<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前置知识本lab大致的要求就是实现malloc、free、initial函数。initial函数就是要初始化堆。 做这个lab之前，需要对一下知识有一个比较清晰的认知。  组织：如何组织空闲块，也就是如何初始化堆。 放置：如何放置一个新分配的块。 分割：因分配的块放到空闲块之后，如何处理空闲块的剩余部分。 合并：如何处理一个刚刚被释放的块。">
<meta property="og:type" content="article">
<meta property="og:title" content="MallocLab">
<meta property="og:url" content="http://example.com/2024/04/07/MallocLab/index.html">
<meta property="og:site_name" content="fishjump&#39;s blog">
<meta property="og:description" content="前置知识本lab大致的要求就是实现malloc、free、initial函数。initial函数就是要初始化堆。 做这个lab之前，需要对一下知识有一个比较清晰的认知。  组织：如何组织空闲块，也就是如何初始化堆。 放置：如何放置一个新分配的块。 分割：因分配的块放到空闲块之后，如何处理空闲块的剩余部分。 合并：如何处理一个刚刚被释放的块。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240328025003.png">
<meta property="og:image" content="http://example.com/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240328030021.png">
<meta property="og:image" content="http://example.com/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240407202028.png">
<meta property="og:image" content="http://example.com/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240405172834.png">
<meta property="og:image" content="http://example.com/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240406165037.png">
<meta property="og:image" content="http://example.com/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240405172834.png">
<meta property="og:image" content="http://example.com/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240407195326.png">
<meta property="article:published_time" content="2024-04-07T12:28:33.000Z">
<meta property="article:modified_time" content="2024-04-07T12:28:33.539Z">
<meta property="article:author" content="fishjump">
<meta property="article:tag" content="csapp">
<meta property="article:tag" content="lab">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240328025003.png">

<link rel="canonical" href="http://example.com/2024/04/07/MallocLab/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MallocLab | fishjump's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="fishjump's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fishjump's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">fly,fly,fly</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/07/MallocLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/dog.jpg">
      <meta itemprop="name" content="fishjump">
      <meta itemprop="description" content="一万年太久，只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fishjump's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MallocLab
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 20:28:33" itemprop="dateCreated datePublished" datetime="2024-04-07T20:28:33+08:00">2024-04-07</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>本lab大致的要求就是实现malloc、free、initial函数。initial函数就是要初始化堆。</p>
<p>做这个lab之前，需要对一下知识有一个比较清晰的认知。</p>
<ul>
<li>组织：如何组织空闲块，也就是如何初始化堆。</li>
<li>放置：如何放置一个新分配的块。</li>
<li>分割：因分配的块放到空闲块之后，如何处理空闲块的剩余部分。</li>
<li>合并：如何处理一个刚刚被释放的块。</li>
</ul>
<span id="more"></span>

<h3 id="组织空闲块"><a href="#组织空闲块" class="headerlink" title="组织空闲块"></a>组织空闲块</h3><p>有这样几种方法可以组织空闲块：采用隐式空闲链表、采用显示空闲链表</p>
<h4 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h4><p>块的格式：<img src="/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240328025003.png"></p>
<p>规定块是双字（8字节）对齐的，也就是块的大小总是8的倍数，所以后三位总是为0，这空出来的三位就来表示状态信息。而剩余的29个高位用来存放块的大小。假设有一个分配的块，大小为24字节，那么其头部状态为</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0x18</span> | <span class="number">0</span>x1   =  <span class="number">0</span>x19         //<span class="number">1</span>为状态为，表示已分配</span><br></pre></td></tr></table></figure>

<p>对于一个大小为24字节，没有被分配的块，其头部为</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0x18</span> | <span class="number">0</span>x0   =  <span class="number">0</span>x18</span><br></pre></td></tr></table></figure>

<p>头部的后面就是有效载荷。有效载荷后面是一片不使用的填充快，其大小是任意的。最后的填充快可以用来对付外部碎片或者满足对齐要求。</p>
<p>每一个块都如此，组织成一个连续的已分配块和空闲块的序列：<img src="/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240328030021.png"></p>
<p>这种数据结构叫做隐式空闲链表，因为空闲块是通过头部中的大小字段隐含的连接着的。分配器可以通过遍历堆中的所有块从而间接地遍历空闲块集合。最后有一个大小为0而显示已分配的块是终止头部，用来标记结束块。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x0 | <span class="number">0</span>x1    <span class="regexp">//</span>终止头部</span><br></pre></td></tr></table></figure>

<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>简单</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>效率低。任何操作都需要堆空闲链表进行搜索，搜索时间与块的总数呈线性关系。</p>
<h4 id="显示空闲链表"><a href="#显示空闲链表" class="headerlink" title="显示空闲链表"></a>显示空闲链表</h4><p>块的样式：</p>
<p><img src="/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240407202028.png"></p>
<p>以后补充。。。</p>
<h3 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h3><p>当请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大的块。分配器的搜索方式是由防止策略确定的，常见的策略有：<strong>首次适配</strong>、<strong>下一次适配</strong>、<strong>最佳适配</strong>。</p>
<h4 id="首次适配"><a href="#首次适配" class="headerlink" title="首次适配"></a>首次适配</h4><p>从又开始搜索空闲链表，选择第一个合适的空闲块。</p>
<h4 id="下一次适配"><a href="#下一次适配" class="headerlink" title="下一次适配"></a>下一次适配</h4><p>和首次适配相似，只是起点不是链表的头部而是上一次查询结束的的地方。</p>
<h4 id="最佳适配"><a href="#最佳适配" class="headerlink" title="最佳适配"></a>最佳适配</h4><p>最佳适配检查每个空闲块，选择适合所需请求大小的最小空闲块。</p>
<h3 id="分割策略"><a href="#分割策略" class="headerlink" title="分割策略"></a>分割策略</h3><p>匹配到合适的空闲块之后，可以选择占用整个空闲块，也可以选择分割为两部分，一部分变为分配块，剩下的部分变成一个新的空闲块。</p>
<h3 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h3><p>合并空闲块时必要的，否则会产生大量的内存碎片。</p>
<h4 id="立即合并"><a href="#立即合并" class="headerlink" title="立即合并"></a>立即合并</h4><p>每次一个块被释放时就合并所有的相邻块。</p>
<h4 id="推迟合并"><a href="#推迟合并" class="headerlink" title="推迟合并"></a>推迟合并</h4><p>等到某个稍晚的时候合并，例如知道分配请求失败，然后扫描整个堆，合并所有的空闲块。</p>
<h3 id="获取额外的堆空间"><a href="#获取额外的堆空间" class="headerlink" title="获取额外的堆空间"></a>获取额外的堆空间</h3><p>思考这样一种情况，在合并了所有的相邻空闲块之后，还是找不到一块足够大的空闲块来防止请求块，应该怎么办？</p>
<p>遇到这种情况，分配器会通过调用sbrk函数，向内核请求额外的堆内存，分配器将额外的内存转为一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。</p>
<h2 id="尝试实现一个简单的分配器"><a href="#尝试实现一个简单的分配器" class="headerlink" title="尝试实现一个简单的分配器"></a>尝试实现一个简单的分配器</h2><p>分配器说明：</p>
<ul>
<li>基于隐式空闲链表</li>
<li>使用立即边界合并</li>
<li>最大的块大小为4GB</li>
</ul>
<p>分配器使用memlib.c包所提供的内存系统模型，模型的目的在于允许我们在不干涉已存在的系统层malloc包的情况下运行分配器。</p>
<p>mm_init函数将对于队来说的可用的虚拟内存模型化为一个大的、双字对齐的字节数组。在mm_heap和mm_brk之间的字节表示已分配的虚拟内存。分配器通过mm_sbrk函数来请求额外的堆内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_heap;     <span class="comment">//指向堆的第一个字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_brk;      <span class="comment">//指向堆的最后一个字节+1 （堆指针）</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_max_addr;  <span class="comment">//最大堆合法地址+1处</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化内存系统模型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span>          <span class="comment">//注意这里不是初始化堆的mm_init</span></span><br><span class="line">&#123;</span><br><span class="line">   mem_heap=(<span class="type">char</span>*)Malloc(MAX_HEAP);</span><br><span class="line">   mem_brk=(<span class="type">char</span>*)mem_heap;        <span class="comment">//此时指向堆顶</span></span><br><span class="line">   mem_max_addr=(<span class="type">char</span>*)(mem_heap+MAX_HEAP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mem_sbrk</span><span class="params">(<span class="type">int</span> incr)</span>       <span class="comment">//还函数用来扩展堆，改变堆指针，如果改变成功，则指向新内存的首地址</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *old_brk=mem_brk;        <span class="comment">//保存</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((incr&lt;<span class="number">0</span>)||((mem_brk+incr)&gt;mem_max_addr))       <span class="comment">//检查参数是否合法，同时检测是否会越界</span></span><br><span class="line">    &#123;</span><br><span class="line">        errno=ENOMEM;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;ERROR: mem_sbrk failed.RAN out of memory...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mem_brk+=incr;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)old_brk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书中提供了一组常数和宏来简化空闲链表操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4     <span class="comment">//字、头部、尾部的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8     <span class="comment">//双字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1&lt;&lt;12)        <span class="comment">//按照该大小扩展堆</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x)&gt;(y)?(x):(y))</span></span><br><span class="line"><span class="comment">//#difien MIN(x,y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打包（size）和已分配位到一个字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size,alloc)  ((size)|(alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读、写一个p地址的字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p)   (*(unsigned int*)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p,val)  (*(unsigned int*)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取块的大小、获取分配状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p)&amp;~0x7) <span class="comment">//舍弃低三位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p)&amp;0x1) <span class="comment">//取最低位</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据块指针，计算出头和尾</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp)    ((char*)(bp)-WSIZE) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp)    ((char*)(bp)+GET_SIZE(HDRP(bp))-DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据块指针计算后一个块、前一个块的地址   （是有效存储位置）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp)  ((char*)(bp)+GET_SIZE(((char*)(bp)-WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp)  ((char*)(bp)-GET_SIZE(((char*)(bp)-DSIZE)))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h3><p>在调用mm_malloc或者mm_free之前，必须用过mm_init函数来初始化堆。如果分配成功就返回0，否则返回-1。mm_init函数从内存系统得到四个字，并将它们初始化，创建一个空的空闲链表。然后调用extend_heap函数将堆扩展CHUNKSIZE字节，并创建初始的空闲块。<img src="/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240405172834.png"></p>
<p>隐式空闲链表如图所示。第一个字是一个双字对齐的不使用的填充字，填充后面跟一个序言块（一个八字节的已分配块），只由头和尾组成。序言块在初始化时创建，并且永不释放。序言块后面是零个或者多个已块。结尾有一个特殊的结尾块，这个块是一个大小为零的已分配块，并且只由一个头部组成。分配器使用一个私有全局变量heap_list指向序言块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">//创建初始空堆       mem_sbrk(4*4) 返回值为之前的mem_brk即原始堆顶，经此次调用，堆扩展16字节，mem_brk指向新的堆顶，即结尾块。</span></span><br><span class="line">    <span class="keyword">if</span>((heap_list=mem_sbrk(<span class="number">4</span>*WSIZE))==(<span class="type">void</span>*)<span class="number">-1</span>)    <span class="comment">//如果分配失败则返回-1，若成功，此时的heap_list指向堆的首字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_list,<span class="number">0</span>);  <span class="comment">//用来双字对齐的不使用的填充字</span></span><br><span class="line">    PUT(heap_list+(<span class="number">1</span>*WSIZE),PACK(DSIZE,<span class="number">1</span>));     <span class="comment">//序言块的头和尾</span></span><br><span class="line">    PUT(heap_list+(<span class="number">2</span>*WSIZE),PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_list+(<span class="number">3</span>*WSIZE),PACK(<span class="number">0</span>,<span class="number">1</span>));        <span class="comment">//结尾块</span></span><br><span class="line">    heap_list+=(<span class="number">2</span>*WSIZE);    <span class="comment">//heap_list指向第二个序言块，如上图所示</span></span><br><span class="line">    <span class="comment">//printf(&quot;初始化空闲链表成功\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//扩展空堆</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE)==<span class="literal">NULL</span>)      <span class="comment">//初次分配扩展   1&lt;&lt;12/4    即1024个字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;初始化成功\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>extend_heap函数会在两种不同的环境中被调用：1.当堆被初始化时；2.当mm_malloc不能找到一个合适的匹配块时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">   </span><br><span class="line">    size=(words%<span class="number">2</span>)?(words+<span class="number">1</span>)*WSIZE:words*WSIZE;     <span class="comment">//确保双字对齐</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="type">long</span>)(bp=mem_sbrk(size))==<span class="number">-1</span>)   <span class="comment">//分配失败</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化            上文如果mem_sbrk调用成功，bp的值修改为mem_brk的初始值，即堆结尾（结尾块的后面），然后mem_brk修改为新的堆顶地址</span></span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));     <span class="comment">//HERP(bp)  ((char*)(bp)-WSIZE)  将原始的结尾块更新为一个大的块(1024字)的头部，状态为未分配。</span></span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));      <span class="comment">//新块的尾部</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)),PACK(<span class="number">0</span>,<span class="number">1</span>));    <span class="comment">//然后将新块的尾部的后一个字节更改成新的尾部</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);     <span class="comment">//  合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的合并书中实现的是隐式空闲链表的立即合并策略</p>
<p>有且仅有四种情况：</p>
<ol>
<li>前面已分配、后面已分配</li>
<li>前面已分配、后面为分配</li>
<li>前面未分配、后面已分配</li>
<li>前面未分配、后面未分配</li>
</ol>
<p><img src="/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240406165037.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span>    <span class="comment">//传入的参数bp是当前块的有效存储位置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp)));    <span class="comment">//获取前后块的分配状态</span></span><br><span class="line">    <span class="type">size_t</span> next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> size=GET_SIZE(HDRP(bp));      <span class="comment">//获取当前块的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)     <span class="comment">//情况一，前后都已分配</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)    <span class="comment">//前分 后未分 此时要合并当前块和后续块  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//修改当前块的头部和后继块的尾部</span></span><br><span class="line">        size+=GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)    <span class="comment">//前未分、后已分</span></span><br><span class="line">    &#123;</span><br><span class="line">        size+=GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//PUT(FTRP(bp),PACK(size,0));</span></span><br><span class="line">        <span class="comment">//更新bp使其指向合并块的起始有效存储位置</span></span><br><span class="line">        bp=PREV_BLKP(bp);      <span class="comment">//在调用PREV_BLKP的时候bp块的头部还是原始值。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size+=(GET_SIZE(HDRP(PREV_BLKP(bp)))+GET_SIZE(HDRP(NEXT_BLKP(bp))));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp=PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h3><p>将指定块释放，也就是将它的标记为改为未分配，在最后再进行一次合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size=GET_SIZE(HDRP(bp));</span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h3><ol>
<li>判断参数是否合法</li>
<li>计算实际分配大小</li>
<li>寻找合适的块，更改头部和尾部</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;        <span class="comment">//实际分配大小</span></span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)        <span class="comment">//判断请求是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//计算实际要分配的大小 </span></span><br><span class="line">    <span class="keyword">if</span>(size&lt;=DSIZE)</span><br><span class="line">        asize=<span class="number">2</span>*DSIZE;   <span class="comment">//如果请求小于一个字，那么直接分配最小块大小即四个字（块是双字对齐的，头和尾占两个字）</span></span><br><span class="line">    <span class="keyword">else</span>             <span class="comment">//假设size大小为9 则asize应该为8+2*8 24字节</span></span><br><span class="line">        asize=DSIZE*((size+(DSIZE)+(DSIZE<span class="number">-1</span>))/DSIZE);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//搜索空闲链表找到一个合适的块</span></span><br><span class="line">    <span class="keyword">if</span>((bp=find_fit(asize))!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp,asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找不到一个合适的块</span></span><br><span class="line">    extendsize=MAX(asize,CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span>((bp=extend_heap(extendsize/WSIZE))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp,asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不能发现一个匹配的块，那么就扩展堆。</p>
<p>如何实现遍历隐式空闲链表？需要注意的是要适配首次搜索。首次搜索的时候只有一个块，即堆扩展产生的一个1024字的大块。要用到heap_list遍历，首次搜索的时候他还指向第二个序言块。</p>
<p><img src="/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240405172834.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span>      <span class="comment">//搜索成功则返回块地址，失败则返回NULL</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* bp;</span><br><span class="line">    <span class="keyword">for</span>(bp=heap_list;GET_SIZE(HDRP(bp))&gt;<span class="number">0</span>;bp=NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (GET_SIZE(HDRP(bp))&gt;=asize))  <span class="comment">//同时满足未分配和大小</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>place函数要实现的功能：设置头部，如果剩余块的大小大于最小块即四字，则进行分割</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span>* bp,<span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size=GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(size-asize&gt;=(<span class="number">2</span>*DSIZE))   <span class="comment">//进行分割</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//剩余块</span></span><br><span class="line">        bp=NEXT_BLKP(bp);       <span class="comment">//指向下一个快</span></span><br><span class="line">        PUT(HDRP(bp),PACK(size-asize,<span class="number">0</span>));     <span class="comment">//设置新块的头和尾</span></span><br><span class="line">        PUT(FTRP(bp),PACK(size-asize,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>

<p>该函数返回一个指针，指向重新分配的地址。如果失败则返回NULL。</p>
<p>如果ptr为NULL，则会分配一个指定大小的块并返回一个指向它的指针。</p>
<p>如果ptr不为NULL，那么ptr就是指向一个需要重新分配的内存块，此时判断size，size为指定重新分配的大小，如果size为0那么释放该块并返回一个空指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *newptr=<span class="literal">NULL</span>;</span><br><span class="line">    newptr=mm_malloc(size);    <span class="comment">//新分配的指定大小的块</span></span><br><span class="line">    <span class="comment">//如果ptr是空的，且newptr分配成功，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(!ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr为NULL,直接分配\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> newptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果非空，则需要复制一下数据</span></span><br><span class="line">    <span class="type">size_t</span> copy_size=size;      </span><br><span class="line">    <span class="type">size_t</span> before_size=GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span>(size&gt;before_size)</span><br><span class="line">    &#123;</span><br><span class="line">        copy_size=before_size;   <span class="comment">//全复制</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;copy_size=%d\n&quot;,copy_size);</span></span><br><span class="line">    <span class="built_in">memcpy</span>(newptr,ptr,copy_size);</span><br><span class="line">    mm_free(ptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调试策略"><a href="#调试策略" class="headerlink" title="调试策略"></a>调试策略</h3><p>可以使用printf辅助调试，可以在关键代码附近打印相关数值，比如在最后的realloc实现中刚开始有些问题，导致测试不通过，提示信息是未能将原块内容复制到新块。然后我就在这里面插了个printf打印copysize，发现打印的结果为copy_size&#x3D;0，然后就发现问题出现在before那里，使用GET_SIZE(bp)获取了块的大小，因为bp指向的是有效载荷而不是头部，所以正确的做法就是改为GET_SIZE(HDRP(bp))。</p>
<h2 id="测试优化"><a href="#测试优化" class="headerlink" title="测试优化"></a>测试优化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make       //编译生成驱动程序</span><br><span class="line"></span><br><span class="line">./mdriver -V       //-V参数展示详细信息</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/07/MallocLab/QQ%E6%88%AA%E5%9B%BE20240407195326.png"></p>
<p>通过上述代码，实现了一个基于<strong>隐式空闲链表</strong>、采用<strong>首次适配</strong>、<strong>立即合并策略</strong>的分配器，得了72分。</p>
<p>优化以后再研究，现在实在没什么兴趣。。。。。   看见空间利用率、吞吐量我就头疼。。。。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/csapp/" rel="tag"># csapp</a>
              <a href="/tags/lab/" rel="tag"># lab</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/25/GWCTF2019babyvm/" rel="prev" title="VM逆向，一篇就够了（上）">
      <i class="fa fa-chevron-left"></i> VM逆向，一篇就够了（上）
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/04/07/%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9baby-decomp/" rel="next" title="铁人三项baby_decomp">
      铁人三项baby_decomp <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E7%BB%87%E7%A9%BA%E9%97%B2%E5%9D%97"><span class="nav-number">1.1.</span> <span class="nav-text">组织空闲块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">隐式空闲链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.2.</span> <span class="nav-text">显示空闲链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5"><span class="nav-number">1.2.</span> <span class="nav-text">放置策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E9%85%8D"><span class="nav-number">1.2.1.</span> <span class="nav-text">首次适配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E6%AC%A1%E9%80%82%E9%85%8D"><span class="nav-number">1.2.2.</span> <span class="nav-text">下一次适配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E9%85%8D"><span class="nav-number">1.2.3.</span> <span class="nav-text">最佳适配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E7%AD%96%E7%95%A5"><span class="nav-number">1.3.</span> <span class="nav-text">分割策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.</span> <span class="nav-text">合并策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%8B%E5%8D%B3%E5%90%88%E5%B9%B6"><span class="nav-number">1.4.1.</span> <span class="nav-text">立即合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A8%E8%BF%9F%E5%90%88%E5%B9%B6"><span class="nav-number">1.4.2.</span> <span class="nav-text">推迟合并</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%A2%9D%E5%A4%96%E7%9A%84%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="nav-number">1.5.</span> <span class="nav-text">获取额外的堆空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%9D%E8%AF%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">尝试实现一个简单的分配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mm-init"><span class="nav-number">2.1.</span> <span class="nav-text">mm_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mm-free"><span class="nav-number">2.2.</span> <span class="nav-text">mm_free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mm-malloc"><span class="nav-number">2.3.</span> <span class="nav-text">mm_malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mm-realloc"><span class="nav-number">2.4.</span> <span class="nav-text">mm_realloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E7%AD%96%E7%95%A5"><span class="nav-number">2.5.</span> <span class="nav-text">调试策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BC%98%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">测试优化</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fishjump"
      src="/uploads/dog.jpg">
  <p class="site-author-name" itemprop="name">fishjump</p>
  <div class="site-description" itemprop="description">一万年太久，只争朝夕</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Fishjump-MY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Fishjump-MY" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1745482102@qq.com" title="E-Mail → 1745482102@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <!---->

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fishjump</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">87k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:17</span>
</div>


<script async="" src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/fireworks.js"></script>
  
  
</body>
</html>
