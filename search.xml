<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022极客大挑战</title>
    <url>/2022/12/21/2022%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>GoogleCTF</title>
    <url>/2023/06/27/GoogleCTF/</url>
    <content><![CDATA[<h1 id="oldschool"><a href="#oldschool" class="headerlink" title="oldschool"></a>oldschool</h1><p>当时做的时候就很奇怪，为什么单步调试输入相应的用户名和密码就显示success，而直接运行程序提交相同的数据就是错误，更奇怪的是当时写的脚本能更正确解除第一组，而后面的矩阵用z3求逆都出现了问题，当时只是怀疑加了反调试修改了数据，但又不知从何处检查。。。。。。</p>
<span id="more"></span>

<p>查看交叉引用，发现第一处反调试</p>
<p><img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627162148.png"></p>
<p>如果检查到正在调试该值加上7。</p>
<p><img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627162100.png"></p>
<p>直接查看负责检查调试的那个函数的交叉引用，即可将所有的反调试一网打尽。<img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627162706.png"></p>
<p>下一处是<img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627162948.png"></p>
<p>如果检查到调试，会对选中的这个数组进行异或处理，正常情况下是异或上2，这里是异或上了4。<img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627163209.png"></p>
<p>第三处在这里<img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627162651.png"></p>
<p><img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627164040.png"></p>
<p>找到这三处反调试，在运算之前下一个断点，ida动态调试，找的if——debug这个参数，可以看到他的值为1，我们直接将其改成0即可，后面的数据就全都是正确的了。<img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627182900.png"></p>
<p><img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627181844.png"></p>
<p>这个脚本和之前的脚本只有两处区别，其一是填充的matx矩阵不同，也就是v18的值，我们只要在v18之后设置断点，然后读出数据即可(v18的数据收到反调试的影响)，其二就是xor_arr这个异或矩阵，这个异或矩阵也是收到了反调试的影响。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matx = [[<span class="number">0x12</span>, <span class="number">0x1D</span>, <span class="number">0x10</span>, <span class="number">0x13</span>, <span class="number">0x1B</span>],</span><br><span class="line">        [<span class="number">0x8</span>, <span class="number">0x1F</span>, <span class="number">0x8</span>, <span class="number">0x17</span>, <span class="number">0x1E</span>],</span><br><span class="line">        [<span class="number">0x1D</span>, <span class="number">0x3</span>, <span class="number">0x1C</span>, <span class="number">0xA</span>, <span class="number">0x15</span>],</span><br><span class="line">        [<span class="number">0x12</span>, <span class="number">0x1D</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x1C</span>],</span><br><span class="line">        [<span class="number">0x0B</span>, <span class="number">0x1E</span>, <span class="number">0x07</span>, <span class="number">0x14</span>, <span class="number">0x07</span>],]  <span class="comment">#这里填v18，username加密后的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">rows = <span class="number">5</span></span><br><span class="line">cols = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">arr = [[z3.BitVec(<span class="string">f&#x27;arr_<span class="subst">&#123;i&#125;</span>_<span class="subst">&#123;j&#125;</span>&#x27;</span>, <span class="number">6</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">s = Solver() </span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(5):</span></span><br><span class="line"><span class="comment">#     for j in range(5):</span></span><br><span class="line"><span class="comment">#         s.add(arr[i][j] &gt;= 0)</span></span><br><span class="line"><span class="comment">#         s.add(arr[i][j] &lt;= 0x7f)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        v28 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            v28 = ((arr[i][m]&amp;<span class="number">0xff</span>) * (matx[k][i]&amp;<span class="number">0xff</span>) + (v28&amp;<span class="number">0xff</span>)) &amp; <span class="number">0x1f</span></span><br><span class="line">        <span class="keyword">if</span> k == m:</span><br><span class="line">            s.add(v28 == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> k != m:</span><br><span class="line">            s.add(v28 == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">inv = []</span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    model = s.model()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        row = [model.evaluate(arr[i][j]).as_long() <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols)]</span><br><span class="line">        inv.append(row)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;err&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;v18的逆矩阵为:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第n列循环右移n字节</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inv)):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">4</span>:</span><br><span class="line">        inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>] = inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>], inv[i][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">3</span>:</span><br><span class="line">        inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>] = inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>], inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">2</span>:</span><br><span class="line">        inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>] = inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>], inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">        inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>] = inv[i][<span class="number">4</span>], inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调换位置后的逆矩阵:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"></span><br><span class="line">xor_arr = [[<span class="number">0x1B</span>, <span class="number">0x00</span>, <span class="number">0x0A</span>, <span class="number">0x0D</span>, <span class="number">0x08</span>],</span><br><span class="line">           [<span class="number">0x18</span>, <span class="number">0x0F</span>, <span class="number">0x1C</span>, <span class="number">0x06</span>, <span class="number">0x07</span>],</span><br><span class="line">           [<span class="number">0x12</span>, <span class="number">0x05</span>, <span class="number">0x0C</span>, <span class="number">0x02</span>, <span class="number">0x04</span>],</span><br><span class="line">           [<span class="number">0x1D</span>, <span class="number">0x1F</span>, <span class="number">0x09</span>, <span class="number">0x13</span>, <span class="number">0x01</span>],</span><br><span class="line">           [<span class="number">0x1E</span>, <span class="number">0x11</span>, <span class="number">0x0B</span>, <span class="number">0x16</span>, <span class="number">0x19</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        inv[k][m] ^= xor_arr[k][m]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;异或后的矩阵:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"></span><br><span class="line">index_arr = [<span class="number">0x00000010</span>, <span class="number">0x0000000E</span>, <span class="number">0x0000000D</span>, <span class="number">0x00000002</span>, <span class="number">0x0000000B</span>, <span class="number">0x00000011</span>, <span class="number">0x00000015</span>, <span class="number">0x0000001E</span>, <span class="number">0x00000007</span>, <span class="number">0x00000018</span>, <span class="number">0x00000012</span>, <span class="number">0x0000001C</span>, <span class="number">0x0000001A</span>, <span class="number">0x00000001</span>, <span class="number">0x0000000C</span>, <span class="number">0x00000006</span>, <span class="number">0x0000001F</span>, <span class="number">0x00000019</span>, <span class="number">0x00000000</span>, <span class="number">0x00000017</span>, <span class="number">0x00000014</span>, <span class="number">0x00000016</span>, <span class="number">0x00000008</span>, <span class="number">0x0000001B</span>, <span class="number">0x00000004</span>, <span class="number">0x00000003</span>, <span class="number">0x00000013</span>, <span class="number">0x00000005</span>, <span class="number">0x00000009</span>, <span class="number">0x0000000A</span>, <span class="number">0x0000001D</span>, <span class="number">0x0000000F</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        inv[k][m] = index_arr.index(inv[k][m])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;索引:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"></span><br><span class="line">chr_arr = [<span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x41</span>, <span class="number">0x42</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0x46</span>, <span class="number">0x47</span>, <span class="number">0x48</span>, <span class="number">0x4A</span>, <span class="number">0x4B</span>, <span class="number">0x4C</span>, <span class="number">0x4D</span>, <span class="number">0x4E</span>, <span class="number">0x50</span>, <span class="number">0x51</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x55</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x58</span>, <span class="number">0x59</span>, <span class="number">0x5A</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(chr_arr[inv[i][j]]), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>总结：下次遇到这种题目，如果很相信自己的逻辑和脚本，一直不对的话就去查看一下有无反调试。</p>
]]></content>
  </entry>
  <entry>
    <title>angr学习</title>
    <url>/2023/05/28/angr%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>早就听闻了angr，之前看wp也有大佬使用了angr，上一次打开angrctf一头雾水，还要装环境啥的，就先搁置了。现在趁着军训开始angr的学习。</p>
<span id="more"></span>

<p>tnnd两天都没配置好一个虚拟环境，还是在朋友的帮助下搞了个docker，woc真难绷，或许以后有能力了可以搞一个虚拟机，包含所有的逆向需要的环境hhh。一天后来考古，那个docker用起来着实别扭，不知道出了什么问题，不能将主机的文件拷贝到容器中，还有就是用了docker start 容器id也启动不了容器，只好另寻他路，本来想放弃的，可是一想到被这环境折磨三四天了，哎。终于，在wsl的虚拟环境成功搭建！！！</p>
<p>记录一下启动步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#在angr_enviroment打开环境</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> myenv/bin/activate</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#关闭环境</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">deactivate</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/a_touhouer/article/details/106058311">(15条消息) 在wsl上安装angr框架_wsl2下安装angr workon_ljahum的博客-CSDN博客</a></p>
<h1 id="Angr介绍"><a href="#Angr介绍" class="headerlink" title="Angr介绍"></a>Angr介绍</h1><p>看一看官方文档的解释</p>
<blockquote>
<p>angr is a multi-architecture binary analysis toolkit, with the capability to perform dynamic symbolic execution (like Mayhem, KLEE, etc.) and various static analyses on binaries. </p>
<p>angr是一个多架构二进制分析工具包，具有执行动态符号执行（例如Mayhem，KLEE等）和各种静态分析的能力。</p>
</blockquote>
<p>什么叫<strong>符号执行</strong>呢？</p>
<h2 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h2><p>符号执行是一种静态分析技术，是一种计算机科学领域的程序分析技术，通过采用抽象的符号代替精确值作为程序输入变量，得出每个路径抽象的输出结果。 这一技术在硬件、底层程序测试中有一定的应用，能够有效的发现程序中的漏洞。符号执行就是给程序传递一个符号而不是具体的值，让符号伴随程序运行，当遇到分支时angr会保留所有分支以及进入分支的约束条件，最后根据约束条件对我们传递的符号约束求解。这听着有点像全自动z3。</p>
<p>概念有点抽象，不如直接做题。</p>
<h1 id="Angr-CTF"><a href="#Angr-CTF" class="headerlink" title="Angr_CTF"></a>Angr_CTF</h1><p>参考链接：<a href="https://www.bilibili.com/video/BV167411o7WK/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=edc820e8f9bd6b2ea43cb8499151dea3">angr符号执行练习 00_angr_find_哔哩哔哩_bilibili</a></p>
<p>​                   <a href="https://github.com/ZERO-A-ONE/AngrCTF_FITM/blob/master/%E7%AC%94%E8%AE%B0/04/Angr_CTF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%EF%BC%88%E5%9B%9B%EF%BC%89.md">angr从入门到精通</a></p>
<p>​                  <a href="https://xz.aliyun.com/t/7117#toc-14">angr核心概念即模块解读</a></p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul>
<li>创建project</li>
<li>设置state</li>
<li>新建符号量 : BVS (bitvector symbolic ) 或 BVV (bitvector value)</li>
<li>把符号量设置到内存或者其他地方</li>
<li>设置 Simulation Managers ， 进行路径探索的对象</li>
<li>运行，探索满足路径需要的值</li>
<li>约束求解，获取执行结果</li>
</ul>
<h2 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr00</span>():   </span><br><span class="line"><span class="comment">##创建project</span></span><br><span class="line">  path_to_binary=<span class="string">&quot;./home/mzyy/AngerCTF/00_angr_find/00_angr_find&quot;</span></span><br><span class="line">  project=angr.Project(path_to_binary) </span><br><span class="line"></span><br><span class="line"><span class="comment">##设置state  state代表实例镜像，模拟执行某个时刻的状态。</span></span><br><span class="line">  initial_state=project.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="comment">##设置SM,project只是程序最开始的一个状态，我们实际对simulation对象进行操作，他模拟程序某时刻的状态</span></span><br><span class="line">  simulation=project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line"><span class="comment">##运行，探索满足路径需要的值</span></span><br><span class="line">  print_good_address=<span class="number">0x8048678</span>     <span class="comment">##通过ida找到输出good的地址</span></span><br><span class="line">  simulation.explore(find=print_good_address) </span><br><span class="line"><span class="comment">##通过explore(),找到能够到达某个地址的状态，同时丢弃不能达到这个地址的状态</span></span><br><span class="line"><span class="comment">##当启用find参数启动.explore()方法时，程序会一直执行，直到发现一个和find参数指定的条件匹配的状态</span></span><br><span class="line"><span class="comment">##find参数的内容可以是想要执行到的某个地址。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##获取执行结果</span></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state=simulation.found[<span class="number">0</span>]  <span class="comment">##</span></span><br><span class="line">    <span class="built_in">print</span>(solution_state.posix.dumps(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    angr00()</span><br></pre></td></tr></table></figure>

<p>下面是用ipython写的截的图，是跟着B站的一位up主来的。</p>
<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230524112747.png"></p>
<h2 id="01-angr-avoid"><a href="#01-angr-avoid" class="headerlink" title="01_angr_avoid"></a>01_angr_avoid</h2><p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230524174356.png"></p>
<p>反编译main函数时说函数过大无法反编译（可以通过修改ida的设置文件，提高最多分析长度来解决此问题）。这一题实际上也不需要，根据函数名，我们找到avoid_me的地址加到参数中即可。<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230524174747.png"></p>
<p>查看avoid_me的交叉引用，发现巨多。我们可以看到全是main函数在引用，这就是main函数巨大的原因吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr01</span>():</span><br><span class="line">    path=<span class="string">&quot;./angrctf/01_angr_avoid&quot;</span></span><br><span class="line">    p=angr.Project(path)</span><br><span class="line">    init_state=p.factory.entry_state()</span><br><span class="line">    sm=p.factory.simgr(init_state)</span><br><span class="line">    sm.explore(find=<span class="number">0x080485FC</span>,avoid=<span class="number">0x080485BF</span>)</span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    angr01()</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230524181047.png"></p>
<p>这一题就是想让我们知道，避开一些错误的路径可以提高效率，我觉得将上面的avoid删掉一样可以达到目的，不过时间可能会很夸张。哎呀被打脸了，跑了十分钟左右跑出来一个killed。<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230524182422.png"></p>
<p>好吧电脑内存不足，进程被系统杀死了，那如果内存足够大还是能跑出来的吧。提出问题和回答问题的人都好耐心好有礼貌^_^</p>
<h2 id="02-angr-find-condition"><a href="#02-angr-find-condition" class="headerlink" title="02_angr_find_condition"></a>02_angr_find_condition</h2><p>很显然这次不能通过输出good job的地址来解题了，因为这一题故意设置了很多跳转，使用了多次put good job和多次put try again。根据作者的注释，在一些情况下我们可能不知道要达到的指令的地址，或者没有特定的指令目标。在这种情况下，我们只要知道一种状态，例如在某状态下二进制文件打印出“Good Job”。angr提供了一种功能强大的方法：允许搜索满足任意条件的状态。具体来讲，我们可以使用一个函数来定义一个状态，该函数接收一个state作为参数，并返回True或false表示该状态是否满足要求。当程序找到一个符合条件的状态时，他就会停止搜索。具体看下面这函数，它检查状态的标准输出是否包含字符串 “Good Job.”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful_state</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&quot;Good Job.&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h3 id="find的用法"><a href="#find的用法" class="headerlink" title="find的用法"></a>find的用法</h3><p>除了地址之外，<code>find</code> 参数还可以是一个函数，该函数接受一个路径（<code>path</code>）作为参数，并返回一个布尔值。当该函数返回 <code>True</code> 时，路径组将停止探索。例如，以下代码使用 <code>find</code> 方法搜索二进制文件中所有包含 <code>win_function</code> 函数的路径，并打印出对应的输入数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/path/to/binary&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">pg = proj.factory.path_group(state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">win_function</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Congratulations!&quot;</span> <span class="keyword">in</span> path.state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pg.explore(find=win_function)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> found <span class="keyword">in</span> pg.found:</span><br><span class="line">    <span class="built_in">print</span>(found.state.posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>win_function</code> 是一个用于检查路径是否包含特定输出的函数。在探索过程中，每当发现一个路径包含 <code>win_function</code> 函数并生成相应的结论时，路径组将停止探索，并输出相应的输入数据。</p>
<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230525002345.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    p=angr.Project(path)</span><br><span class="line">    init_state=p.factory.entry_state()</span><br><span class="line">    sm=p.factory.simgr(init_state)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isGood</span>(<span class="params">sm</span>):<span class="comment">##sm是我们实际操作的状态，也可以用state代替</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;Good Job.&quot;</span> <span class="keyword">in</span> sm.posix.dumps(<span class="number">1</span>):<span class="comment">##dumps(1)是标准输出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBad</span>(<span class="params">sm</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;Try again.&quot;</span> <span class="keyword">in</span> sm.posix.dumps(<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    sm.explore(find=isGood,avoid=isBad)</span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="03-angr-symbolic-registers"><a href="#03-angr-symbolic-registers" class="headerlink" title="03_angr_symbolic_registers"></a>03_angr_symbolic_registers</h2><p>根据当时作者的说明，Angr目前不支持使用scanf一次读取多个变量（例如：# scanf(“%u %u)）。您需要告诉仿真引擎在调用scanf后开始程序，并手动将符号注入寄存器。据说现在可以了，但学一下总没有坏处，能从中体会到angr的灵活。</p>
<p>首先呢确定进入的地址，就在scanf之后，0x080488C7<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230525022032.png"></p>
<p>进去之后呢因为我们跳过了scanf所以把它的参数放到该有的位置，也就是寄存器eax，ebx，edx中<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230525022100.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line"> path=argv[<span class="number">1</span>]</span><br><span class="line"> p=angr.Project(path)</span><br><span class="line"> start_address=<span class="number">0x080488C7</span></span><br><span class="line"><span class="comment">##注意这里和之前不同，之前是factory.entry_state()</span></span><br><span class="line"> init_state=p.factory.blank_state(addr=start_address)</span><br><span class="line">    </span><br><span class="line"><span class="comment">##创建三个向量，和z3差不多，第一个pass0是符号变量名称，第二个pass0是该位宽变量的字符串标识符，后面的32指大小</span></span><br><span class="line"> pass0=claripy.BVS(<span class="string">&#x27;pass0&#x27;</span>,<span class="number">32</span>)</span><br><span class="line"> pass1=claripy.BVS(<span class="string">&#x27;pass1&#x27;</span>,<span class="number">32</span>)</span><br><span class="line"> pass2=claripy.BVS(<span class="string">&#x27;pass2&#x27;</span>,<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##将符号放进寄存器</span></span><br><span class="line"> init_state.regs.eax=pass0</span><br><span class="line"> init_state.regs.ebx=pass1</span><br><span class="line"> init_state.regs.edx=pass2</span><br><span class="line"></span><br><span class="line"> sm=p.factory.simgr(init_state)</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> sm.found:</span><br><span class="line">  soulution_state=sm.found[<span class="number">0</span>]</span><br><span class="line"><span class="comment">##注意这里不能使用print(solution_state.posix.dumps(0)),至于为什么呢，因为我们跳过了输入？</span></span><br><span class="line"><span class="comment">##约束求解，pass012代表的是状态，password012则是达到对应状态的输入</span></span><br><span class="line">  password0=soulution_state.solver.<span class="built_in">eval</span>(pass0)</span><br><span class="line">  password1=soulution_state.solver.<span class="built_in">eval</span>(pass1)</span><br><span class="line">  password2=soulution_state.solver.<span class="built_in">eval</span>(pass2)</span><br><span class="line"><span class="comment">##&#123;:x&#125;,16进制输出</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;&#123;:x&#125; &#123;:x&#125; &#123;:x&#125;&quot;</span>.<span class="built_in">format</span>(password0,password1,password2))</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;no found&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230525025228.png"></p>
<h2 id="04-angr-symbolic-stack"><a href="#04-angr-symbolic-stack" class="headerlink" title="04_angr_symbolic_stack"></a>04_angr_symbolic_stack</h2><p>做这一题之前需要回顾一下栈帧，在看《逆向工程核心原理》的时候了解过。</p>
<h3 id="栈帧-函数调用"><a href="#栈帧-函数调用" class="headerlink" title="栈帧 函数调用"></a>栈帧 函数调用</h3><ol>
<li>通过push指令传参</li>
<li>将call指令的下一条指令的地址压入栈中作为返回地址</li>
<li>push ebp 保存ebp的原始值 ebp稍后会被用作栈帧指针</li>
<li>mov ebp,esp 直到函数返回前ebp中的值都是esp的初始值 我们可以通过ebp安全的访问栈中的函数参数与局部变量</li>
<li>.sub esp，x这里的x依局部变量而变，如果局部变量为两个long类型（4字节）则此处的x应该为8</li>
<li>借助mov指令和ebp创建局部变量</li>
<li>删除栈帧 mov esp，ebp（恢复栈指针），pop ebp（恢复ebp）</li>
<li>retn</li>
<li>返回原来位置后，add esp，x测出的x根据步骤0穿入的参数而定，这一步的目的是将参数从栈中清理</li>
</ol>
<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230525225636.png"></p>
<p>上一个题目的scanf是单独使用的，就是将我们的输入放入栈中然后再传到寄存器，所以我们只要跳到scanf执行完之后将输入放入寄存器即可。而这一题，是直接将我们的输入当作临时变量使用，即通过栈指针访问，那么我们跳过scanf之后，函数预留的那两个临时变量的位置是空的，所以我们要对栈进行操作，将函数正确的放入栈中。看上面的图，调用scanf的时候利用寄存器从右往左传参，var_10和var_c分别是第二个参数和第一个参数，所以我们将创建的符号变量依次放入ebp+var_C和ebp+var_10处即可。<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230526010927.png"></p>
<p>从ida我们可以看出，这个函数第二行sub   esp, 18h，实际上堆栈空间是0x18，但是在实际的做题中我们只是用到了那两个参数，我们就恢复了0x8.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    start_address=<span class="number">0x080486AE</span></span><br><span class="line">    init_state=project.factory.blank_state(addr=start_address)</span><br><span class="line">    </span><br><span class="line">    pass0=claripy.BVS(<span class="string">&#x27;pass0&#x27;</span>,<span class="number">32</span>)</span><br><span class="line">    pass1=claripy.BVS(<span class="string">&#x27;pass1&#x27;</span>,<span class="number">32</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">##由于我们跳转到了函数的中间，所以跳过了栈初始化的过程，我们要对其进行必要的还原</span></span><br><span class="line">    init_state.regs.ebp=init_state.regs.esp</span><br><span class="line">    padding_size=<span class="number">0x8</span></span><br><span class="line">    init_state.regs.esp-=padding_size</span><br><span class="line"></span><br><span class="line"><span class="comment">##将我们的输入放入正确的位置</span></span><br><span class="line">    init_state.stack_push(pass0)   <span class="comment">## 先压入参数1</span></span><br><span class="line">    init_state.stack_push(pass1)</span><br><span class="line"></span><br><span class="line">    sm=project.factory.simulation_manager(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        password0=solution_state.solver.<span class="built_in">eval</span>(pass0)</span><br><span class="line">        password1=solution_state.solver.<span class="built_in">eval</span>(pass1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &quot;</span>.<span class="built_in">format</span>(password0,password1))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230526010422.png"></p>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><ul>
<li><code>solver.eval(expression)</code> 将会解出一个可行解</li>
<li><code>solver.eval_one(expression)</code>将会给出一个表达式的可行解，若有多个可行解，则抛出异常。</li>
<li><code>solver.eval_upto(expression, n)</code>将会给出最多n个可行解，如果不足n个就给出所有的可行解。</li>
<li><code>solver.eval_exact(expression, n)</code>将会给出n个可行解，如果解的个数不等于n个，将会抛出异常。</li>
<li><code>solver.min(expression)</code>将会给出最小可行解</li>
<li><code>solver.max(expression)</code>将会给出最大可行解</li>
</ul>
<h2 id="05-angr-symbolic-memory"><a href="#05-angr-symbolic-memory" class="headerlink" title="05_angr_symbolic_memory"></a>05_angr_symbolic_memory</h2><p>修改了寄存器，修改了栈，这一次开始修改内存了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">  path=argv[<span class="number">1</span>]</span><br><span class="line">  project=angr.Project(path)</span><br><span class="line">  start_address=<span class="number">0x08048618</span></span><br><span class="line">  init_state=project.factory.blank_state(addr=start_address)</span><br><span class="line"><span class="comment">##%8s 即8个字符</span></span><br><span class="line">  passwd0=claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>,<span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">  passwd1=claripy.BVS(<span class="string">&#x27;passwd1&#x27;</span>,<span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">  passwd2=claripy.BVS(<span class="string">&#x27;passwd2&#x27;</span>,<span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">  passwd3=claripy.BVS(<span class="string">&#x27;passwd3&#x27;</span>,<span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">  passwd0_address=<span class="number">0x0AB232C0</span></span><br><span class="line">  passwd1_address=<span class="number">0x0AB232C8</span></span><br><span class="line">  passwd2_address=<span class="number">0x0AB232D0</span></span><br><span class="line">  passwd3_address=<span class="number">0x0AB232D8</span></span><br><span class="line"><span class="comment">##本题的不同，操作内存，store(address,value),value包含了大小</span></span><br><span class="line">  init_state.memory.store(passwd0_address,passwd0)</span><br><span class="line">  init_state.memory.store(passwd1_address,passwd1)</span><br><span class="line">  init_state.memory.store(passwd2_address,passwd2)</span><br><span class="line">  init_state.memory.store(passwd3_address,passwd3)</span><br><span class="line">  </span><br><span class="line">  sm=project.factory.simgr(init_state)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">  sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line"><span class="comment">##cast_to=byte 将passwd转化为字节序列，decode方法将其解码为字符串</span></span><br><span class="line">  <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        password0=solution_state.solver.<span class="built_in">eval</span>(passwd0,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        password1=solution_state.solver.<span class="built_in">eval</span>(passwd1,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        password2=solution_state.solver.<span class="built_in">eval</span>(passwd2,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        password3=solution_state.solver.<span class="built_in">eval</span>(passwd3,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &quot;</span>.<span class="built_in">format</span>(password0,password1,password2,password3))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no found&quot;</span>)</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230526143721.png"></p>
<h2 id="06-angr-symbolic-dynamic-memory"><a href="#06-angr-symbolic-dynamic-memory" class="headerlink" title="06_angr_symbolic_dynamic_memory"></a>06_angr_symbolic_dynamic_memory</h2><p>新知识点：符号化动态内存。</p>
<p>作者的解释文档这样写着：我们可以不告诉二进制程序将数据写入使用<code>malloc()</code>分配的内存地址，而是直接伪造一个未使用的内存块的地址，并覆盖指向数据的指针。</p>
<p>思路是这样的：malloc函数返回值是一个地址，储存到了buffer里，我们伪造一个地址放到buffer即可，然后在我们伪造的地址处填入符号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    start_address=<span class="number">0x080486AF</span></span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">    passwd_size=<span class="number">8</span>*<span class="number">8</span></span><br><span class="line">    passwd0=claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>,passwd_size)</span><br><span class="line">    passwd1=claripy.BVS(<span class="string">&#x27;passwd1&#x27;</span>,passwd_size)</span><br><span class="line"></span><br><span class="line">    fake_heap_address0=<span class="number">0x0804A144</span></span><br><span class="line">    fake_heap_address1=<span class="number">0x0804A154</span></span><br><span class="line">    real_address0=<span class="number">0x0A2DEF74</span></span><br><span class="line">    real_address1=<span class="number">0x0A2DEF7C</span></span><br><span class="line">    </span><br><span class="line">    init_state.memory.store(real_address0,fake_heap_address0,endness=project.arch.memory_endness)</span><br><span class="line">    init_state.memory.store(real_address1,fake_heap_address1,endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">    init_state.memory.store(fake_heap_address0,passwd0)</span><br><span class="line">    init_state.memory.store(fake_heap_address1,passwd1)</span><br><span class="line"></span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        password0=solution_state.solver.<span class="built_in">eval</span>(passwd0,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        password1=solution_state.solver.<span class="built_in">eval</span>(passwd1,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &quot;</span>.<span class="built_in">format</span>(password0,password1))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init_state.memory.store(real_address0,fake_heap_address0,endness=project.arch.memory_endness)</span><br><span class="line">（原地址，我们指定的假地址，端序），原地址指的是存放malloc返回值的变量的地址，此处endness是和本项目相同</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>endness可选项</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LE</span> – 小端序<span class="comment">(little endian, least significant byte is stored at lowest address)</span></span><br><span class="line">BE – 大端序<span class="comment">(big endian, most significant byte is stored at lowest address)</span></span><br><span class="line">ME – 中间序<span class="comment">(Middle-endian. Yep.)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230526234028.png"></p>
<h2 id="07-angr-symbolic-file"><a href="#07-angr-symbolic-file" class="headerlink" title="07_angr_symbolic_file"></a>07_angr_symbolic_file</h2><p>新知识点：符号化文件内</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    start_address=<span class="number">0x080488BC</span></span><br><span class="line">    init_state=project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">    filename=<span class="string">&#x27;FOQVSBZB.txt&#x27;</span></span><br><span class="line">    filesize=<span class="number">0x40</span></span><br><span class="line">    passwd0=claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>,filesize*<span class="number">8</span>)</span><br><span class="line">    passwdfile=angr.storage.SimFile(filename,content=passwd0,size=filesize)</span><br><span class="line"></span><br><span class="line">    init_state.fs.insert(filename,passwdfile)</span><br><span class="line">    </span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        password0=solution_state.solver.<span class="built_in">eval</span>(passwd0,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        <span class="built_in">print</span>(password0)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no found&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>新操作，创建虚拟文件并将其放入仿真文件系统</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##创建同名的虚拟文件，必须要和题目中给出的文件名一致</span></span><br><span class="line">filename=<span class="string">&#x27;FOQVSBZB.txt&#x27;</span></span><br><span class="line">filesize_byte=<span class="number">0x40</span></span><br><span class="line"><span class="comment">##符号化文件内容</span></span><br><span class="line">passwd0=claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>,filesize*<span class="number">8</span>)</span><br><span class="line"><span class="comment">##创建符号化文件，参数是（文件名，内容，大小byte）</span></span><br><span class="line">passwdfile=angr.storage.SimFile(filename,content=passwd0,size=filesize)</span><br><span class="line"></span><br><span class="line"><span class="comment">##将文件放入仿真文件系统,这一步我的理解就是替换，访问文件时直接访问我们创建的同名文件</span></span><br><span class="line">init_state.fs.insert(filename,passwdfile)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230527140218.png"></p>
<h2 id="08-angr-constraints"><a href="#08-angr-constraints" class="headerlink" title="08_angr_constraints"></a>08_angr_constraints</h2><p>开始之前先了解一下路径爆炸。因为这次的新知识点就是：通过添加约束解决路径爆炸问题。</p>
<h3 id="路径爆炸"><a href="#路径爆炸" class="headerlink" title="路径爆炸"></a>路径爆炸</h3><p>路径爆炸(Path explosion)指的是在有限状态机或接收器的设计过程中,状态数或路径数呈指数增长的现象。当程序经历的所有可能路径数量超过计算机的处理能力时，就会出现路径爆炸的问题。</p>
<p>路径爆炸是软件测试和验证中一个重要的问题。在对程序进行测试或验证时，需要覆盖程序的所有可能路径，以确保程序的正确性和安全性。但是，当程序中存在复杂的控制流结构时，这个任务就变得非常艰巨。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    start_address=<span class="number">0x0804863C</span></span><br><span class="line">    buffer_address=<span class="number">0x0804A040</span></span><br><span class="line">    ckeckfun_address=<span class="number">0x0804857C</span></span><br><span class="line"></span><br><span class="line">    init_state=project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">    passwd_len=<span class="number">16</span></span><br><span class="line">    passwd0=claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>,passwd_len*<span class="number">8</span>)</span><br><span class="line">    init_state.memory.store(buffer_address,passwd0)</span><br><span class="line"></span><br><span class="line">    simulation=project.factory.simulation_manager(init_state)</span><br><span class="line">    simulation.explore(find=ckeckfun_address)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state=simulation.found[<span class="number">0</span>]</span><br><span class="line">        parameter_address=buffer_address</span><br><span class="line">        parameter_size_bytes=<span class="number">16</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">##.load读出buffer处的内存数据</span></span><br><span class="line">        parameter_bitvector=solution_state.memory.load(parameter_address,parameter_size_bytes)</span><br><span class="line">        compare_valve=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span></span><br><span class="line">        solution_state.solver.add(parameter_bitvector==compare_valve)</span><br><span class="line">        solution0=solution_state.solver.<span class="built_in">eval</span>(passwd0,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        <span class="built_in">print</span>(solution0)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;no found&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果按照程序之前的逻辑，按字节进行比对，16byte长度的数据就会产生2^16个分支，分支呈指数级增长，因此我们不按照他的逻辑进行比对，我们的输入经过一些操作之后还是被存储在buffer里，我们直接拿处理过后的buffer与comparedata进行比较，这样这样就变成了简单的爆破，不会造成路径爆炸。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ckeckfun_address=<span class="number">0x0804857C</span></span><br><span class="line"><span class="comment">##模拟到这个检测函数，其他的就不管了，只要让buffer满足条件即可，下面增加的约束就相当于创建了一个函数，实现的功能和之前的check是相等的，不过不是按位比较</span></span><br><span class="line">simulation.explore(find=ckeckfun_address)</span><br><span class="line"><span class="comment">##运行到调用比较函数的状态</span></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state=simulation.found[<span class="number">0</span>]</span><br><span class="line">        parameter_address=buffer_address</span><br><span class="line">        parameter_size_bytes=<span class="number">16</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">##.load读出buffer处的内存数据，即读取符号向量</span></span><br><span class="line">        parameter_bitvector=solution_state.memory.load(parameter_address,parameter_size_bytes)</span><br><span class="line">        compare_valve=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span></span><br><span class="line">        <span class="comment">##.add(约束内容)，约束条件：运行到此处buffer的值与比较数据相等</span></span><br><span class="line">        solution_state.solver.add(parameter_bitvector==compare_valve)</span><br><span class="line">        solution0=solution_state.solver.<span class="built_in">eval</span>(passwd0,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230527215116.png"></p>
<h2 id="09-angr-hooks"><a href="#09-angr-hooks" class="headerlink" title="09_angr_hooks"></a>09_angr_hooks</h2><p>新知识点：hook。</p>
<blockquote>
<p>wiki：</p>
<p>钩子编程（hooking），也称作“挂钩”，是计算机程序设计术语，指<strong>通过拦截软件模块间的函数调用、消息传递、事件传递来修改或扩展操作系统、应用程序或其他软件组件的行为的各种技术</strong>。 处理被拦截的函数调用、事件、消息的代码，被称为钩子（hook）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    checkfun_address=<span class="number">0x080486CA</span></span><br><span class="line">    <span class="comment">##定义执行完要跳过多少字节，这意味着我们直接替换了这个函数</span></span><br><span class="line">    jump_len=<span class="number">5</span></span><br><span class="line"><span class="meta">    @project.hook(<span class="params">checkfun_address,length=jump_len</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fake_checkfun</span>(<span class="params">state</span>):</span><br><span class="line">        buffer_address=<span class="number">0x0804A044</span></span><br><span class="line">        buffer_len=<span class="number">16</span></span><br><span class="line">        usr_input_string=state.memory.load(buffer_address,buffer_len)</span><br><span class="line">        compare_data=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span>.encode()</span><br><span class="line"></span><br><span class="line">        <span class="comment">##相等则设置寄存器eax的值为1，因为我们在对状态进行操作，所以不能直接使用if else语句</span></span><br><span class="line">        state.regs.eax=claripy.If(usr_input_string==compare_data,claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),claripy.BVV(<span class="number">0</span>, <span class="number">32</span>) )</span><br><span class="line">        </span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        solution = solution_state.posix.dumps(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用地址hook，最后部分模仿函数返回值，返回值储存在寄存器eax中。</p>
<p>在ida查看命令字节码长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##定义执行完要跳过多少字节，这意味着我们直接替换了这个函数</span></span><br><span class="line">    jump_len=<span class="number">5</span></span><br><span class="line"><span class="meta">    @project.hook(<span class="params">checkfun_address,length=jump_len</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fake_checkfun</span>(<span class="params">state</span>):</span><br><span class="line">        buffer_address=<span class="number">0x0804A044</span></span><br><span class="line">        buffer_len=<span class="number">16</span></span><br><span class="line">        usr_input_string=state.memory.load(buffer_address,buffer_len)</span><br><span class="line">        compare_data=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span>.encode()</span><br><span class="line"></span><br><span class="line">        <span class="comment">##相等则设置寄存器eax的值为1，因为我们在对状态进行操作，所以不能直接使用if else语句</span></span><br><span class="line">        state.regs.eax=claripy.If(usr_input_string==compare_data,claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),claripy.BVV(<span class="number">0</span>, <span class="number">32</span>) )</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528022728.png"></p>
<h2 id="10-angr-simprocedures"><a href="#10-angr-simprocedures" class="headerlink" title="10_angr_simprocedures"></a>10_angr_simprocedures</h2><p>仍然是利用hook解决路径爆炸的问题，上一题是利用地址比较麻烦，现在学习利用函数名来hook，有点像最开始的时候用函数替换good job的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line">    <span class="comment">##定义一个继承angr.simprocedure的类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Replacefun</span>(angr.SimProcedure):</span><br><span class="line">          <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,to_check,length</span>):</span><br><span class="line">                buffer_address=to_check</span><br><span class="line">                buffer_length=length</span><br><span class="line"></span><br><span class="line">                user_input_string=self.state.memory.load(buffer_address,buffer_length)</span><br><span class="line">                comparedata=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span>.encode()</span><br><span class="line">                <span class="keyword">return</span> claripy.If(</span><br><span class="line">                      user_input_string==comparedata,</span><br><span class="line">                      claripy.BVV(<span class="number">1</span>,<span class="number">32</span>),</span><br><span class="line">                      claripy.BVV(<span class="number">0</span>,<span class="number">32</span>)</span><br><span class="line">                )</span><br><span class="line">    check_equals_symbol=<span class="string">&#x27;check_equals_OSIWHBXIFOQVSBZB&#x27;</span><span class="comment">##函数名</span></span><br><span class="line">    project.hook_symbol(check_equals_symbol,Replacefun())</span><br><span class="line"></span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        solution = solution_state.posix.dumps(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        main(sys.argv)</span><br></pre></td></tr></table></figure>

<p>把新知识点放下面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##定义一个继承angr.simprocedure的类</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Replacefun</span>(angr.SimProcedure):</span><br><span class="line">       <span class="comment">##后面两个参数按照原函数check_equals_OSIWHBXIFOQVSBZB来</span></span><br><span class="line">         <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,to_check,length</span>):</span><br><span class="line">               buffer_address=to_check</span><br><span class="line">               buffer_length=length</span><br><span class="line"></span><br><span class="line">               user_input_string=self.state.memory.load(buffer_address,buffer_length)</span><br><span class="line">               comparedata=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span>.encode()</span><br><span class="line">               <span class="keyword">return</span> claripy.If(</span><br><span class="line">                     user_input_string==comparedata,</span><br><span class="line">                     claripy.BVV(<span class="number">1</span>,<span class="number">32</span>),</span><br><span class="line">                     claripy.BVV(<span class="number">0</span>,<span class="number">32</span>)</span><br><span class="line">               )</span><br><span class="line">   check_equals_symbol=<span class="string">&#x27;check_equals_OSIWHBXIFOQVSBZB&#x27;</span><span class="comment">##函数名</span></span><br><span class="line">   project.hook_symbol(check_equals_symbol,Replacefun())</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528114046.png"></p>
<h2 id="11-angr-sim-scanf"><a href="#11-angr-sim-scanf" class="headerlink" title="11_angr_sim_scanf"></a>11_angr_sim_scanf</h2><p>和上面的一样，用来巩固。这样处理之后scanf可以接收多个参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">myscanf</span>(angr.SimProcedure):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,format_string,para0,para1</span>):</span><br><span class="line">            input0=claripy.BVS(<span class="string">&#x27;input0&#x27;</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">            input1=claripy.BVS(<span class="string">&#x27;input1&#x27;</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">            self.state.memory.store(para0,input0,endness=project.arch.memory_endness)</span><br><span class="line">            self.state.memory.store(para1,input1,endness=project.arch.memory_endness)</span><br><span class="line">            </span><br><span class="line">            self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>]=input0</span><br><span class="line">            self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>]=input1</span><br><span class="line"></span><br><span class="line">    scanf_symbol=<span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">    project.hook_symbol(scanf_symbol,myscanf())</span><br><span class="line"></span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        stored_solutions0 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>]</span><br><span class="line">        stored_solutions1 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>]</span><br><span class="line">        solution = <span class="string">f&#x27;<span class="subst">&#123;solution_state.solver.<span class="built_in">eval</span>(stored_solutions0)&#125;</span> <span class="subst">&#123;solution_state.solver.<span class="built_in">eval</span>(stored_solutions1)&#125;</span>&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528115054.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##用myscanf来代替__isoc99_scanf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myscanf</span>(angr.SimProcedure):</span><br><span class="line">   <span class="comment">##后面三个参数分别为格式化字符串，输入1，输入2</span></span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,format_string,para0,para1</span>):</span><br><span class="line">           <span class="comment">##符号化输入内容</span></span><br><span class="line">           input0=claripy.BVS(<span class="string">&#x27;input0&#x27;</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">           input1=claripy.BVS(<span class="string">&#x27;input1&#x27;</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">           <span class="comment">##将符号向量载入内存buffer处</span></span><br><span class="line">           self.state.memory.store(para0,input0,endness=project.arch.memory_endness)</span><br><span class="line">           self.state.memory.store(para1,input1,endness=project.arch.memory_endness)</span><br><span class="line">           <span class="comment">##将函数内的局部变量input转变为全局变量solution</span></span><br><span class="line">           self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>]=input0</span><br><span class="line">           self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>]=input1</span><br><span class="line"></span><br><span class="line">   scanf_symbol=<span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">   project.hook_symbol(scanf_symbol,myscanf())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528150540.png"></p>
<h2 id="12-angr-veritesting"><a href="#12-angr-veritesting" class="headerlink" title="12_angr_veritesting"></a>12_angr_veritesting</h2><p>之前使用hook或者添加约束来解决路径爆炸问题，现在直接在创建虚拟管理器的时候加上一个参数，simulation&#x3D;project.factory.simgr(init_state,veritesting&#x3D;True)</p>
<blockquote>
<p>简单来说就是Veritesting结合了静态符合执行与动态符号执行，减少了路径爆炸的影响，在angr里我们只要在构造模拟管理器时，启用Veritesting了就行</p>
</blockquote>
<p>不知道什么原因这个程序跑起来内存就会爆炸，看来还是没解决路径爆炸的问题，推测可能是环境的问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line">    simulation=project.factory.simgr(init_state,veritesting=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    simulation.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state=simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution=solution_state.posix(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;no found&#x27;</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528172818.png"></p>
<h2 id="13-angr-static-binary"><a href="#13-angr-static-binary" class="headerlink" title="13_angr_static_binary"></a>13_angr_static_binary</h2><blockquote>
<p>作者文档里的内容：</p>
<p>这个挑战与第一个挑战完全相同，只是它被编译为静态二进制文件。通常，Angr会自动使用SimProcedures替换标准库函数，以实现更快的运行速度。</p>
<p>为了解决这个挑战，需要手动hook任何使用的标准库c函数。</p>
</blockquote>
<p>什么叫静态什么叫动态？<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528203748.png"></p>
<p>拖进ida里很容易看出来，题目13function那一栏里比12多得多，这是因为<strong>静态链接</strong>库将所有依赖项都包含在目标二进制文件中，反观<strong>动态链接</strong>，同台链接是指程序在训醒时才需要加载所依赖的库，当我们使用动态链接库来编译程序时，编译器并不会将所有库函数的代码都合并为一个单独的可执行文件。相反，它只是在可执行文件中留下一些标记，以便在运行时从系统或其他位置加载动态链接库。</p>
<p>在静态链接库中，没有动态链接库来提供符号，我们需要手动hook任何使用的标准库c函数，并确保从main函数的开头开始执行。</p>
<p>在动态链接库中，动态链接器会提供符号，我们不需要手动hook标准库c函数。</p>
<p>这一题我们就要将main函数里所用到的标准库函数hook住，用angr的方法来取代，这能大大提高效率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line">    </span><br><span class="line">    printf_address=<span class="number">0x0804FAB0</span></span><br><span class="line">    scanf_address=<span class="number">0x0804FB10</span></span><br><span class="line">    strcmp_address=<span class="number">0x08048228</span></span><br><span class="line">    puts_address=<span class="number">0x080503F0</span></span><br><span class="line">    __libc_start_main_address=<span class="number">0x08048D60</span></span><br><span class="line"></span><br><span class="line">    project.hook(printf_address,angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]())</span><br><span class="line">    project.hook(scanf_address,angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line">    project.hook(strcmp_address,angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;strcmp&#x27;</span>]())</span><br><span class="line">    project.hook(puts_address,angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line">    <span class="comment">##重点关注一下这里不太清楚是个啥</span></span><br><span class="line">    project.hook(__libc_start_main_address,angr.SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isgood</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isbad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    simulation=project.factory.simgr(init_state)</span><br><span class="line">    simulation.explore(find=isgood,avoid=isbad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state=simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution=solution_state.posix.dumps(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;no found&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528211108.png"></p>
<h2 id="14-angr-shared-library"><a href="#14-angr-shared-library" class="headerlink" title="14_angr_shared_library"></a>14_angr_shared_library</h2><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <tags>
        <tag>angr</tag>
      </tags>
  </entry>
  <entry>
    <title>bomblab</title>
    <url>/2023/06/02/bomblab/</url>
    <content><![CDATA[<p>解压完出现了三个文件bomb、bomb.c、readme，其中bomb.c是实验的源代码，不过他最重要的部分被删除了。我们可以通过将可执行文件bomb反汇编来查看内部情况。通过objdump -d bomb &gt; bomb.asm我们获得了一个新的文件，内容是bomb的汇编代码。</p>
<span id="more"></span>

<h2 id="gdb的使用"><a href="#gdb的使用" class="headerlink" title="gdb的使用"></a>gdb的使用</h2><table>
<thead>
<tr>
<th>基本命令</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1.进入调试状态</td>
<td>gdb bomb</td>
<td>后面的bomb是我们要调试的程序</td>
</tr>
<tr>
<td>2.查看源码</td>
<td>(gdb) l</td>
<td>前面的（gdb）代表已经进入调试状态，后面的l，将源码按行号显示</td>
</tr>
<tr>
<td>3.设置断点</td>
<td>(gdb) b   6</td>
<td>意思是运行到源码的第六行时停止（第六行的指令没有执行）</td>
</tr>
<tr>
<td>4.查看断点情况</td>
<td>(gdb) info b</td>
<td>将我们设置的断点列举出来</td>
</tr>
<tr>
<td>5.运行代码</td>
<td>(gdb) r</td>
<td></td>
</tr>
<tr>
<td>6.显示变量值</td>
<td>(gdb) p n</td>
<td>p（print）变量名</td>
</tr>
<tr>
<td>7.单步运行</td>
<td>(gdb) n</td>
<td>next</td>
</tr>
<tr>
<td>8.程序继续运行</td>
<td>(gdb) c</td>
<td>continue</td>
</tr>
<tr>
<td>9.退出</td>
<td>(gdb) q</td>
<td>quit</td>
</tr>
<tr>
<td>10.访问内存</td>
<td>x&#x2F;参数 &lt;地址&gt;</td>
<td>参数s是输出为字符串，d为十进制输出，x为十六进制输出</td>
</tr>
<tr>
<td>11.跟踪寄存器</td>
<td>display&lt;$寄存器&gt;</td>
<td>碰到断点停下时显示所有跟踪寄存器的值</td>
</tr>
</tbody></table>
<p>用$前缀表示一个立即数</p>
<p>函数传参：当参数个数小于等于6个时，使用寄存器<strong>rdi,rsi,rdx,rcx,r8,r9，从第7个参数开始通过栈传递，顺序为从右往左入栈。</strong>csapp 3.7</p>
<h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p>这就是第一个炸弹</p>
<p><img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230424151255.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp                   ;创建栈帧</span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi              ;将0x402400复制到esi中，前去查看</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	call   401338 &lt;strings_not_equal&gt;  ;根据名字来看，调用比较函数</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax                    </span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;        ;相等则跳转</span><br><span class="line">  400ef2:	e8 43 05 00 00       	call   40143a &lt;explode_bomb&gt;        ;爆炸</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp                    ;恢复栈帧</span><br><span class="line">  400efb:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>test执行过程与and相似，但他只设置条件码寄存器，不改变目的寄存器中的值。这里的用法是，如果返回值为零，则条件码寄存器置1，je进行跳转。</p>
<p>我们用x&#x2F;s 0x402400查看以0x402400为首地址的字符串。</p>
<p>先把一个值（字符串的地址）放到了%esi里，而放到%edi里的就是我们输入的字符串地址，记住传参顺序，di、si、dx、cx、r8、r9.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:       &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>

<h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>第二个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   rbp                     ;保存栈帧寄存器</span><br><span class="line">  400efd:	53                   	push   rbx                </span><br><span class="line">  400efe:	48 83 ec 28          	sub    rsp,0x28                </span><br><span class="line">  400f02:	48 89 e6             	mov    rsi,rsp        ;-------------------为函数的调用做准备</span><br><span class="line">  400f05:	e8 52 05 00 00       	call   40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:	83 3c 24 01          	cmp    DWORD PTR [rsp],0x1</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:	e8 25 05 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    eax,DWORD PTR [rbx-0x4]</span><br><span class="line">  400f1a:	01 c0                	add    eax,eax</span><br><span class="line">  400f1c:	39 03                	cmp    DWORD PTR [rbx],eax</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:	e8 15 05 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    rbx,0x4</span><br><span class="line">  400f29:	48 39 eb             	cmp    rbx,rbp</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    rbx,[rsp+0x4]             ;将(rsp)+0x4赋值给rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    rbp,[rsp+0x18]</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:	48 83 c4 28          	add    rsp,0x28</span><br><span class="line">  400f40:	5b                   	pop    rbx</span><br><span class="line">  400f41:	5d                   	pop    rbp</span><br><span class="line">  400f42:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>不太熟悉lea指令，先学一下。</p>
<p>lea是“load effective address”的缩写，把一个内存变量的有效地址送给指定的寄存器，简单地说lea指令可以用来将一个内存地址直接赋值给目的操作数。lea eax,[ebx+8]是将ebx+8这个值直接赋值给eax，与之相似的mov指令，mov eax,[ebx+8]是将内存地址为ebx+8处的数据赋值给eax。对于lea指令，lea eax，eax是会报错的，只能lea eax，[eax] 等同于mov eax,eax其实就是【eax】就是eax的值。</p>
<p>理一下逻辑：</p>
<p>1.调用函数，接收六个数字</p>
<p>2.[rsp]和0x1对比，所以(rsp)&#x3D;1</p>
<p>3.如果相等则进行跳转，不相等则爆炸！！！</p>
<p>4.将rsp+4和rsp+0x18分别赋值给rbx和rbp</p>
<p>5.跳转，将地址为rbx-4处的数据赋值给eax</p>
<p>6.将eax乘2</p>
<p>7.[rbx]和eax进行比较</p>
<p>8.相等则将rbx+4，不相等则爆炸！！！！</p>
<p>9.比较rbx和rbp，如果相等则结束程序（success），如果不相等则跳转到步骤5.</p>
<p>第四行的指令mov rsi，rsp，rsi是传递第二个参数的寄存器，他保存的是什么值？保存的是栈指针，也就是栈顶地址。那么第一个参数呢，我们有理由怀疑我们的输入是第一个参数，正如pgase1中，根据函数名我们可以判断，读入六个数字。</p>
<p><img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230425144102.png"></p>
<p>可以看到他将第二个参数赋值给了rdx，然后下面的rsi+4和rsi+0x14，0x14&#x3D;&#x3D;24，通过lea指令将距离栈顶第二个元素的地址和第七个元素的地址（末尾标志）传入了相关寄存器，注意这里的[rsi],因为前面提到过，rsi里存放的是栈顶地址，所以可以这么解释。这么复杂加上后面的sscanf大概猜测一下，就是将我们输入的6个数字放入首地址为rsp的内存空间中。我么可以查看一下mov esi,0x4025c3这条指令输入的十六个整型。</p>
<p><img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230425154617.png"></p>
<p>回到phase2函数，再调用完读取函数之后，进行了一次比较，如果输入的第一个数不是0x1则爆炸。继续往下，将输入的第二个数（【rsp+4】）送入rbp，将[rsp+0x18]送入rbp（栈帧寄存器），下面其实是个循环，通过比较指令和跳转指令来实现，add    rbx,0x4这条指令相当于一个计数器。大致实现的逻辑是将第二个如放入rbx，将钱一个数字放入rax，将rax进行乘2操作，进行比较。其实只要看出这一题的循环，很多东西都是水到渠成的顺出来的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp    rbx,rbp</span><br><span class="line">75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br></pre></td></tr></table></figure>

<p>每比较一次都会对rbx+4，当rbx+4与我们设置的末尾表值相同时就会结束循环。0x4–&gt;0x18,差为24，正好循环六次</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">6</span>]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i+<span class="number">1</span>]=arr[i]*<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">;<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span></span><br></pre></td></tr></table></figure>

<h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    rsp,0x18</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    rcx,[rsp+0xc]           ;参数4     0x00</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]           ;参数3</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    esi,0x4025cf            ;参数2查看之后是%d，诡异的是接收两个整形</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    eax,0x0                 ;应该是个计数器</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	call   400bf0 &lt;__isoc99_sscanf@plt&gt;；读取我们的input作为scand的参数</span><br><span class="line">  400f60:	83 f8 01             	cmp    eax,0x1                 ;eax里的值和1比较，eax存放的是函数的返回值</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;   ;如果大于一则跳转     jg是由符号运算大于则跳转</span><br><span class="line">  400f65:	e8 d0 04 00 00       	call   40143a &lt;explode_bomb&gt;   ;不大于一直接爆炸</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmp    DWORD PTR [rsp+0x8],0x7 ;调准到此处，与0x7进行比较</span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;   ;无符号大于则跳转，爆炸</span><br><span class="line">  400f71:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8] </span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmp    QWORD PTR [rax*8+0x402470];用x/x查明之后，是机器码0xb9，对应的汇编指令是MOV cx,immed16</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    eax,0xcf</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    eax,0x2c3</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    eax,0x100</span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    eax,0x185</span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    eax,0xce</span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    eax,0x2aa</span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    eax,0x147</span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    eax,0x0</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    eax,0x137</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    eax,DWORD PTR [rsp+0xc]</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:	e8 71 04 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    rsp,0x18</span><br><span class="line">  400fcd:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>通过传到esi里的参数我们可以看出，这次接受的输入是两个整形，下面一堆东西是属比较抽象，静态看实在有点头大，于是多下了几个断点一步一步来，输入2 2尝试一下。cmp eax，0x1，eax里保存的是返回值，只要我们的输入大于一个应该就能正常跳转，下面的比较没太看明白，和0x7进行比较，试一下就知道，其实是和我们的第一个输入进行比较，只要不大于7就能正常跳转，我们接着向下，一步一步调试来到了最后的比较，cmp    eax,DWORD PTR [rsp+0xc]，很容易想到[rsp+0xc]其实就是我们的第二个输入，这是只要我们查看一下寄存器的值，就知道如何进行比较<img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230425212410.png"></p>
<p>可以看到rax的值为707，推出之后重新运行，输入2 707果然正确。通过这题目的名字可以看出他考察的是分支，关键的没看懂的地方其实是jmp    QWORD PTR [rax*8+0x402470]，这一步大概率是根据我们的输入进行不同的跳转的函数。至于我们的输入为什么被放在了[rsp,0xc]和[rsp+0x8]中，我的猜测是这是函数的参数用来指定将接收的输入放置的位置。 __isoc99_sscanf@plt(rdi,rsi,n1,n2,n3…)其中参数rdi保存的是我们input里的输入，rsi保存的是%d之类的，以什么形式接收多少，后面就是放置的位置吧。</p>
<p>看了网上的题解之后，才明白这原来就是个switch分支啊，我们可以通过x命令来查看一下0x402470的内容，这是个跳转表，在《汇编语言》接触过</p>
<p>通过x&#x2F;8xg<img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230425222247.png"></p>
<p>细说一下x命令，很好用。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">格式        x/nfu  addr</span><br><span class="line">n是正数表示要显示的数量</span><br><span class="line">f该表的是输出格式，常用的有字符串s，十六进制x，十进制d，字符c</span><br><span class="line">u代表一多少个字节作为一个内存单元来显示，<span class="attribute">b</span>=1byte,h=2 bytes,<span class="attribute">w</span>=4 bytes,<span class="attribute">g</span>=8 bytes</span><br><span class="line">addr代表内存单元地址</span><br><span class="line"> x/8xg 0x402470</span><br><span class="line">这条指令的意思就是从内存地址0x402470处，以十六进制形式8个字节为一个单位显示8组数</span><br><span class="line">为什么这里要用8呢，因为跳转那里是qword也就是两个字，一个字32为两个字就是8字节</span><br></pre></td></tr></table></figure>

<h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:	48 83 ec 08          	sub    rsp,0x8</span><br><span class="line">  400fd2:	89 d0                	mov    eax,edx  ;0x0e</span><br><span class="line">  400fd4:	29 f0                	sub    eax,esi  ;0x0</span><br><span class="line">  400fd6:	89 c1                	mov    ecx,eax   </span><br><span class="line">  400fd8:	c1 e9 1f             	shr    ecx,0x1f  ;右移0x1f</span><br><span class="line">  400fdb:	01 c8                	add    eax,ecx   ;</span><br><span class="line">  400fdd:	d1 f8                	sar    eax,1     ;算术右移</span><br><span class="line">  400fdf:	8d 0c 30             	lea    ecx,[rax+rsi*1]   ;</span><br><span class="line">  400fe2:	39 f9                	cmp    ecx,edi</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt;      ;有符号小于等于</span><br><span class="line">  400fe6:	8d 51 ff             	lea    edx,[rcx-0x1]</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	call   400fce &lt;func4&gt;      ;调用自身  递归</span><br><span class="line">  400fee:	01 c0                	add    eax,eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    eax,0x0</span><br><span class="line">  400ff7:	39 f9                	cmp    ecx,edi</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt;;有符号大于等于</span><br><span class="line">  400ffb:	8d 71 01             	lea    esi,[rcx+0x1]</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	call   400fce &lt;func4&gt;</span><br><span class="line">  401003:	8d 44 00 01          	lea    eax,[rax+rax*1+0x1]</span><br><span class="line">  401007:	48 83 c4 08          	add    rsp,0x8</span><br><span class="line">  40100b:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    rsp,0x18</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    rcx,[rsp+0xc]      ;第二个输入</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]      ;第一个输入</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    esi,0x4025cf       ;接收两个整型</span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    eax,0x0</span><br><span class="line">  401024:	e8 c7 fb ff ff       	call   400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:	83 f8 02             	cmp    eax,0x2            ;如果输入不为2就爆炸</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmp    DWORD PTR [rsp+0x8],0xe  ;第一个输入和0xe进行比较</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;    ;无符号小于等于则跳转，所以我们的输入必须小于等于14</span><br><span class="line">  401035:	e8 00 04 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    edx,0xe</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    esi,0x0</span><br><span class="line">  401044:	8b 7c 24 08          	mov    edi,DWORD PTR [rsp+0x8]   ;------------函数传参</span><br><span class="line">  401048:	e8 81 ff ff ff       	call   400fce &lt;func4&gt;      ;调用func4</span><br><span class="line">  40104d:	85 c0                	test   eax,eax            ;and操作不过不改变不敌寄存器的值，为0时标志寄存器置0</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;    ;如果上面eax的值为0则不发生跳转（哦按段是否相等是检测其差是否为0）</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmp    DWORD PTR [rsp+0xc],0x0   ;将第二个参数与0进行比较</span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;      ;相等则成功，否则爆炸！！！</span><br><span class="line">  401058:	e8 dd 03 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    rsp,0x18</span><br><span class="line">  401061:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>看着汇编用c语言大致实现了一遍。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> di, <span class="type">int</span> si, <span class="type">int</span> dx)</span><span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ax = dx;</span><br><span class="line">    ax = ax - si;</span><br><span class="line">    <span class="type">int</span> cx = ax;</span><br><span class="line">    cx = cx &gt;&gt; <span class="number">0x1f</span>; <span class="comment">//逻辑</span></span><br><span class="line">    ax = ax + cx;</span><br><span class="line">    ax = ax &gt;&gt; <span class="number">1</span>; <span class="comment">//算数</span></span><br><span class="line">    cx = (ax + si);</span><br><span class="line">    <span class="keyword">if</span> (cx &lt;= di)</span><br><span class="line">    &#123;</span><br><span class="line">        ax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cx &gt;= di)</span><br><span class="line">            <span class="keyword">return</span> ax;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            si = (cx + <span class="number">1</span>);</span><br><span class="line">            ax=func4(di, si, dx);</span><br><span class="line">            ax = (ax + ax + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> ax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dx = (cx - <span class="number">1</span>);</span><br><span class="line">        ax = func4(di, si, dx);</span><br><span class="line">        ax = ax+ax;</span><br><span class="line">        <span class="keyword">return</span> ax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> g = <span class="number">0</span>;</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;g);</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0xe</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        <span class="type">int</span> x=func4(i, <span class="number">0</span>, <span class="number">0xe</span>);</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;bomb!!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;success!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;bomb!!!!!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bomb&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本来tmd早就可以结束的，在test那里出了点问题，test eax,eax; jne bomb 意思是如果返回值eax的值为零，那么爆炸，woc简直了，把c语言的判断写成了         if（ex&#x3D;&#x3D;0）则爆炸。。。这一题的解题思路不同于上两个，是直接通过代码实现的，经过验证（0~14）其中可行的是0，1，3，7第二个输入是固定的0。</p>
<h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    rsp,0x20</span><br><span class="line">  401067:	48 89 fb             	mov    rbx,rdi</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax</span><br><span class="line">  401078:	31 c0                	xor    eax,eax</span><br><span class="line">  40107a:	e8 9c 02 00 00       	call   40131b &lt;string_length&gt; </span><br><span class="line">  40107f:	83 f8 06             	cmp    eax,0x6                ;如果输入的字符串长度不等于6，则爆炸</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;      </span><br><span class="line">  401084:	e8 b1 03 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  40108b:	0f b6 0c 03          	movzx  ecx,BYTE PTR [rbx+rax*1]     ;将我们的输入逐字节传送到ecx</span><br><span class="line">  40108f:	88 0c 24             	mov    BYTE PTR [rsp],cl            ;送入【rsp】</span><br><span class="line">  401092:	48 8b 14 24          	mov    rdx,QWORD PTR [rsp]          ;送入rdx</span><br><span class="line">  401096:	83 e2 0f             	and    edx,0xf                      ;将我们的输入and上0xf</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzx  edx,BYTE PTR [rdx+0x4024b0]       ;把该地址处的值存入edx，0扩展并传送（无符号扩展）到edx</span><br><span class="line">  4010a0:	88 54 04 10          	mov    BYTE PTR [rsp+rax*1+0x10],dl       ;将修改过的输入传入指定位置</span><br><span class="line">  4010a4:	48 83 c0 01          	add    rax,0x1                          ;eax+1</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    rax,0x6                           ;eax的值与6进行比较</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt;             ;因为在前面eax已经置零，所以这里就是循环六次上面的操作</span><br><span class="line">  4010ae:	c6 44 24 16 00       	mov    BYTE PTR [rsp+0x16],0x0         ;向指定位置送个0，像是结尾标志</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    esi,0x40245e                    ;将比较字符串“flyers”送入</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    rdi,[rsp+0x10]                  ;</span><br><span class="line">  4010bd:	e8 76 02 00 00       	call   401338 &lt;strings_not_equal&gt;        ;如果不相等则为真返回1否则返回0</span><br><span class="line">  4010c2:	85 c0                	test   eax,eax                           </span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;              ;如果返回值rax为0则进行跳转，否则爆炸</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]               </span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    eax,0x0</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]         ;</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    rax,QWORD PTR fs:0x28            ;异或操作，实际上是进行比较，其实是进行栈溢出检测</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;            ;如果相等则异或结果为零跳转，成功。</span><br><span class="line">  4010e9:	e8 42 fa ff ff       	call   400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:	48 83 c4 20          	add    rsp,0x20</span><br><span class="line">  4010f2:	5b                   	pop    rbx</span><br><span class="line">  4010f3:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>这里其实是个多解题目，其实输入的是六个索引值。0x4024b0那里就是字符表(在字符表后发现了隐藏的炸弹好阴险)，最后的栈溢出检测浪费了很长时间，应该就是将其和金丝雀值进行对比，通过调试也可以看出，栈是随机化的。</p>
<h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   r14</span><br><span class="line">  4010f6:	41 55                	push   r13</span><br><span class="line">  4010f8:	41 54                	push   r12</span><br><span class="line">  4010fa:	55                   	push   rbp</span><br><span class="line">  4010fb:	53                   	push   rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    rsp,0x50</span><br><span class="line">  401100:	49 89 e5             	mov    r13,rsp</span><br><span class="line">  401103:	48 89 e6             	mov    rsi,rsp      ;第二个参数  存放输入的首地址</span><br><span class="line">  401106:	e8 51 03 00 00       	call   40145c &lt;read_six_numbers&gt;</span><br><span class="line">  40110b:	49 89 e6             	mov    r14,rsp      ;将栈顶地址赋值给r14</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    r12d,0x0     ;</span><br><span class="line">  401114:	4c 89 ed             	mov    rbp,r13      ;将栈顶地址赋值给rbp</span><br><span class="line">  401117:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]   ;把输入1送入eax</span><br><span class="line">  40111b:	83 e8 01             	sub    eax,0x1          ;将eax减去1</span><br><span class="line">  40111e:	83 f8 05             	cmp    eax,0x5          ;和5进行比较</span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;  ;无符号小于等于跳转</span><br><span class="line">  401123:	e8 12 03 00 00       	call   40143a &lt;explode_bomb&gt;  ;第一个输入不能大于6</span><br><span class="line">  401128:	41 83 c4 01          	add    r12d,0x1      ;给计数器加1</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    r12d,0x6      ;与6进行比较</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt; ;相等则跳转</span><br><span class="line">  401132:	44 89 e3             	mov    ebx,r12d     ;</span><br><span class="line">  401135:	48 63 c3             	movsxd rax,ebx      ;符号扩展</span><br><span class="line">  401138:	8b 04 84             	mov    eax,DWORD PTR [rsp+rax*4];将输入送入eax</span><br><span class="line">  40113b:	39 45 00             	cmp    DWORD PTR [rbp+0x0],eax;与输入1进行对比</span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;;不相等跳转</span><br><span class="line">  401140:	e8 f5 02 00 00       	call   40143a &lt;explode_bomb&gt;;相等爆炸</span><br><span class="line">  401145:	83 c3 01             	add    ebx,0x1  ;2</span><br><span class="line">  401148:	83 fb 05             	cmp    ebx,0x5   ;比较，循环5次知道ebx=6</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt; ;有符号小于等于跳转</span><br><span class="line">  40114d:	49 83 c5 04          	add    r13,0x4  ;r13指向第2个输入</span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  401153:	48 8d 74 24 18       	lea    rsi,[rsp+0x18]   ;第六个输入的后一个的地址</span><br><span class="line">  401158:	4c 89 f0             	mov    rax,r14</span><br><span class="line">  40115b:	b9 07 00 00 00       	mov    ecx,0x7</span><br><span class="line">  401160:	89 ca                	mov    edx,ecx</span><br><span class="line">  401162:	2b 10                	sub    edx,DWORD PTR [rax]</span><br><span class="line">  401164:	89 10                	mov    DWORD PTR [rax],edx</span><br><span class="line">  401166:	48 83 c0 04          	add    rax,0x4</span><br><span class="line">  40116a:	48 39 f0             	cmp    rax,rsi</span><br><span class="line">  40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;    ;又是一个循环</span><br><span class="line">  40116f:	be 00 00 00 00       	mov    esi,0x0          </span><br><span class="line">  401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  401176:	48 8b 52 08          	mov    rdx,QWORD PTR [rdx+0x8]</span><br><span class="line">  40117a:	83 c0 01             	add    eax,0x1</span><br><span class="line">  40117d:	39 c8                	cmp    eax,ecx</span><br><span class="line">  40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:	ba d0 32 60 00       	mov    edx,0x6032d0</span><br><span class="line">  401188:	48 89 54 74 20       	mov    QWORD PTR [rsp+rsi*2+0x20],rdx</span><br><span class="line">  40118d:	48 83 c6 04          	add    rsi,0x4</span><br><span class="line">  401191:	48 83 fe 18          	cmp    rsi,0x18</span><br><span class="line">  401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:	8b 0c 34             	mov    ecx,DWORD PTR [rsp+rsi*1]</span><br><span class="line">  40119a:	83 f9 01             	cmp    ecx,0x1</span><br><span class="line">  40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">  40119f:	b8 01 00 00 00       	mov    eax,0x1</span><br><span class="line">  4011a4:	ba d0 32 60 00       	mov    edx,0x6032d0</span><br><span class="line">  4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  4011ab:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]</span><br><span class="line">  4011b0:	48 8d 44 24 28       	lea    rax,[rsp+0x28]</span><br><span class="line">  4011b5:	48 8d 74 24 50       	lea    rsi,[rsp+0x50]</span><br><span class="line">  4011ba:	48 89 d9             	mov    rcx,rbx</span><br><span class="line">  4011bd:	48 8b 10             	mov    rdx,QWORD PTR [rax]</span><br><span class="line">  4011c0:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx</span><br><span class="line">  4011c4:	48 83 c0 08          	add    rax,0x8</span><br><span class="line">  4011c8:	48 39 f0             	cmp    rax,rsi</span><br><span class="line">  4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:	48 89 d1             	mov    rcx,rdx</span><br><span class="line">  4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  4011d2:	48 c7 42 08 00 00 00 	mov    QWORD PTR [rdx+0x8],0x0</span><br><span class="line">  4011d9:	00 </span><br><span class="line">  4011da:	bd 05 00 00 00       	mov    ebp,0x5</span><br><span class="line">  4011df:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]</span><br><span class="line">  4011e3:	8b 00                	mov    eax,DWORD PTR [rax]</span><br><span class="line">  4011e5:	39 03                	cmp    DWORD PTR [rbx],eax</span><br><span class="line">  4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">  4011e9:	e8 4c 02 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:	48 8b 5b 08          	mov    rbx,QWORD PTR [rbx+0x8]</span><br><span class="line">  4011f2:	83 ed 01             	sub    ebp,0x1</span><br><span class="line">  4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  4011f7:	48 83 c4 50          	add    rsp,0x50</span><br><span class="line">  4011fb:	5b                   	pop    rbx</span><br><span class="line">  4011fc:	5d                   	pop    rbp</span><br><span class="line">  4011fd:	41 5c                	pop    r12</span><br><span class="line">  4011ff:	41 5d                	pop    r13</span><br><span class="line">  401201:	41 5e                	pop    r14</span><br><span class="line">  401203:	c3                   	ret    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> arr[]=<span class="string">&quot;193456&quot;</span>;</span><br><span class="line">	<span class="type">int</span> rsp=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ebp;</span><br><span class="line">	<span class="type">int</span> ecx = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> edx = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> esi = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span>* r14 = arr;<span class="comment">//	mov    r14,rsp                  将输入的首地址放在r14</span></span><br><span class="line">	<span class="type">char</span>* rsp = arr;                 <span class="comment">//                 将输入的首地址放在rsp</span></span><br><span class="line">	<span class="type">int</span> r12d = <span class="number">0</span>;<span class="comment">//mov    r12d,0x0</span></span><br><span class="line">	<span class="type">char</span>* r13 = arr;                           <span class="comment">//       将输入的首地址放在r13</span></span><br><span class="line">jump401114:<span class="type">char</span>* rbp = r13;<span class="comment">//mov    rbp,r13        （第一次）首地址  （第二次）第二个输入     </span></span><br><span class="line">	<span class="type">int</span> eax = *(r13 + <span class="number">0</span>);<span class="comment">//mov    eax,DWORD PTR [r13+0x0]    将我们的一个输入放入eax中（第一个）  （第二次）第二个</span></span><br><span class="line">	eax = eax - <span class="number">1</span>;<span class="comment">//	sub    eax,0x1                       将（第一个）输入减一 我们的第一个输入必须小于等于6  （第二个也小于6）</span></span><br><span class="line">	<span class="type">int</span> ebx = <span class="number">0</span>;      </span><br><span class="line">	<span class="keyword">if</span> (eax &lt;= <span class="number">5</span>)<span class="comment">//	cmp    eax,0x5  //jbe    401128 &lt;phase_6+0x34&gt;     </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">goto</span> jump4001128;</span><br><span class="line">		jump4001128:</span><br><span class="line">		r12d = r12d + <span class="number">1</span>;<span class="comment">//add    r12d,0x1            （第一次路过）r12d=1   第六次路过就是6啦（非常的聪明）</span></span><br><span class="line">		<span class="keyword">if</span> (r12d == <span class="number">6</span>)<span class="comment">//cmp  r12d,0x6 //je     401153 &lt;phase_6+0x5f&gt;    很明显循环五次 经历过五次循环 前数与后数不相同0123456的排列组合，满足条件则进入</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//////////////////////////////////////////////////////////////////满足初始的0~6条件进入（第一次判断）</span></span><br><span class="line">			<span class="keyword">goto</span> jump4001153;</span><br><span class="line">			jump4001153:</span><br><span class="line">			<span class="type">int</span> rsi = <span class="number">0</span>;<span class="comment">//lea    rsi,[rsp+0x18]             第六个输入的后一个地址，应该是用来结束 rsi结束地址！！！！！！！！！！</span></span><br><span class="line">			eax = *r14;<span class="comment">//	mov    rax,r14                   eax存放输入的首地址</span></span><br><span class="line">			ecx = <span class="number">0x7</span>;<span class="comment">//mov    ecx,0x7                     ecx是7</span></span><br><span class="line">jump401160: edx = ecx;<span class="comment">//	mov    edx,ecx                 （第一次）edx=7    </span></span><br><span class="line">			edx = edx - eax;<span class="comment">//sub    edx,DWORD PTR [rax]    （第一次）edx=7-input1   （第二次）edx=7-input2     （第五次）edx=7-input5  （第六次）edx=7-input6</span></span><br><span class="line">			eax = edx;<span class="comment">//mov    DWORD PTR [rax],edx           将edx的值放入input1的位置    （第二次）放到input2的位置          （第六次）input6的位置</span></span><br><span class="line">			eax = eax + <span class="number">4</span>;<span class="comment">//add    rax,0x4                   （第一次）rax指向input2   （第二次）input3    （第5次）input6       （第六次）rsi所在的位置</span></span><br><span class="line">			<span class="keyword">if</span> (eax == rsi)<span class="comment">//cmp    rax, rsi              如果eax等于最后一个输入后面的地址  </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">///////////////////////////////////////////////////////////用7减去满足条件的数存放在以rsp为首的位置（rsp~rsp+0x14）</span></span><br><span class="line">				rsi = <span class="number">0</span>;<span class="comment">//mov    esi,0x0                     将esi置零，用作计数器</span></span><br><span class="line">				<span class="keyword">goto</span> jump401197;</span><br><span class="line">	jump401197: ecx = *(rsp + rsi);<span class="comment">//mov  ecx,DWORD PTR [rsp+rsi*1]     （第一次）ecx=input1</span></span><br><span class="line">				<span class="keyword">if</span> (ecx &lt;= <span class="number">1</span>)<span class="comment">//cmp  ecx,0x1  7-6=1                只可能是输入为6的情况啊   </span></span><br><span class="line">				&#123;</span><br><span class="line">					edx = <span class="number">0x6032d0</span>;<span class="comment">//	mov    edx,0x6032d0</span></span><br><span class="line">					<span class="keyword">goto</span> jump401188;<span class="comment">////jle   401183 &lt;phase_6+0x8f&gt;     输入为6进行跳转</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>            <span class="comment">//输入5 4 3 2 1 0 的情况      （假设input=2即输入为5）</span></span><br><span class="line">				&#123;</span><br><span class="line">					eax = <span class="number">1</span>;<span class="comment">//mov    eax,0x1                       </span></span><br><span class="line">					edx = <span class="number">0x6032d0</span>;<span class="comment">//mov    edx,0x6032d0</span></span><br><span class="line">					<span class="keyword">goto</span> jump401176;</span><br><span class="line">				jump401176:</span><br><span class="line">					edx = edx + <span class="number">0x8</span>;<span class="comment">//	mov  rdx,QWORD PTR [rdx+0x8]   0x6032d8处的内容  </span></span><br><span class="line">					eax = eax + <span class="number">1</span>;<span class="comment">//add    eax,0x1             此时的input1为2（加1次8）   input为5（加4次8）</span></span><br><span class="line">					<span class="keyword">if</span> (eax != ecx)<span class="comment">//cmp eax,ecx        </span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">goto</span> jump401176;<span class="comment">//jne 401176 &lt;phase_6+0x82&gt;</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="comment">//	jmp    401188 &lt;phase_6+0x94&gt;</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">goto</span> jump401188;</span><br><span class="line">					jump401188:</span><br><span class="line">						rsp = edx;<span class="comment">//mov    QWORD PTR [rsp+rsi*2+0x20],rdx      将rdx（0x6032d8）的数据存入 rsp+0+0x20处    </span></span><br><span class="line">						rsi = rsi + <span class="number">4</span>;<span class="comment">//add    rsi,0x4                4 8</span></span><br><span class="line">						<span class="keyword">if</span> (rsi == <span class="number">0x18</span>)<span class="comment">//je  4011ab &lt;phase_6+0xb7&gt;    循环6次 第一次到这里是4 第六次是0x18</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">/////////////////////////////////////////将6个数据分类讨论后进入（第三次筛选）</span></span><br><span class="line">							<span class="keyword">goto</span> jump4011ab;</span><br><span class="line">						jump4011ab:</span><br><span class="line">							ebx = rsp+<span class="number">0x20</span>;<span class="comment">//ebx=    mov    rbx,QWORD PTR [rsp+0x20]        将fake 1载入ebx</span></span><br><span class="line">							eax = rsp+<span class="number">0x28</span>;<span class="comment">//rax= 	lea    rax,[rsp+0x28]                   将fake 2的地址载入rax</span></span><br><span class="line">							rsi = rsp+<span class="number">0x50</span>;<span class="comment">//rsi=  lea    rsi,[rsp+0x50]                    将结束地址载入rsi</span></span><br><span class="line">							ecx = ebx;<span class="comment">//	mov    rcx,rbx                                  将fake 1载入rcx</span></span><br><span class="line">		jump4011bd:			edx = eax; <span class="comment">//mov    rdx, QWORD PTR[rax]                         将fake x值载入rdx x=2 3 4 5 6</span></span><br><span class="line">							ecx = edx;<span class="comment">//	mov    QWORD PTR [rcx+0x8],rdx                  将rdx   值载入fake y+8的位置 y=1 2 3 4 5</span></span><br><span class="line">							eax = eax + <span class="number">8</span>;                                               <span class="comment">// eax指向下一个fake </span></span><br><span class="line">							<span class="keyword">if</span> (eax == rsi)                                     </span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">goto</span> jump4011d2;</span><br><span class="line">							jump4011d2:</span><br><span class="line">								edx = <span class="number">0</span>;<span class="comment">//mov    QWORD PTR [rdx+0x8],0x0          （第一轮）将0载入fake 6 的位置</span></span><br><span class="line">								ebp = <span class="number">5</span>;<span class="comment">//mov    ebp,0x5                           计数器</span></span><br><span class="line">	      jump4011df:			eax=ebx;<span class="comment">//mov    rax,QWORD PTR [rbx+0x8]           将（fake y）载入rax x=2 3 4 5 6</span></span><br><span class="line">								eax = eax;<span class="comment">//mov    eax,DWORD PTR [rax]              </span></span><br><span class="line">								ebx = eax;<span class="comment">//cmp    DWORD PTR[rbx], eax              </span></span><br><span class="line">								<span class="keyword">if</span> (ebx &gt;= eax)<span class="comment">//jge    4011ee &lt;phase_6+0xfa&gt;</span></span><br><span class="line">								&#123;</span><br><span class="line">									<span class="keyword">goto</span> jump4011ee;</span><br><span class="line">								jump4011ee:</span><br><span class="line">									<span class="comment">//mov    rbx,QWORD PTR [rbx+0x8]      将fake2载入rbx</span></span><br><span class="line">									ebp = ebp - <span class="number">1</span>;<span class="comment">//sub    ebp,0x1</span></span><br><span class="line">									<span class="keyword">if</span> (ebp != <span class="number">1</span>)    <span class="comment">// 满足最后一轮循环后即可乱杀</span></span><br><span class="line">									&#123;</span><br><span class="line">										<span class="keyword">goto</span> jump4011df;</span><br><span class="line">									&#125;</span><br><span class="line">									<span class="keyword">else</span></span><br><span class="line">									&#123;</span><br><span class="line">										<span class="built_in">printf</span>(<span class="string">&quot;w1n!!!_y0u_@r3_my_her0!!!!&quot;</span>);</span><br><span class="line">										<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">else</span>                <span class="comment">//如果小于则爆炸</span></span><br><span class="line">								&#123;</span><br><span class="line">									<span class="keyword">goto</span> bomb;</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">							&#123;</span><br><span class="line">								<span class="comment">//mov    rcx,rdx</span></span><br><span class="line">								<span class="keyword">goto</span> jump4011bd;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							ecx = rsp + <span class="number">4</span>;<span class="comment">//mov ecx, DWORD PTR[rsp + rsi * 1]       （第一次）把第二个输入传给ecx   第三个</span></span><br><span class="line">							<span class="keyword">if</span> (ecx &lt;= <span class="number">1</span>)<span class="comment">//jle    401183 &lt;phase_6+0x8f&gt;     （查看第二个输入）（原为6）</span></span><br><span class="line">							&#123;</span><br><span class="line">								<span class="comment">//mov    edx,0x6032d0</span></span><br><span class="line">								<span class="keyword">goto</span> jump401188;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> </span><br><span class="line">							&#123;</span><br><span class="line">								eax = <span class="number">1</span>;<span class="comment">//mov    eax,0x1</span></span><br><span class="line">								edx = <span class="number">0x6032d0</span>;<span class="comment">//mov    edx,0x6032d0</span></span><br><span class="line">								<span class="keyword">goto</span> jump401176;</span><br><span class="line">							<span class="comment">////////////////////////////////jump401176:</span></span><br><span class="line">							<span class="comment">////////////////////////////////	//mov    rdx,QWORD PTR [rdx+0x8]</span></span><br><span class="line">							<span class="comment">////////////////////////////////	//add    eax,0x1</span></span><br><span class="line">							<span class="comment">////////////////////////////////	if (eax == ecx)</span></span><br><span class="line">							<span class="comment">////////////////////////////////	&#123;</span></span><br><span class="line">							<span class="comment">////////////////////////////////		goto jump401188;</span></span><br><span class="line">							<span class="comment">////////////////////////////////	&#125;</span></span><br><span class="line">							<span class="comment">////////////////////////////////	else</span></span><br><span class="line">							<span class="comment">////////////////////////////////	&#123;</span></span><br><span class="line">							<span class="comment">////////////////////////////////		goto jump401176;</span></span><br><span class="line">							<span class="comment">////////////////////////////////	&#125;</span></span><br><span class="line"></span><br><span class="line">							&#125;</span><br><span class="line"></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">goto</span> jump401160;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ebx = r12d;<span class="comment">//mov    ebx,r12d     （第一次）ebx=1   （第二次）r12d=2</span></span><br><span class="line"> jump401135:eax = ebx;<span class="comment">//movsxd rax,ebx        （第一次）eax=1 （第一个输入4次小循环）  (第二次) eax=2</span></span><br><span class="line">			eax = *(rsp + eax);<span class="comment">//mov    eax,DWORD PTR [rsp+rax*4] （第一次）eax=第二个输入   (第二次第3个输入)</span></span><br><span class="line">			<span class="keyword">if</span> (*(rbp) == eax)         <span class="comment">//（第一次路过）如果输入1、2相等   （第二次）如果2、3相等</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;401140 bomb!!!&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//jne    401145 &lt;phase_6+0x51&gt;</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">goto</span> jump401145;</span><br><span class="line">				jump401145:</span><br><span class="line">				ebx = ebx + <span class="number">1</span>;<span class="comment">//add    ebx,0x1     （第一次路过）ebx=2  （第二次路过）ebx=3 （第三次）ebx=4 （第四次）ebx=5</span></span><br><span class="line">				<span class="keyword">if</span> (ebx &lt;= <span class="number">5</span>)<span class="comment">//jle    401135 &lt;phase_6+0x41&gt; 很明显循环4次  这里针对的是前四个输入 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">goto</span> jump401135;  <span class="comment">//（）</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					r13 = r13 + <span class="number">1</span>;<span class="comment">//add    r13,0x4</span></span><br><span class="line">					<span class="keyword">goto</span> jump401114;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bomb!&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *r13 );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">bomb:<span class="built_in">printf</span>(<span class="string">&quot;bomb!!!!!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一题做的非常的。。。。。。。。怎么说呢，做完了看看别人的解题思路才发现这是个链表，我是直接把汇编还原成c语言，不是完全的还原，只是看着像的那种还原，这样做有一个好处是比直接看汇编简单一点，因为那个跳来跳去的，这样跳转到哪里，跳转条件至少清楚一点。第一层：检测六个数是否都小于等于6，第二层：用7减去原数据放在原始位置上，第三层：将0x6032d0处数据每隔8字节分别复制到栈中，这个复制顺序和我们的输入有关，比如说我们第一个输入是6，7-6&#x3D;1，就是将0x6032d0+0*8处的数据复制到第一个位置，第二个输入是3，7-3&#x3D;4，那么将0x6032d0+3*8处的数据复制到第二个位置。第四层：将复制到栈中的数据进行比较，大的在前。查看内存</p>
<p><img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230505155410.png"></p>
<p>后面是序号，前面是数据，从大到小排列是345612，这个顺序是被7减过后的，所以原来的是432165</p>
<p>这种做法算是比较粗野的一种，说一下这次做题中遇到的问题，首先是【】的问题，现在在知道了，出现[]一般是要访问内存了，其二注意数据的长度，有dw，qw，b啥的。还有，有时候看不懂的时候就带入具体的数据看一看，比如说第三层那里，看不懂它是将哪里的数据复制到哪里，最后带入654321这样的具体数据一眼就看出了它是如何操作的。</p>
<p><img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230505134616.png"></p>
]]></content>
  </entry>
  <entry>
    <title>csapp笔记</title>
    <url>/2022/12/21/csapp/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一些自己的看法和心得。</p>
<h1 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h1><p>不知道是个人的原因，还是此章节比较特殊的原因，读了一遍，感觉没有进脑子什么东西。查看了一些笔记，说是有一定的C语言基础即可阅读，而第一章更是给读者们找自信的一个章节，这使我十分的迷茫。遇到困难我们就要勇敢的面对困难，硬着头皮整理一下吧。</p>
<span id="more"></span>

<h5 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h5><p>0和1组成位，也成为比特，八个位组成一组称为字节。系统之中所有的信息都是由一串比特表示的，区分不同数据对象的唯一方法就是对照上下文。举个简单的例子，0110 0100，这么一串比特，它既能表示二进制数，又能表示ASCII对应的值d，具体表示什么要联系上下文。</p>
<h5 id="了解编译系统如何工作的益处（书上这么写的不是我总结的）"><a href="#了解编译系统如何工作的益处（书上这么写的不是我总结的）" class="headerlink" title="了解编译系统如何工作的益处（书上这么写的不是我总结的）"></a>了解编译系统如何工作的益处（书上这么写的不是我总结的）</h5><p>1.优化程序性能</p>
<p>2.理解链接时出现的错误</p>
<p>3.避免安全漏洞</p>
<h5 id="了解shell"><a href="#了解shell" class="headerlink" title="了解shell"></a>了解shell</h5><p>第一章中不停的在提及shell。shell是一个命令解释器，他输出一个提示符，等待输入一个命令符，然后执行这个命令。简单的理解一下，Windows系统中我们打开一个程序需要点击其图像，Linux则需要我们输入命令行来打开，shell就是那个供用户输入命令行的程序。shell是一个应用程序，连接了用户和linux内核。参考：(<a href="http://c.biancheng.net/view/706.html">http://c.biancheng.net/view/706.html</a>)</p>
<h5 id="系统是硬件和软件互相交织的集合体（简单介绍一下硬件）"><a href="#系统是硬件和软件互相交织的集合体（简单介绍一下硬件）" class="headerlink" title="系统是硬件和软件互相交织的集合体（简单介绍一下硬件）"></a>系统是硬件和软件互相交织的集合体（简单介绍一下硬件）</h5><h6 id="1-总线"><a href="#1-总线" class="headerlink" title="1.总线"></a>1.总线</h6><p>像神经一样，贯穿于整个系统，携带信息字节并负责在各个部门传递</p>
<h6 id="2-I-x2F-O设备"><a href="#2-I-x2F-O设备" class="headerlink" title="2.I&#x2F;O设备"></a>2.I&#x2F;O设备</h6><p>及输入&#x2F;输出设备，键盘、鼠标为输入设备，显示器和磁盘为输出设备。</p>
<h6 id="3-主存"><a href="#3-主存" class="headerlink" title="3.主存"></a>3.主存</h6><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</p>
<h6 id="4-处理器"><a href="#4-处理器" class="headerlink" title="4.处理器"></a>4.处理器</h6><p>中央处理单元（CPU），简称处理器，世界是（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该指令的地址）。</p>
<h5 id="不大不小的疑惑"><a href="#不大不小的疑惑" class="headerlink" title="不大不小的疑惑"></a>不大不小的疑惑</h5><p>此时年轻懵懂的我不明白为什么有很多很多人念着Linux系统的好，Windows这种图形化控着与此相比有什么难以弥补的劣势？据说以后工作实践中，项目大多也是基于Linux完成的，有时间了一定好好了解一下其中的内幕。</p>
<h1 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h1><h6 id="研究数字的实际表示的意义"><a href="#研究数字的实际表示的意义" class="headerlink" title="研究数字的实际表示的意义"></a>研究数字的实际表示的意义</h6><p> 能够了解可以表时得知和不同算术运算的属性。从而使程序正确工作，更具可移植性，更安全。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230224173354.png"></p>
<h6 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h6><p>大多数计算机使用8位的块（字节）作为最小的可寻址的内存单元。机器级的程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都由一个唯一的数字来标识，称为它的地址。所有可能地址的集合称为虚拟地址空间。</p>
<h6 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h6><p>二进制表示起来过用冗长，而十进制与二进制的转化很麻烦，十六进制表示起来很方便。如果二进制位数不是4的倍数，最左侧补0。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230224174927.png"></p>
<p>j代表的是16进制0的数量。前面的i是1的数量，注意只能是1,11,111,1111这四种表示。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307203238.png"></p>
<h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><h6 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h6><p>字长决定虚拟地址空间的最大大小，我们常说的32位64位都是指的字长，32位字长虚拟地址空间为2的32次方及4GB。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307204456.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307204729.png"></p>
<p>#include&lt;stdint.h&gt;中有关于int32_t等的宏定义，确定的大小可以避免很多麻烦，程序的可移植性也更高。</p>
<h6 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307205643.png"></p>
<p>可以这样说，大端是更符合我们日常思维的那一种。两种端序没有优劣之分，选择哪种字节顺序没有技术上的理由。我们只需选择一种并且始终如一地坚持。</p>
<h6 id="C语言中的逻辑运算"><a href="#C语言中的逻辑运算" class="headerlink" title="C语言中的逻辑运算"></a>C语言中的逻辑运算</h6><p>逻辑运算和按位运算有很大的不同，其一逻辑运算中所有的非零参数都表示TRUE，0参表FALSE，其二，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算就不会对第二个参数求值。</p>
<h6 id="C语言中的移位运算"><a href="#C语言中的移位运算" class="headerlink" title="C语言中的移位运算"></a>C语言中的移位运算</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307222226.png"></p>
<p>几乎所有的编译器都对有符号数使用算数右移（保留最高位），对于无符号数，右移必须是逻辑的。Java中x&gt;&gt;&gt;k是逻辑右移，x&gt;&gt;k是算数右移。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307223156.png"></p>
<h6 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h6><p>强制类型转换结果保持位不变，改变的是对位的解析方式</p>
<h6 id="有符号和无符号处理"><a href="#有符号和无符号处理" class="headerlink" title="有符号和无符号处理"></a>有符号和无符号处理</h6><p>当表达式中同时出现也有符号和无符号，那么C语言会隐式的将有符号数转换为无符号数（位不变），例如表达式-1&lt;0u返回的结果是0，也就是表达式错误，因为将-1的补码按照无符号数来解析。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230324010451.png"></p>
<p>看着好像没什么问题，但是当len等于0，在运算0-1时，计算机会当作0+(-1),因为默认是有符号，而len是无符号的。所以(-1)要从补码转换成无符号数也就是T2U，也就是UMax，所以程序会进入死循环，并且访问到a的非法元素。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230324012052.png"></p>
<p>A.当s比t短的时候会错误的返回1</p>
<p>B.两数相减得到负数会当作无符号数处理，最高位为1也就是一个很大的数大于零</p>
<p>C.改为return strlen(s)&gt;strlen(t)</p>
<h6 id="扩展一个数字的位表示"><a href="#扩展一个数字的位表示" class="headerlink" title="扩展一个数字的位表示"></a>扩展一个数字的位表示</h6><p>如果想扩展一个数字，只需要在它的最高位补上n个符号位，比如说101表示-3，在最左侧加1变为1101还是表示-3，我们可以看到它最高位与后一位的和-8+4&#x3D;-4这也是扩展前符号位的值，我们再给它扩展一位变为11101它还是表示-3，对于非负数我们只需在其前面补上0即可，正好今天在做datalab的howManyBits，和这个正好是相关的，刚开始看到网上师傅举得例子还有点懵，为啥101和1101代表的都是-3，所以我们可以知道有无数种形式的补码可以表示-3，而101是最短的一种。</p>
<h6 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h6><p>截断无符号数：</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230324001954.png"></p>
<h6 id="对于整数运算最后的思考-模运算"><a href="#对于整数运算最后的思考-模运算" class="headerlink" title="对于整数运算最后的思考 模运算"></a>对于整数运算最后的思考 模运算</h6><p>计算机执行整数运算实际上是一种模运算，什么是模运算呢？模运算也就是求余运算，在前面我们可以看到几乎所有的溢出都采取了模最高位取余数的方法。补码的表示，可以使正数加上负数的补码等于减去其原码比如</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>-<span class="number">2</span></span><br><span class="line"><span class="symbol">0000 </span><span class="number">0011</span>-<span class="number">0000</span> <span class="number">0010</span>=  <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"><span class="symbol">0000 </span><span class="number">0011</span>+<span class="number">1111</span> <span class="number">1110</span>=<span class="number">1</span> <span class="number">0000</span> <span class="number">0001</span>//最高位舍去</span><br></pre></td></tr></table></figure>

<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><h6 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h6><p>二进制小数，小数点左边是二的非负权（非负幂），小数点右边是二的负权，这一点和十进制小数并无区别。</p>
<p>二进制小数只能精确的表示形如（x*2的y次幂）的数</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327091512.png"></p>
<h6 id="IEEE浮点数表示"><a href="#IEEE浮点数表示" class="headerlink" title="IEEE浮点数表示"></a>IEEE浮点数表示</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327091842.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327092231.png"></p>
<p>正如书中提到的，浮点数看起来比较深奥难懂，但它是建立在小而一致的原则之上的。</p>
<p>根据exp的值，可以分为三种不同的情况，规格化的、非规格化的或特殊值</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327093637.png"></p>
<h6 id="规格化得值"><a href="#规格化得值" class="headerlink" title="规格化得值"></a>规格化得值</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327093742.png"></p>
<p>小数点在f段最高位的左侧，隐含的以1开头表示。</p>
<h6 id="偏置值"><a href="#偏置值" class="headerlink" title="偏置值"></a>偏置值</h6><p>这个师傅讲的比较简单明了：</p>
<p>拿单精度来说，（规格化）e的取值范围是0000 0001<del>1111 1110也就是1</del>254，肯定不能只使用无符号表示，因为这样只能表示非负数，所以使用E&#x3D;e-Bias，其范围就是-126<del>127，那么为什么不直接用补码表示e呢？这样E的范围就是1111 1111</del>0111 1111&#x3D;（-128~127），可以看出使用偏置和使用补码表示的范围相差不大，还可以不用考虑符号</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327134820.png"></p>
<h6 id="非规格化的值"><a href="#非规格化的值" class="headerlink" title="非规格化的值"></a>非规格化的值</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327094556.png"></p>
<h6 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327095039.png"></p>
<h6 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h6><p>浮点数浮点数采用向偶数最接近的偶数舍入的方法，这样对与那些处在中间的数在50%的时间里会向上舍入(1.5—&gt;2)，在另外的50%的时间会向下舍入(2.5—&gt;2)。</p>
<h6 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327210735.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327210747.png"></p>
<p>下面是对3丢失的解释，所以说浮点数计算不符合结合律</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">对于float</span> <span class="string">符号位</span> <span class="string">阶码</span> <span class="string">尾数分别为</span> <span class="number">1</span> <span class="number">8</span> <span class="number">23</span></span><br><span class="line"><span class="number">1e10</span> <span class="string">=</span> <span class="number">0010 </span><span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">010</span><span class="string">（0</span> <span class="number">0000 </span><span class="number">0000</span><span class="string">）</span></span><br><span class="line">     <span class="string">=1.0</span> <span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">0000 </span><span class="string">X</span> <span class="number">2</span><span class="string">^33</span></span><br><span class="line"><span class="string">表示成浮点数</span>   <span class="string">bias=127</span> <span class="string">所以E=127+33=160=1010</span> <span class="number">0000</span></span><br><span class="line"><span class="number">1e10</span></span><br><span class="line"><span class="string">浮点数：0</span> <span class="number">1010 </span><span class="number">0000 </span><span class="number">0010 </span><span class="number">1010 </span><span class="number">0000 </span><span class="number">0101 </span><span class="number">1111 </span><span class="number">0010</span> </span><br><span class="line"><span class="number">1e10</span><span class="string">+3=</span> <span class="number">0010 </span><span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">010</span><span class="string">（0</span> <span class="number">0000 </span><span class="number">0011</span><span class="string">）</span></span><br><span class="line">      <span class="string">=1.0</span> <span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">0011 </span><span class="string">X</span> <span class="number">2</span><span class="string">^33</span></span><br><span class="line"><span class="string">浮点数</span> <span class="string">=0</span> <span class="number">1010 </span><span class="number">0000 </span><span class="number">0010 </span><span class="number">1010 </span><span class="number">0000 </span><span class="number">0101 </span><span class="number">1111 </span><span class="number">0010</span></span><br><span class="line"><span class="string">可以看出后面括号里的的3=0</span> <span class="number">0000 </span><span class="number">0011</span><span class="string">直接被舍掉了</span></span><br></pre></td></tr></table></figure>

<h1 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章  程序的机器级表示"></a>第三章  程序的机器级表示</h1><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>从十六位过渡到64位不显得突兀，在指令后面加了字符后缀，确定大小<img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405114357.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405114424.png"></p>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405120704.png"></p>
<h2 id="ATT和Intel"><a href="#ATT和Intel" class="headerlink" title="ATT和Intel"></a>ATT和Intel</h2><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405122311.png"></p>
<p>之前接触的是intel的导致我以为这里出现了错误</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>更新一点对栈的认知，之前一直以为将栈顶的值pop之后，内存中的值会消失，原来值会一直存在，直到被覆盖。</p>
<h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><h3 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作"></a>算术操作</h3><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405214930.png"></p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405220431.png"></p>
<h2 id="函数传参和寄存器的关系"><a href="#函数传参和寄存器的关系" class="headerlink" title="函数传参和寄存器的关系"></a>函数传参和寄存器的关系</h2><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230406093404.png"></p>
<p>是按照这个顺序进行传参，并且返回值默认是ax。</p>
]]></content>
      <tags>
        <tag>阅读</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp.lab</title>
    <url>/2023/03/24/csapp-lab/</url>
    <content><![CDATA[<h1 id="1-datalab-handout"><a href="#1-datalab-handout" class="headerlink" title="1.datalab-handout"></a>1.datalab-handout</h1><h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make clean//每次更改都要重新编译</span><br><span class="line">make btest//进行测试</span><br><span class="line">./btest -g//以紧凑形式进行测试</span><br><span class="line">./dlc -e bits.c//检测是否符合编码准则</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/FlamelNW/article/details/123039299">https://blog.csdn.net/FlamelNW/article/details/123039299</a></li>
<li></li>
</ul>
<h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><p>x^y using only ~ and &amp;,用按位运算~和&amp;实现异或。</p>
<p>&amp;是1、1的时候返回1，^是0、1的时候返回1,就拿4和5举例子吧</p>
<p>4：0100  0100 1011 1010 0101 1011</p>
<p>5：0101  0100 1010 1010 0101 1011</p>
<p>x、y是未知的，所以进行~运算的时候一定是对他两个同时。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> w=<span class="number">0</span>;</span><br><span class="line">  z=x&amp;y;<span class="comment">//0100</span></span><br><span class="line">  x=~x;<span class="comment">//1011</span></span><br><span class="line">  y=~y;<span class="comment">//1010</span></span><br><span class="line">  w=x&amp;y;<span class="comment">//1010</span></span><br><span class="line">  w=~w;<span class="comment">//0101</span></span><br><span class="line">  z=~z;<span class="comment">//1011</span></span><br><span class="line">  z=z&amp;w;<span class="comment">//0001</span></span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230312010752.png"></p>
<p>成功，其实很大程度是连蒙带猜的，毕竟就这两种运算。看看大佬是怎么分析的<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230312011601.png"></p>
<p>思路：用(x&amp;y)定位出共同的1所在，用(<del>x&amp;</del>y)定位出共同的0所在，其余部位就是既有1又有0啦，然后非全0部位和非全1部位进行&amp;运算<del>(x&amp;y)&amp;</del>(<del>x&amp;</del>y)</p>
<h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>return minimum two’s complement integer，返回补码最小值。</p>
<p>对于一个正数，它的二进制形式就是它的原码，正数的原码补码反码相同。</p>
<p>对于一个负数，反码是将除符号位以外的位全部取反，补码就是将反码加上1。</p>
<p>对于-1</p>
<p>原码：1000 0001</p>
<p>反码：1111 1110</p>
<p>补码：1111 1111</p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230312202856.png"></p>
<p>补码最小值，及第32位为1，其余位为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="type">int</span> min =<span class="number">1</span>;</span><br><span class="line">   min=min&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p>returns 1 if x is the maximum, two’s complement number,and 0 otherwise，传来的参数是补码的最大值则返回1，其余情况返回0。</p>
<p>从上图我们可以看到，补码的最大值紧挨着补码的最小值，所以我们只要将最小值减1即可，可是题目不允许使用移位操作符。</p>
<p>经过很长时间的思考，发现根本表示不出最大值，参考了一下，豁然开朗，可以假设传入的参数就是就是最大值。我们可以看出最大值有一个特性，那就是max+1&#x3D;<del>(max+1),也不能完全说是特性吧，因为-1也拥有这个属性，仅此两个。首先我们可以通过max^(</del>(max+1)),如果其值返回0那我们可以锁定-1和max这两种情况,接下来我们在排除其是-1这种情况。我们只要找出-1的特性即可，(-1+1)&amp;-1&#x3D;0,其他的任何数都满足不了这一点。这种做法可以实现函数功能，却没有满足操作符的数量，使用了11个操作符，题目规定不能大于10。参考过后修改一下操作数变成9啦。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isMax</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//如果是max则返回1，其余返回0</span></span><br><span class="line">&#123; <span class="comment">//int a=((x+1)&amp;~0);//如果x等于-1则返回0，其余的所有数都是非零</span></span><br><span class="line">  <span class="type">int</span> a=x+<span class="number">1</span>;<span class="comment">//这样也能判断是否为-1</span></span><br><span class="line">  <span class="type">int</span> b=(x^(~(x+<span class="number">1</span>)));<span class="comment">//如果是max或—1则返回0，其余的会返回非0</span></span><br><span class="line">  <span class="type">int</span> c=!!(!a)^(!b);！！可以使非零值返回<span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考一下<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230313005141.png"></p>
<h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p>return 1 if all odd-numbered bits in word set to 1，如果所有的奇数位都为1则返回1，最左侧为第31位，最右侧为第0位。</p>
<p>我们可以看看奇数位为1的数有什么共同点。<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230313201116.png"></p>
<p>额，这我只能说是毫无头绪好吧。奇数位必须为1，偶数位不做要求。灵光一现：左移偶数位，得到的数一定是负数。然而并没有什么卵用。直接选择参考。data&#x3D;1010 1010(32位)，参数x^data,如果x满足要求，则返回data。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目要求可以使用的最大的数为0xff即1010 1010 我们要通过移位操作构造出32位奇数位全为1的data</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">0xAA</span>;<span class="comment">//1010 1010</span></span><br><span class="line"><span class="type">int</span> a2=a&lt;&lt;<span class="number">8</span>|a;<span class="comment">//1010 1010 x 2</span></span><br><span class="line"><span class="type">int</span> data=((a2&lt;&lt;<span class="number">16</span>)|a2);<span class="comment">//1010 1010 x 4 32位</span></span><br><span class="line"><span class="type">int</span> mid=x&amp;data;<span class="comment">//x的偶数位全部变成0，奇数位是1则1，是0则0,即如果x奇数位全部为1则返回data</span></span><br><span class="line"><span class="type">int</span> final=mid^data；<span class="comment">//如果x为符合，则mid==data，则异或结果为0</span></span><br><span class="line"><span class="keyword">return</span> !final;<span class="comment">//final为0则符合，题目让返回1    </span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>可以这么说，这题要是不看点提示，想一天也想不来。还是按位操作这里有所欠缺。</p>
<h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>return -x ，返回-x。即返回一个数的相反数</p>
<p>这题比较简单，我们直接看一个数和他的相反数在二进制形式上有什么异同点。可以看出，只要按位取反再加上1即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0000 0001   1</span></span><br><span class="line"><span class="comment">//1111 1111  -1</span></span><br><span class="line"><span class="comment">//0000 0010   2</span></span><br><span class="line"><span class="comment">//1111 1110  -2</span></span><br><span class="line"><span class="comment">//0111 1111   127</span></span><br><span class="line"><span class="comment">//1000 0001  -127</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (~x)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><p>return 1 if 0x30 &lt;&#x3D; x &lt;&#x3D; 0x39 (ASCII codes for characters ‘0’ to ‘9’)，如果传来的参数是数字则反回1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment">//0x30  0011 0000</span></span><br><span class="line"><span class="comment">//0x31  0011 0001</span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="comment">//0x39  0011 1001</span></span><br><span class="line"><span class="type">int</span> a=(x&gt;&gt;<span class="number">4</span>)^<span class="number">3</span>(<span class="number">0011b</span>);<span class="comment">//若a为0，则说明前28位相同，我们只用再判断后四位即可,若不同则返回值非零</span></span><br><span class="line"><span class="type">int</span> b=(x&gt;&gt;<span class="number">4</span>)^(x+((~<span class="number">10</span>)+<span class="number">1</span>)&gt;&gt;<span class="number">4</span>);<span class="comment">//后四位如果是0~9则返回非零，如果不是则返回0</span></span><br><span class="line"><span class="keyword">return</span> !(a|(!b));<span class="comment">//如果前28位相同，且后四位小于10则返回1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>解释一下最后一行，假设x是数字，则a&#x3D;0，b≠0，c&#x3D;!b&#x3D;0，所以a|(!b)&#x3D;0，反之a|(!b)≠0，所以在前面加上一个！。</p>
<h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p>same as x ? y : z   如果x非零则返回y如果x为零则返回z。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=!!x;<span class="comment">//如果x为零则返回0，如果x非零则返回1</span></span><br><span class="line"><span class="type">int</span> b=(~a)+<span class="number">1</span>;<span class="comment">//如果a=0则返回0(全0)，如果a＝1则返回—1(全1)</span></span><br><span class="line"><span class="keyword">return</span> ((b&amp;y)+((~b)&amp;z));<span class="comment">//如果x为零则b为零，则返回z，反之返回y</span></span><br><span class="line"><span class="comment">//最后的return 也可以写成这样：return (b&amp;y)|((~b)&amp;z)</span></span><br></pre></td></tr></table></figure>

<h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>if x &lt;&#x3D; y  then return 1, else return 0  如果x&lt;&#x3D;y,返回1，反之返回0</p>
<p>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=x+((~y)+<span class="number">1</span>);<span class="comment">//a=x-y,如果a&lt;0，则a的最高位为1，如果a&gt;=0,最高位时0，这样有点不好实现，因为小于和等于没在一起</span></span><br><span class="line"><span class="type">int</span> b=y+((~x)+<span class="number">1</span>);<span class="comment">//b=y-x,如果y&gt;=x,则b的最高位为0，反之b的最高位为1</span></span><br><span class="line"><span class="type">int</span> c=b&gt;&gt;<span class="number">31</span>;<span class="comment">//如果成立则返回全0，如果不成立则返回全1</span></span><br><span class="line"><span class="keyword">return</span> c+<span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<p>本来以为简简单单大功告成，进行测试发现没分，cao,上面的方法只适合同符号比较。   y&gt;&#x3D;x等价于y-x&gt;&#x3D;0在数学是行得通的，可是在计算机中要考虑 溢出问题。也就是可能会出现一些比较诡异的情况：</p>
<p>当y&lt;0,x&gt;0时，可能出现y-x&gt;0的情况，比如1000 0000-0000 0001<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230316233030.png"></p>
<p>可以看到，由于第一位的1变成了0，所以就变成了正数。</p>
<p>当y&gt;0,x&lt;0时，可能出现y-x&lt;0的情况，比如0000 0001-1000 0000<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230316234033.png"></p>
<p>有什么是可以肯定的呢，符号不同时，正数肯定比负数大，符号相同时看差值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我测真的烦</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> singX=(x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//如果不&amp;1，负数情况下就会返回-1</span></span><br><span class="line">    <span class="type">int</span> signY=(y&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> signY_X=((y+(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//y-x如果大于等于则返回0，小于则返回1</span></span><br><span class="line">    <span class="type">int</span> checknSign=signX^signY;<span class="comment">//相同为0，不同为1</span></span><br><span class="line">    <span class="keyword">return</span> (!checkSign&amp;!signY_X)|(checkSign&amp;signX)</span><br><span class="line">&#125;          符号相同，看差的符号         符号不同时，x&lt;<span class="number">0</span>则返回<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个return比较长，我们分开来看一下其实很简单，</p>
<p>左半部分：!checkSign&amp;!signY_X，符号相等的情况，符号相等不用考虑溢出的问题，我们可以直接根据差值的符号进行大小的判断，符号相等则check为0，signY_X如果满足则为0，否则为1，这里我们倒换一下，也就是满足时返回1，不满足时返回0，如果出现符号不相等，则左半部分返回0</p>
<p>右半部分：如果符号相同则右半部分返回0，如果符号不同，那么我们只需要看x的符号即可，如果x是负数，一定满足条件则返回他的符号1</p>
<p>反思：卡在这里很久很久，因为什么？？？一个很重要的原因对按位运算|掌握得不够熟悉，看到很多师傅的解前面有很多都使用了|，从这一题往后很难不用到|，不能再简单的使用加减。</p>
<h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p>implement the ! operator, using all of   the legal operators except !</p>
<p> Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>使用其他合规操作符实现！，也就是传入的参数为0则返回1，非零则返回0</p>
<p>思路零：未完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//0   0000 0000     0的相反数是0 相反数和自身异或取其符号位，为零则为零，非零则为1</span></span><br><span class="line"><span class="comment">//正数 0000 1110</span></span><br><span class="line"><span class="comment">//负数 1000 0100</span></span><br><span class="line"><span class="comment">//0 异或0为0</span></span><br><span class="line">   <span class="type">int</span> signX=(X&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//获取x的符号，负数则为1</span></span><br><span class="line">   <span class="type">int</span> _signX=((~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//获取-x的符号</span></span><br><span class="line">   <span class="keyword">return</span> signX^_signX^<span class="number">1</span>;</span><br><span class="line">   <span class="comment">//零异或上自己的相反数为0，其他数为1，在异或上1，改变符号</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> xor0=(<span class="number">0</span>^x)&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;x为零和正数则为<span class="number">0</span>，负数返回<span class="number">1</span></span><br><span class="line">    <span class="comment">//我们需要这样一个数，等于零时返回1，其余时候返回0 死循环</span></span><br></pre></td></tr></table></figure>

<p>运行失败，看以下错误原因</p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230323155705.png"></p>
<p>0x80000也就是最小数10000000这里出现了错误，我们知道对于有符号整型，负数范围比正数大一，所以表示不出来最小数的相反数，这个数和零一样，相反数等于自身。收到一位师傅的启发，我们可以给符号位取反，这样0x80000的符号位就变成0，不造成影响</p>
<p>思路一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> _x=~x+<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> sign=(((~x&amp;~_x))&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sign;</span><br><span class="line">   取反后非零数相反数进行&amp;运算符号位为<span class="number">0</span>，如果不进行取反操作则不能绕过<span class="number">0x8000</span>这个存在，它的相反数和自身符号相同都为<span class="number">1</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>思路二：</p>
<p>一个非零数或上自己的相反数其符号位总是1，最小值0x8000也不例外，虽然它的相反数无法表示，但其最高位都是1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sign=(x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>;如果是零则返回<span class="number">0000</span>，非零则返回<span class="number">1111</span></span><br><span class="line">    <span class="keyword">return</span> sign+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都是用到相反数，只是如果使用异或的话不可行，因为0和min的相反数最高位相同，所以只能考虑使用|或&amp;。</p>
<h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p>return the minimum number of bits required to represent x in   two’s complement    返回用二进制补码表示x的最小位数，比如1、0只用一位即可表示</p>
<p>-1也是1，因为-1的补码是1111 1111其实等价于1，补码101和1101代表的都是-3，所以-3最少需要三位，补码的最高位是符号位，就像非负数01和001、0001代表的都是1，前面有多少0都无关紧要，对于负数的补码，前面有多少个1都无关紧要，用数学来解释的话就是最高的两位之和是个定值，对于101最高两位是-2&#x3D;-2，对于1101最高两位是-4+2&#x3D;-2。</p>
<p>负数以补码的形式储存，正数的原码补码反码相同。思路：如果是整数那就检索其最高位的1的位置，如果1首先出现在了第三位，比如0101，最高位的1所在的位置就是3，那么这个数最少就可以用3+1位来表示,加的那个1是符号位。对于负数，我们检索其最高位0出现的位置，11101，0出现在第2位，那么最少可以用2+1（符号位）来表示此数，对于-1也就是全1，可以用1表示，仍然符合，也就是它的第0位是0然后我们加上1。</p>
<p>那么怎么检索呢？一个一个来肯定是不能满足操作符数量上的要求的。可以用二分法，我们处理的int是32位的，我们可以先检测它的前十六位，比如说如果全部位0，那么肯定可以用16及更少的位来表示它，再检测其余十六位的前八位，如果不全为零，那么我们继续缩小范围，检测前八位的前四位……</p>
<p>具体怎么实现还是参考的网上的，两个主要操作：计数和缩小范围</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a0,a1,a2,a4,a8,a16;</span><br><span class="line">   <span class="type">int</span> w;<span class="comment">//位数</span></span><br><span class="line">   <span class="type">int</span> sign=x&gt;&gt;<span class="number">31</span>;<span class="comment">//如果是正数返回全0，如果是负数返回全1</span></span><br><span class="line">   x=(~sign&amp;x)|(sign&amp;~x);<span class="comment">//如果是非负数则返回x，如果是负数则按位取反</span></span><br><span class="line">   a16=(!!(x&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;<span class="comment">//右移16位，两次取非，左移4；如果如果没出现1则高16位为0则返回0，如果出现1则非零则返回16</span></span><br><span class="line">   x=x&gt;&gt;a16;<span class="comment">//如果高十六位非零，右移16位；</span></span><br><span class="line">   a8=(!!(x&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;<span class="comment">//如果前十六位为0，则检测其前24位，如果无1，则返回0，如果出现1，则返回8；如果前十六位不为0，则检测32~25位，如果为0则返回0，否则返回8</span></span><br><span class="line">   x=x&gt;&gt;a8;<span class="comment">//如果a8非零则右移8位；</span></span><br><span class="line">   a4=(!!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>);<span class="comment">//如果前8位为零的话，检测其前28位；如果前8位不为为零的话，这一步检测其前四位（32~29位），如果非零则返回4，为零返回0；</span></span><br><span class="line">   x=x&gt;&gt;a4;</span><br><span class="line">   a2=!!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;<span class="comment">//如果24位为零的话，则只检测其前30位，为零则返回0，出现1则返回2；</span></span><br><span class="line">   x=x&gt;&gt;a2;<span class="comment">//如果a2非零则右移四位</span></span><br><span class="line">   a1=!!(x&gt;&gt;<span class="number">1</span>);<span class="comment">//如果前30位为零的话，则检测其前31位。</span></span><br><span class="line">   x=x&gt;&gt;a1;<span class="comment">//如果a1非零则右移两位</span></span><br><span class="line">   a0=x;<span class="comment">//如果前31位为零，那么x要么是1，要么是0</span></span><br><span class="line">   w=a0+a1+a2+a4+a8+a16+<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> w;<span class="comment">//1是符号位</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>float型 符号 阶码 尾数位分别为 1、8、23，</p>
<p>规格化的，尾数以隐含的1开头，E&#x3D;e-bias</p>
<p>非规格化的，尾数无隐含的1，E&#x3D;1-bias</p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230328115316.png"></p>
<h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><p>Return bit-level equivalent of expression 2*f for floating point argument f.将传来的参数当成float的位级表示，返回浮点数乘2的位级表示，如果是NAN和极大值(阶码全部为1)则返回0x800000(1000 0000)</p>
<p>思路：对于规格话数，乘2只需要将阶码+1，其它位保持不变</p>
<p> 非规格化的数左移一位即可得到2倍，原因见下图。参考：<a href="https://blog.csdn.net/qq_43855740/article/details/106843924">https://blog.csdn.net/qq_43855740/article/details/106843924</a></p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230328140534.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;   <span class="comment">//拿1来举例子0    0000 0000    0000 0000 0000 0000 0000 001</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> s=((uf&gt;&gt;<span class="number">31</span>)&lt;&lt;<span class="number">31</span>);<span class="comment">//符号            0    0000 0000    0000 0000 0000 0000 0000 000 </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> e=((uf&gt;&gt;<span class="number">23</span>)&lt;&lt;<span class="number">24</span>&gt;&gt;<span class="number">1</span>);<span class="comment">//获得阶码     0    0000 0000    0000 0000 0000 0000 0000 000</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> m=((uf&lt;&lt;<span class="number">9</span>)&gt;&gt;<span class="number">9</span>);<span class="comment">//获得尾数           0    0000 0000    0000 0000 0000 0000 0000 001</span></span><br><span class="line">  <span class="keyword">if</span>(e==<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> (uf&lt;&lt;<span class="number">1</span>)|s;<span class="comment">//非规格化数左移1位变为两倍，再恢复其符号位</span></span><br><span class="line">  <span class="keyword">if</span>(e==<span class="number">0x7f800000</span>)<span class="comment">//无穷大和非规格化数 无穷大的二倍还是无穷大</span></span><br><span class="line">   <span class="keyword">return</span> uf;</span><br><span class="line">  e=(((uf&gt;&gt;<span class="number">23</span>)+<span class="number">1</span>)&lt;&lt;<span class="number">24</span>&gt;&gt;<span class="number">1</span>);<span class="comment">//获得阶码+1 </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> r=s+e+m;</span><br><span class="line">  <span class="keyword">return</span> r;                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h3><p>Return bit-level equivalent of expression (int) f  for floating point argument f.将浮点型转换为位级等价整数 Anything out of range (including NaN and infinity) should return 0x80000000u.</p>
<p>取出他的符号 指数和尾数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s=uf&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;<span class="comment">//取符号</span></span><br><span class="line">     <span class="type">int</span> e=(uf&lt;&lt;<span class="number">1</span>&gt;&gt;<span class="number">24</span>)<span class="number">-127</span>;<span class="comment">//e属于(-127~126)</span></span><br><span class="line">     <span class="type">int</span> m=uf&lt;&lt;<span class="number">9</span>&gt;&gt;<span class="number">9</span>;<span class="comment">//尾数</span></span><br><span class="line">     m=m+<span class="number">0x800000</span>;</span><br><span class="line">     <span class="type">int</span> r=<span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&lt;<span class="number">0</span>)<span class="comment">//小数点左移，实际的数就是0.xxx</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&gt;<span class="number">31</span>)<span class="comment">//溢出，包括NaN</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(e&gt;<span class="number">23</span>)</span><br><span class="line">        m=(m&lt;&lt;(e<span class="number">-23</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m=(m&gt;&gt;(<span class="number">23</span>-e));</span><br><span class="line">    <span class="type">int</span> mSign=m&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s)<span class="comment">//如果传来的参数是负数，那么我们直接将得到的数取反</span></span><br><span class="line">      <span class="keyword">return</span> -m;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//传参为正数</span></span><br><span class="line">      <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h3><p>Return bit-level equivalent of the expression 2.0^x  (2.0 raised to the power x) for any 32-bit integer x.以浮点数形式返回2^x&#x3D;r</p>
<p>2的多少次方，其尾数全零，隐含1，我们只需要将e改为127+x即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> e=x+<span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&gt;=<span class="number">255</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x7F000000</span>u;<span class="comment">//返回+INF（正无穷大）</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (e&lt;&lt;<span class="number">23</span>)|<span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230328212413.png"></p>
<p>完结撒花</p>
]]></content>
      <tags>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h2 id><a href="#" class="headerlink" title></a><span id="more"></span></h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a><!--more--></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>汇编语言</title>
    <url>/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>​       </p>
<h1 id="debug中的常用命令"><a href="#debug中的常用命令" class="headerlink" title="debug中的常用命令"></a>debug中的常用命令</h1><ul>
<li><p>g 加地址，直接跳转至此处，前面全部执行 </p>
</li>
<li><p>u 将内存中的机器指令翻译成汇编指令</p>
</li>
<li><p>t 执行一条指令</p>
<span id="more"></span>
</li>
<li><p>r 查看寄存器中的值，同时显示出下一条要执行的指令，还可以改变寄存器中的内容，比如r ax，然后弹出冒号，输入即可</p>
</li>
<li><p>d 查看内存中的内容，d 段地址：偏移地址 (可以在此处加上想查看的范围，默认是128字节)，之后再按d显示后续内容</p>
</li>
<li><p>p 可以跳过loop循环</p>
</li>
<li><p>e 向内存单元写入命令，e 段地址:偏移地址 B8 01 00,即向该内存写入mov ax,1命令</p>
</li>
</ul>
<h1 id="第7章-更灵活的定位内存地址的方法"><a href="#第7章-更灵活的定位内存地址的方法" class="headerlink" title="第7章 更灵活的定位内存地址的方法"></a>第7章 更灵活的定位内存地址的方法</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230313180808.png"></p>
<p>话不多说，直接上图，完成了任务。只不过忘掉了如何一次性执行完循环，一直t加回车，头皮发麻。这一题是让我们补充codesg段的代码，我们要灵活的利用栈来存储和释放cx</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230313181241.png"></p>
<p>s0处的push cx是将外层循环的cx值压入栈中，然后往下执行，mov cx,4设置内层循环次数，执行完4次s1后，此时的cx值为零，将之前cx的值弹出栈，恢复为3(即4-1)，然后往复执行。</p>
<h5 id="tips-快速结束循环"><a href="#tips-快速结束循环" class="headerlink" title="tips 快速结束循环"></a>tips 快速结束循环</h5><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230313182253.png"></p>
<p>再补充一个快速的指令 g 偏移地址，例如g 0012执行后，ip&#x3D;0012，从此处开始往下执行。</p>
<h1 id="第8章-数据处理的两个基本问题"><a href="#第8章-数据处理的两个基本问题" class="headerlink" title="第8章 数据处理的两个基本问题"></a>第8章 数据处理的两个基本问题</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230315004402.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230315004456.png"></p>
<p>只有上述形式是是正确的，有个小要点，[bp]默认的段地址是ss。</p>
<h5 id="指令要处理的数据有多长"><a href="#指令要处理的数据有多长" class="headerlink" title="指令要处理的数据有多长"></a>指令要处理的数据有多长</h5><p>这是我们必须指出的，可以显性地指出也可以隐形的指出，比如在有寄存器名称的情况下我们可以判断出访问的是字单元还是字节单元，在没有寄存器参与的情况下用操作符X ptr指明长度。X为byte或word。对于push [1000]这样的指令则无需指明，因为push指令只进行字操作。</p>
<h3 id="实验-7"><a href="#实验-7" class="headerlink" title="实验 7"></a>实验 7</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322200528.png"></p>
<p>废了九牛二虎之力终于用比较朴素的方法实现了。遇到了不少问题，其中最主要的两个是：</p>
<ol>
<li>error A2052: Improper operand type</li>
<li>g命令之后卡死</li>
</ol>
<p>第一个在经过Google之后找到了解答<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322202425.png"></p>
<p>我记得这一点书上好像提到过，给忘掉了，真是一头雾水</p>
<p>第二个问题，算是摸索着解开了疑惑，网上说有三种情况，1.代码段没加mov ax,4c00h 2.重启解决 3.代码导致g命令出错</p>
<p>我的情况应该是属于第三种，因为我按自己的想法写的时候，寻址方式比较奇怪。比如说我成功之前的那一次</p>
<h5 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div word ptr [bx].0Ah//g命令后卡死，虽然这两处的值不相同，但按道理来说结果会出错，不应该出现程序卡死，此处存有疑惑</span><br><span class="line">div word ptr [bx+0ah]//也不可行</span><br><span class="line">div word ptr es:[bx+0ah]//成功，上边的错误在于忘记了要标明es段，可是有一点存疑，就算用的是ds段地址，那同样也能读取数据，为什么会卡死呢？？？？？</span><br><span class="line">div word ptr [168+si]//正确</span><br></pre></td></tr></table></figure>

<h5 id="寻址方式小结"><a href="#寻址方式小结" class="headerlink" title="寻址方式小结"></a>寻址方式小结</h5><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322203639.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg                        //写的比较朴实，可能有较多重复的步骤，也可以一次循环填充一行中的所有信息，然后循环</span><br><span class="line">data segment                            //21次即可</span><br><span class="line">db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;</span><br><span class="line">db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line"></span><br><span class="line">dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">dd 345980,590827,803530,1183000,1843000,2759000,375000,4649000,5937000</span><br><span class="line"></span><br><span class="line">dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">dw 11542,14430,15257,17800</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line">table segment</span><br><span class="line">db 21 dup(&#x27;year sumn ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line">codesg segment</span><br><span class="line">   start:mov ax,data</span><br><span class="line">         mov ds,ax</span><br><span class="line">         mov ax,table</span><br><span class="line">         mov es,ax</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s0: mov ax,[si]                       </span><br><span class="line">         mov es:[bx],ax</span><br><span class="line">         add si,2</span><br><span class="line">         mov ax,[si]</span><br><span class="line">         mov es:[bx+2],ax</span><br><span class="line">         add si,2</span><br><span class="line">         add bx,16                                </span><br><span class="line">         loop s0</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s1: mov ax,[84+si]                          </span><br><span class="line">         mov es:[bx+5],ax              </span><br><span class="line">         add si,2</span><br><span class="line">         mov ax,[84+si]</span><br><span class="line">         mov es:[bx+5+2],ax</span><br><span class="line">         add si,2</span><br><span class="line">         add bx,16                             </span><br><span class="line">         loop s1</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s2: mov ax,[168+si]                         </span><br><span class="line">         mov es:[bx+0Ah],ax</span><br><span class="line">         add bx,16</span><br><span class="line">         add si,2</span><br><span class="line">         loop s2</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s3: mov ax,es:[bx+5]</span><br><span class="line">         mov dx,es:[bx+5+2]</span><br><span class="line">         div word ptr [168+si]</span><br><span class="line">         mov es:[bx+0Dh],ax</span><br><span class="line">         add si,2</span><br><span class="line">         add bx,16</span><br><span class="line">         loop s3</span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start      </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这次的实验知识发现了不少短板，hhh或者说全是短板哈哈哈哈，很多基础的东西打的不是很牢固，比如说高低字节，高低位</p>
<h5 id="高低字节，高低位"><a href="#高低字节，高低位" class="headerlink" title="高低字节，高低位"></a>高低字节，高低位</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">对于 <span class="number">1234</span>h这个十六进制数来说，其高字节是<span class="number">12</span>，低字节是<span class="number">34</span></span><br><span class="line">我们平时接触小端序比较多，那么高字节<span class="number">12</span>存放在高地址单元中，低字节<span class="number">34</span>存放在低地址单元中</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322204849.png"></p>
<p>如果我们进行div word ptr ds:0操作，那么处理的也就是0、1这两个内存单元组成的数1234h。</p>
<h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><h2 id="操作符offeset"><a href="#操作符offeset" class="headerlink" title="操作符offeset"></a>操作符offeset</h2><p>offeset在汇编语言中是由编译器处理的符号，它的功能是取得标号处的偏移地址<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330172558.png"></p>
<h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><h3 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h3><p>CPU在执行jmp指令的时候不需要转移的目的地址，需要的是位移量。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173053.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173151.png"></p>
<h4 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h4><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173536.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173606.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173835.png"></p>
<p>可以看到，这里是通过目的地址而非位移量进行转移的</p>
<h4 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h4><p>jmp word ptr 内存单元地址（段内转移）</p>
<p>jmp dword ptr 内存段地址（段间转移）</p>
<p>对于段间转移 （CS）&#x3D;（内存单元地址+2），</p>
<p>​                        （IP） &#x3D;（内存单元地址）</p>
<h3 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h3><p>有条件的段间转移，有条件转移都是段间的，在对应的机器码中包含位移而不是地址。当cx&#x3D;&#x3D;0的时候执行跳转，cx!&#x3D;0时直接执行下一条语句<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330175241.png"></p>
<h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><p>循环指令都是段指令，对应的机器码中包含位移地址而不是目的地址<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330175446.png"></p>
<h2 id="实验八-分析一个奇怪的程序"><a href="#实验八-分析一个奇怪的程序" class="headerlink" title="实验八 分析一个奇怪的程序"></a>实验八 分析一个奇怪的程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">start:</span><br><span class="line">       mov ax,0</span><br><span class="line">s:     nop</span><br><span class="line">       nop</span><br><span class="line">       mov di,offset s</span><br><span class="line">       mov si,offset s2</span><br><span class="line">       mov ax,cs:[si]</span><br><span class="line">       mov cs:[di],ax</span><br><span class="line">s0: jmp short s</span><br><span class="line">s1: mov ax,0</span><br><span class="line">       int 21h</span><br><span class="line">       mov ax,0</span><br><span class="line">s2: jmp short s1</span><br><span class="line">       nop</span><br><span class="line">codesg ends</span><br><span class="line">       end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然看着是挺奇怪的，s的操作就是使s处的命令变为s2处的命令，即跳转到s1，很显然mov ax,0这里不满足让程序正确返回，用debug的t命令进行调试，可以成功运行，我们知道jup命令是不带有目标位置的地址的，它含有一个偏移地址，s2处的jump short s1的机器码是EB F6,F6就是偏移地址1111 0110补码表示-10，-10含义是标号处的地址-jmp指令后的第一个字节的地址，也就是从mov di,offset s位置前移十个字节，正好到达mov ax,4c00h int 21h，程序得以成功返回</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330172008.png"></p>
<h2 id="实验九"><a href="#实验九" class="headerlink" title="实验九"></a>实验九</h2><p>将’welcome to masm!’正好16个字符，填入第11、12、13行</p>
<p>绿色属性 0 000 0 010B                 02h</p>
<p>绿底红字属性  0 010 0 100B         24h</p>
<p>白底蓝色属性 0 111 0 001B          71h</p>
<p>经过不懈的努力终于是搞好了，困住我的主要有两点，其一是对字，字节，寄存器不敏感，对于传输字和字节有点生疏。其二就是让我崩溃的东西，题目要求是打印在中间，我一想80个字符位，左边空出32，右边空出32中间正好留下16，然后左边的32x2&#x3D;64，有因为是从零开始，所以这边我们第一个填充的位置就是64呀，当成了63操作，结果是真抽象，还好最后一试，将welcome全部改成了11111，打印出来发现全部是同一个颜色的符号，也就是说我的颜色就然和字符与关，果断想到填充错了位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg,ds:data</span><br><span class="line">data segment</span><br><span class="line">  db &#x27;welcome to masm!&#x27;</span><br><span class="line">data ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov di,0</span><br><span class="line">      mov cx,16</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov ax,0B800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov si,06e0h</span><br><span class="line">      mov ah,02h</span><br><span class="line">   s0:mov al,ds:[di]</span><br><span class="line">      mov es:[bx+si+64],al</span><br><span class="line">      mov es:[bx+si+65],ah</span><br><span class="line">      add bx,2</span><br><span class="line">      add di,1</span><br><span class="line">      loop s0</span><br><span class="line">      mov ax,0B800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,0</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov si,780h</span><br><span class="line">      mov cx,16</span><br><span class="line">   s1:mov al,ds:[di]</span><br><span class="line">      mov es:[bx+si+64],al</span><br><span class="line">      mov al,24h</span><br><span class="line">      mov es:[bx+si+65],al</span><br><span class="line">      add bx,2</span><br><span class="line">      inc di</span><br><span class="line">      loop s1</span><br><span class="line">      mov ax,0B800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov di,0</span><br><span class="line">      mov si,820h</span><br><span class="line">      mov cx,16</span><br><span class="line">   s2:mov al,ds:[di]</span><br><span class="line">      mov es:[bx+si+64],al</span><br><span class="line">      mov al,71h</span><br><span class="line">      mov es:[bx+si+65],al</span><br><span class="line">      add bx,2</span><br><span class="line">      inc di</span><br><span class="line">      loop s2</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230331013823.png"></p>
<h1 id="第十章-CALL指令和RET指令"><a href="#第十章-CALL指令和RET指令" class="headerlink" title="第十章 CALL指令和RET指令"></a>第十章 CALL指令和RET指令</h1><h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><p>ret指令只修改ip的内容，实现近迁移，retf应该就是ret far的意思，同时修改cs和ip中的内容，实现远迁移。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032439.png"></p>
<p>用汇编语言解释</p>
<p>ret：POP IP</p>
<p>retf：POP IP ,POP CS</p>
<h2 id="CALL指令"><a href="#CALL指令" class="headerlink" title="CALL指令"></a>CALL指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032635.png"></p>
<h3 id="依据位迁移进行转移的call指令"><a href="#依据位迁移进行转移的call指令" class="headerlink" title="依据位迁移进行转移的call指令"></a>依据位迁移进行转移的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032834.png"></p>
<p>下面程序执行后，ax的值</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032932.png"></p>
<p>读取过call s指令后，ip中的值自动增加（第二章 28页），变为6，call指令相当于push ip，s处是pop ax，所以ax的值为6。</p>
<h3 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402033501.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402034116.png"></p>
<h3 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402034837.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402034852.png"></p>
<p>bp的默认段地址是ss</p>
<h3 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402035632.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402040248.png"></p>
<p>回顾一下jump dword ptr 内存单元地址 </p>
<p>CS&#x3D;（内存单元地址+2）</p>
<p>IP&#x3D;（内存单元地址）</p>
<h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230403170535.png"></p>
<h2 id="实验-10-编写子程序"><a href="#实验-10-编写子程序" class="headerlink" title="实验 10 编写子程序"></a>实验 10 编写子程序</h2><p>1.显示字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line">data segment</span><br><span class="line">db&#x27;welcome to masm!&#x27;,0</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">db 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov dh,8 ;传参 8行 3列 绿色</span><br><span class="line">      mov dl,3</span><br><span class="line">      mov cl,2</span><br><span class="line">      mov ax,data</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,0</span><br><span class="line">      call show_str</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">show_str:</span><br><span class="line">      sub dh,1;这里注意000是第一行开始，160是第2行开始</span><br><span class="line">      mov al,160</span><br><span class="line">      mul dh;存入的数据是7*160，即第八行开始</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dh,0</span><br><span class="line">      add bx,dx</span><br><span class="line">      add bx,dx;这里实现列数，注意两个字节表一个字符，所以我们加两次即加6</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov al,cl</span><br><span class="line">    s:mov cl,[si]</span><br><span class="line">      mov ch,0</span><br><span class="line">      jcxz ok;如果是结束字符0，则跳转回去</span><br><span class="line">      mov es:[bx],cl</span><br><span class="line">      mov es:[bx+1],al</span><br><span class="line">      inc si</span><br><span class="line">      add bx,2</span><br><span class="line">      jmp short s</span><br><span class="line">      </span><br><span class="line">ok:   ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>由于粗心出现了一个警告 missing data：zero assume，提醒我们缺少操作数</p>
<p>把add bx,dx写成了add bx,dx</p>
<p>2.解决除法的溢出问题</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230404195800.png"></p>
<p>给出了一个提示</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230404195943.png"></p>
<p>65536是十六进制的1 0000也就是将得到的数左移四个16进制位呗，我们可以直接把int(H&#x2F;N)的内容直接放入dx中，然后把后面的整体装入ax中，把后面整体产生的余数装入cx中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line">stack segment</span><br><span class="line">dw 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">      mov ss,ax</span><br><span class="line">      mov sp,10h</span><br><span class="line">      mov ax,4240h</span><br><span class="line">      mov dx,000fh</span><br><span class="line">      mov cx,0ah</span><br><span class="line">      call divdw</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">divdw:push ax</span><br><span class="line">      push dx</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dx,0</span><br><span class="line">      pop ax</span><br><span class="line">      div cx</span><br><span class="line">      push ax;商</span><br><span class="line">      push dx;余</span><br><span class="line">      mov ax,bx</span><br><span class="line">      div cx</span><br><span class="line">      mov cx,dx</span><br><span class="line">      pop dx</span><br><span class="line">      pop dx</span><br><span class="line">      pop si;它存在的意义是把栈清理到只剩一个，以便使下面的ret成功返回</span><br><span class="line">      ret    ;前面哪些部分其实可以不使用栈，此题占用的寄存器不多</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230404221743.png"></p>
<p>3.数值显示将二进制转化为十进制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line"> db 10 dup (10)</span><br><span class="line"> data ends</span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">start:mov ax,12666</span><br><span class="line">      mov bx,data</span><br><span class="line">      mov ds,bx</span><br><span class="line">      mov si,0</span><br><span class="line">      call dtoc</span><br><span class="line"></span><br><span class="line">      mov dh,8</span><br><span class="line">      mov dl,3</span><br><span class="line">      mov cl,2</span><br><span class="line">      call show_str</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line"> </span><br><span class="line"> dtoc:mov dx,0</span><br><span class="line">      mov bx,10</span><br><span class="line">      div bx;余数在dx，商在ax</span><br><span class="line">      mov cx,ax</span><br><span class="line">      add dx,30h</span><br><span class="line">      mov [si],dl;存放余数的ascii</span><br><span class="line">      inc si;表示位数</span><br><span class="line">      jcxz short s1</span><br><span class="line">      jmp short dtoc</span><br><span class="line">   s1:ret</span><br><span class="line">show_str:</span><br><span class="line">      sub dh,1</span><br><span class="line">      mov al,160</span><br><span class="line">      mul dh</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dh,0</span><br><span class="line">      add bx,dx</span><br><span class="line">      add bx,dx</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov al,cl</span><br><span class="line">    s:mov cl,[-1+si];66621</span><br><span class="line">      mov ch,0</span><br><span class="line">      ;jcxz ok 如果不注释掉的话，以零结尾的数将无法显示</span><br><span class="line">      mov es:[bx],cl</span><br><span class="line">      mov es:[bx+1],al</span><br><span class="line">      sub si,1</span><br><span class="line">      mov cx,si</span><br><span class="line">      jcxz short ok</span><br><span class="line">      add bx,2</span><br><span class="line">      jmp short s</span><br><span class="line">ok:   ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>感谢这位博主：<a href="https://blog.csdn.net/qq_60829702/article/details/123582250">https://blog.csdn.net/qq_60829702/article/details/123582250</a></p>
<h1 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406121332.png"></p>
<h2 id="ZF-标志"><a href="#ZF-标志" class="headerlink" title="ZF 标志"></a>ZF 标志</h2><p>记录相关指令执行后结果是否为零，如果为零则ZF为1，如果非零则ZF为0。</p>
<h2 id="PF-标志"><a href="#PF-标志" class="headerlink" title="PF 标志"></a>PF 标志</h2><p>记录执行相关指令后，结果的所有bit位1的个数是否为偶数，如果1的数量是偶数，则PF为1.</p>
<h2 id="SF-标志"><a href="#SF-标志" class="headerlink" title="SF 标志"></a>SF 标志</h2><p>记录执行相关指令后，结果是否为负，如果结果为负，则SF为1.</p>
<h2 id="CF-标志"><a href="#CF-标志" class="headerlink" title="CF 标志"></a>CF 标志</h2><p>在进行无符号运算时，它记录进位和借位情况</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406122332.png"></p>
<p>进位比较好理解，下面看一下借位</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406122516.png"></p>
<h2 id="OF-标志"><a href="#OF-标志" class="headerlink" title="OF 标志"></a>OF 标志</h2><p>进行有符号运算是否发生溢出，如果溢出则OF为1.<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406123023.png"></p>
<h2 id="adc-指令"><a href="#adc-指令" class="headerlink" title="adc 指令"></a>adc 指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406123128.png"></p>
<p>这个指令乍一看很奇怪，很多余，为什么要加上一个cf？但是看了下面的解释之后，我直呼巧妙</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406123359.png"></p>
<p>adc也会对CF位进行设置，由于这样的功能，我们可以对任意大的数据进行加法运算。</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406124107.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406124125.png"></p>
<h2 id="sbb-指令"><a href="#sbb-指令" class="headerlink" title="sbb 指令"></a>sbb 指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406133522.png"></p>
<h2 id="cmp-指令"><a href="#cmp-指令" class="headerlink" title="cmp 指令"></a>cmp 指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406134232.png"></p>
<p>可以通过标志寄存器中的值得出比较结果<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406134301.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406171440.png"></p>
<p>这里有点疑惑的，为什么实际结果为负，且发生了溢出，就可以推出实际结果为正。溢出，有正溢出和负溢出。正溢出就是两个正数相加，超过了能表示的最大范围，变为负数，负溢出就是两个负数相加，超出了能表示的最小范围，变为正数。举个例子：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">拿四位有符号数来举例</span><br><span class="line"><span class="attribute">MAX</span>==0111==7</span><br><span class="line"><span class="attribute">MIN</span>==1000==-8</span><br><span class="line">正溢出0111+<span class="attribute">0111</span>==1110(补码)==-2</span><br><span class="line">负溢出1000+<span class="attribute">1000</span>==10000截断最高位==0000两个负数相加结果为0</span><br></pre></td></tr></table></figure>

<p>好的疑惑消失了。</p>
<h2 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h2><p>这些指令往往和cmp搭配使用，因为cmp可以同时进行两种比较，无符号数比较和有符号数比较。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406181600.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406181626.png"></p>
<h2 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406183935.png"></p>
<p>串传送指令：movsb，实现传送一个字节，movsw实现传送一个字</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184037.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184052.png"></p>
<p>movsb一般和rep搭配使用</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184255.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184459.png"></p>
<h2 id="pushf-和-popf"><a href="#pushf-和-popf" class="headerlink" title="pushf 和 popf"></a>pushf 和 popf</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184609.png"></p>
<p>push 和 pop显然不能进行这些操作，他两个的操作对象是字而不是bit。</p>
<h2 id="标志寄存器在Debug中的表示"><a href="#标志寄存器在Debug中的表示" class="headerlink" title="标志寄存器在Debug中的表示"></a>标志寄存器在Debug中的表示</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406185003.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406185033.png"></p>
<h2 id="实验-11-编写子程序"><a href="#实验-11-编写子程序" class="headerlink" title="实验 11 编写子程序"></a>实验 11 编写子程序</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406200150.png"></p>
<p>我们分析一下题目，以0结尾，我们可以通过cx实现自动循环。</p>
<p>难点在于我们如何识别出是小写字符a<del>z，应该是通过ASCII（97</del>122）判断，如果ascii在这个区间，那么我们就通过and 1101 1111将第6位置零，如果不在此区间，那么直接下一个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">datasg segment</span><br><span class="line">  db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class="line">data ends</span><br><span class="line">codesg segment</span><br><span class="line">begin:mov ax,datasg</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,0</span><br><span class="line">      call letterc</span><br><span class="line"></span><br><span class="line">      mov ax,4cooh</span><br><span class="line">      int 21h</span><br><span class="line"></span><br><span class="line">letterc:</span><br><span class="line">s0   :mov cl,[si]</span><br><span class="line">      mov ch,0</span><br><span class="line">      jcxz then</span><br><span class="line">      cmp cl,97</span><br><span class="line">      jb over;如果小于97，进行下一个字符</span><br><span class="line">      cmp cl,122;如果大于122，进行下一个</span><br><span class="line">      ja over</span><br><span class="line">      and cl,11011111b;如果在区间内则</span><br><span class="line">      mov [si],cl</span><br><span class="line">over :inc si</span><br><span class="line">      jmp s0</span><br><span class="line">then :ret</span><br><span class="line">codesg ends</span><br><span class="line">end begin</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406203439.png"></p>
<p>运行完我们使用d命令进行检测，全部都是大写，成功。</p>
<h1 id="第十二章-内中断"><a href="#第十二章-内中断" class="headerlink" title="第十二章  内中断"></a>第十二章  内中断</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406212630.png"></p>
<h2 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406213552.png"></p>
<p>有四种中断源，前三个看不懂，但是最后这个int很熟悉，我们可以推测一下，int 21，21这个中断类型码代表的就是结束程序。CPU通过中断类型码来识别中断信息的来源。</p>
<h2 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407135334.png"></p>
<p>1.取得中断类型码</p>
<p>2.标志寄存器入栈</p>
<p>3.设置标志寄存器</p>
<p>4.CS的内容入栈</p>
<p>5.IP的内容入栈</p>
<p>6.读取入口地址</p>
<h2 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h2><p>中断处理程序是存储在内存某段空间之中的，因为CPU随时都可能执行中断处理程序。中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表中。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407140044.png"></p>
<p>iret指令相较于ret指令多了一步，让标志寄存器出栈</p>
<p>pop IP</p>
<p>pop CS</p>
<p>popf</p>
<h2 id="向量表"><a href="#向量表" class="headerlink" title="向量表"></a>向量表</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407181125.png"></p>
<h2 id="实验-12-编写0号中断的处理程序"><a href="#实验-12-编写0号中断的处理程序" class="headerlink" title="实验 12 编写0号中断的处理程序"></a>实验 12 编写0号中断的处理程序</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407140951.png"></p>
<p>要点：1.中断处理程序一般存储在0000：0200~0000：02ff这256个字节中。</p>
<p>​            2.显示缓冲区 以B8000开始 25x80，25行80列，一列160个字节，两个字节显示一个字</p>
<p>​            3.我们想要现实的字符串，不能刚开始就存放在data段中，因为这个程序执行完之后，它所占用的内存空间被系统释放，在其中存放的字符串很可能会被别的信息覆盖，所以我们将字符串放置在do0程序中</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">d<span class="meta">o0</span>安装程序  将d<span class="meta">o0</span>的内容放在以<span class="number">0000</span>：<span class="number">0200</span>开头的那段空间中</span><br><span class="line">设置中断向量表 将中断类型码<span class="number">0</span>对应的中断向量表改为d<span class="meta">o0</span>程序的起始地址 注意第一个字节是偏移地址，第二个字节是段地址</span><br><span class="line">d<span class="meta">o0</span>程序 实现功能</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:;do0安装程序</span><br><span class="line">      mov ax,cs    </span><br><span class="line">      mov ds,ax    ;设置ds：si指向源地址（do0）</span><br><span class="line">      mov si,offset do0;刚开始忘了设置si了，导致源地址指向了向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h  ;设置es：di指向目的地址</span><br><span class="line">      </span><br><span class="line">      mov cx,offset do0end-do0</span><br><span class="line">      cld          ;设置传输方向为正</span><br><span class="line">      rep movsb    ;逐字节传输</span><br><span class="line">      </span><br><span class="line">      ;设置中断向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[0],200h;通用的格式是[n*4]</span><br><span class="line">      mov word ptr es:[2],0</span><br><span class="line">      ;检测程序</span><br><span class="line">      mov ax,1000h</span><br><span class="line">      mov bh,1</span><br><span class="line">      div bh</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">  do0:jmp short do0start</span><br><span class="line">      db &quot;divide erro!&quot;</span><br><span class="line">do0start:</span><br><span class="line">      mov ax,cx</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,202h      ;设置es:di指向字符串，刚开始的jmp指令长度为两个字节</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,12*160+36*2 ;第十三行，第36列</span><br><span class="line">      mov cx,12       ;cx为字符串长度</span><br><span class="line">   s: mov al,[si]</span><br><span class="line">      mov es:[di],al</span><br><span class="line">      mov es:[di+1],7ch</span><br><span class="line">      inc si</span><br><span class="line">      add di,2</span><br><span class="line">      loop s</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">      </span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h1 id="第十三章-int-指令"><a href="#第十三章-int-指令" class="headerlink" title="第十三章 int 指令"></a>第十三章 int 指令</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407162603.png"></p>
<h2 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407170452.png"></p>
<h2 id="实验-13-编写、应用中断例程"><a href="#实验-13-编写、应用中断例程" class="headerlink" title="实验 13 编写、应用中断例程"></a>实验 13 编写、应用中断例程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407172949.png"></p>
<p>这一题应该可以调用int 10的9号子程序吧，搭配2号子程序设置光标，但是9号子程序的结束标志是‘$’，看来是想让我们自己实现。</p>
<p>在网上看到了一种方法，先把安装程序执行，在运行测试程序，只要不重启DOSBox，就会保存我们设置的中断例程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;编写安装程序</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,offset ins             ;设置ds:si指向源程序</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h                   ;设置es:di指向目的地址</span><br><span class="line">      mov cx，offset insends-0ffset ins      ;传输长度</span><br><span class="line">      cld                            ;正向传输</span><br><span class="line">      rep mobsb</span><br><span class="line">      ;设置中断向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[7ch*4],200h     ;两个字节存一个地址 高地址存段 低地址存偏移</span><br><span class="line">      mov word ptr es:[ych*4+2],0</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">  ins:sub dh,1;这里注意000是第一行开始，160是第2行开始</span><br><span class="line">      mov al,160</span><br><span class="line">      mul dh;存入的数据是7*160，即第八行开始</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dh,0</span><br><span class="line">      add bx,dx</span><br><span class="line">      add bx,dx;这里实现列数，注意两个字节表一个字符，所以我们加两次即加6</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov al,cl</span><br><span class="line">    s:mov cl,[si]</span><br><span class="line">      mov ch,0</span><br><span class="line">      jcxz ok;如果是结束字符0，则跳转回去</span><br><span class="line">      mov es:[bx],cl</span><br><span class="line">      mov es:[bx+1],al</span><br><span class="line">      inc si</span><br><span class="line">      add bx,2</span><br><span class="line">      jmp short s</span><br><span class="line">ok:   iret</span><br><span class="line">insends:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>这里的ins程序和我们之前做的show_str十分吻合，我们直接copy过来，不要忘记将子程序使用的寄存器入栈然后反序出栈。</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407185352.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407185417.png"></p>
<p>啊这个不就是书中的例子吗，自己尝试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;编写安装程序 照着抄即可</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,offset ins             ;设置ds:si指向源程序</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h                   ;设置es:di指向目的地址</span><br><span class="line">      mov cx,offset insends-offset ins      ;传输长度</span><br><span class="line">      cld                            ;正向传输</span><br><span class="line">      rep movsb</span><br><span class="line">      ;设置中断向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[7ch*4],200h     ;两个字节存一个地址 高地址存段 低地址存偏移</span><br><span class="line">      mov word ptr es:[7ch*4+2],0</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">  ins:push bp</span><br><span class="line">      mov bp,sp</span><br><span class="line">      dec cx</span><br><span class="line">      jcxz lpret</span><br><span class="line">      add [bp+2],bx    ;给原来的ip加上位移 </span><br><span class="line">lpret:pop bp</span><br><span class="line">      iret</span><br><span class="line">insends:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>本来ins那里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ins：</span><br><span class="line">      dec cx</span><br><span class="line">      jcxz lpret</span><br><span class="line">      add [sp],bx    ;给原来的ip加上位移 </span><br></pre></td></tr></table></figure>

<p>然后就出现了一个报错：must be index or base register 必须是索引寄存器或者base寄存器</p>
<p>也就是sp不能放在[]里单独使用，只有bx、si、di、bp （第八章）</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407193620.png"></p>
<p>看到后面的’$‘,不难看出下面将使用int 21的子程序</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407194103.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407193938.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	s1:	db &#x27;Good,better,best,&#x27;,&#x27;$&#x27;</span><br><span class="line">	s2: db &#x27;Never let it rest&#x27;,&#x27;$&#x27;</span><br><span class="line">	s3: db &#x27;Till good is better&#x27;,&#x27;$&#x27;</span><br><span class="line">	s4: db &#x27;And better,best.&#x27;,&#x27;$&#x27;</span><br><span class="line">	s : dw offset s1,offset s2,offset s3,offset s4</span><br><span class="line">	row: db 2,4,6,8</span><br><span class="line"></span><br><span class="line">strat:</span><br><span class="line">	mov ax,cs</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,offset s</span><br><span class="line">	mov si,offset row</span><br><span class="line">	mov cx,4</span><br><span class="line">ok:</span><br><span class="line">	mov bh,0</span><br><span class="line">	mov dh,ds:[si]</span><br><span class="line">	mov dl,0</span><br><span class="line">	mov ah,2</span><br><span class="line">	int 10h</span><br><span class="line"></span><br><span class="line">	mov dx,ds:[bx]</span><br><span class="line">	mov ah,9</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">	add bx,2</span><br><span class="line">	int si,2</span><br><span class="line">	loop ok</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end strat		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="第十四章-端口"><a href="#第十四章-端口" class="headerlink" title="第十四章 端口"></a>第十四章 端口</h1><h2 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h2><p>端口的读写指令只有两条，in和out，分别用于从端口读取数据和往端口写入数据</p>
<p>举个例子 （这里的in和out是针对 out就是从寄存器中出去）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dx,3f8h ;将端口号送入dx</span><br><span class="line">in  al,dx   ;从3f8h端口读入一个字节，就是将dx中的数据送入al</span><br><span class="line">out dx,al   ;向3f8h端口写入一个字节，将al中的数据写入dx</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409205632.png"></p>
<h2 id="CMOS-RAM-芯片"><a href="#CMOS-RAM-芯片" class="headerlink" title="CMOS RAM 芯片"></a>CMOS RAM 芯片</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409205749.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409205813.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,2</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h</span><br></pre></td></tr></table></figure>

<h2 id="逻辑位移指令-shl和shr"><a href="#逻辑位移指令-shl和shr" class="headerlink" title="逻辑位移指令 shl和shr"></a>逻辑位移指令 shl和shr</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409210214.png"></p>
<p>左移相当于x*2，右移相当于x&#x2F;2。</p>
<h2 id="实验-14-访问-CMOS-RAM"><a href="#实验-14-访问-CMOS-RAM" class="headerlink" title="实验 14 访问 CMOS RAM"></a>实验 14 访问 CMOS RAM</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409210618.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409210754.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">      mov cx,3</span><br><span class="line">      mov si,30</span><br><span class="line">   s: push cx</span><br><span class="line">      add cx,6</span><br><span class="line">      mov al,cl</span><br><span class="line">      out 70h,al</span><br><span class="line">      in al,71h</span><br><span class="line">      mov ah,al</span><br><span class="line">      mov cl,4</span><br><span class="line">      shr ah,cl</span><br><span class="line">      and al,00001111b</span><br><span class="line">      add ah,30h    ;以ascii表示</span><br><span class="line">      add al,30h</span><br><span class="line">      mov bx,0b800h</span><br><span class="line">      mov es,bx</span><br><span class="line">      mov bx,si</span><br><span class="line">      mov byte ptr es:[160*12+si+bx],ah</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+2],al</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+4],2fh</span><br><span class="line">      add si,3</span><br><span class="line">      pop cx</span><br><span class="line">      loop s</span><br><span class="line">      mov cx,3</span><br><span class="line">  s2: push cx</span><br><span class="line">      add cx,cx</span><br><span class="line">      sub cx,2</span><br><span class="line">      push cx</span><br><span class="line">      mov al,cl</span><br><span class="line">      out 70h,al</span><br><span class="line">      in al,71h</span><br><span class="line">      mov ah,al</span><br><span class="line">      mov cl,4</span><br><span class="line">      shr ah,cl</span><br><span class="line">      and al,00001111b</span><br><span class="line">      add ah,30h    ;以ascii表示</span><br><span class="line">      add al,30h</span><br><span class="line">      mov bx,0b800h</span><br><span class="line">      mov es,bx</span><br><span class="line">      mov bx,si</span><br><span class="line">      mov byte ptr es:[160*12+si+bx],ah</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+2],al</span><br><span class="line">      pop cx</span><br><span class="line">      jcxz ok    ;如果没有这一步的化，最后秒后面会多出一个冒号</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+4],3ah     ;冒号的ascii</span><br><span class="line">      add si,3</span><br><span class="line">      pop cx</span><br><span class="line">      loop s2 </span><br><span class="line">   ok:mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">      </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409231300.png"></p>
<h1 id="第十五章-外中断"><a href="#第十五章-外中断" class="headerlink" title="第十五章 外中断"></a>第十五章 外中断</h1><p>用两个16位寄存器来存放32位的循环次数，这里刚开始没看懂，在网上找到了一个恍然大悟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   mov ds,10h</span><br><span class="line">   mov ax,0</span><br><span class="line">s: sub ax,1    ;第一次ax=fffffh，cf=1</span><br><span class="line">   sbb dx,0    ;第一次dx=fh</span><br><span class="line">   cmp ax,0</span><br><span class="line">   jne s</span><br><span class="line">   cmp dx,0</span><br><span class="line">   jne s</span><br></pre></td></tr></table></figure>

<p>上述程序实现了循环100000次。sbb dx,0 相当于dx&#x3D;dx-0-CF,每循环（ffffh+1）即10000h次，dx减1.注意这里dx减1，发生在每10000次循环的最开始哦。</p>
<h2 id="sti和cli指令"><a href="#sti和cli指令" class="headerlink" title="sti和cli指令"></a>sti和cli指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230410205935.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230410205945.png"></p>
<p>下面的程序用于改变全屏的显示信息非常的炫酷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment </span><br><span class="line"> db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">      mov ss,ax</span><br><span class="line">      mov sp,128</span><br><span class="line">      push cs</span><br><span class="line">      pop ds</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov si,offset int9</span><br><span class="line">      mov di,204h</span><br><span class="line">      mov cx,offset int9end-offset int9</span><br><span class="line">      cld</span><br><span class="line">      rep movsb</span><br><span class="line">      push es:[9*4]</span><br><span class="line">      pop es:[200h]</span><br><span class="line">      push es:[9*4+2]</span><br><span class="line">      pop es:[202h]</span><br><span class="line">      cli</span><br><span class="line">      mov word ptr es:[9*4],204h</span><br><span class="line">      mov word ptr es:[9*4+2],0</span><br><span class="line">      sti</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">int9: push ax</span><br><span class="line">      push bx</span><br><span class="line">      push cx</span><br><span class="line">      push es</span><br><span class="line">      in al,60h               ;接收键入的字符</span><br><span class="line">      pushf</span><br><span class="line">      call dword ptr cs:[200h]</span><br><span class="line">      cmp al,3bh</span><br><span class="line">      jne int9ret</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,1</span><br><span class="line">      mov cx,2000</span><br><span class="line">  s:  inc byte ptr es:[bx]</span><br><span class="line">      add bx,2</span><br><span class="line">      loop s</span><br><span class="line">int9ret:pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br><span class="line">int9end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实验-15-安装新的int9中断例程"><a href="#实验-15-安装新的int9中断例程" class="headerlink" title="实验 15 安装新的int9中断例程"></a>实验 15 安装新的int9中断例程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230410220732.png"></p>
<p>这次实验我们只需要更改上面程序int9的部分即可，A的通码1E，断码9E</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment </span><br><span class="line"> db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">      mov ss,ax</span><br><span class="line">      mov sp,128</span><br><span class="line">      push cs</span><br><span class="line">      pop ds</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov si,offset int9</span><br><span class="line">      mov di,204h</span><br><span class="line">      mov cx,offset int9end-offset int9</span><br><span class="line">      cld</span><br><span class="line">      rep movsb</span><br><span class="line">      push es:[9*4]</span><br><span class="line">      pop es:[200h]</span><br><span class="line">      push es:[9*4+2]</span><br><span class="line">      pop es:[202h]</span><br><span class="line">      cli</span><br><span class="line">      mov word ptr es:[9*4],204h</span><br><span class="line">      mov word ptr es:[9*4+2],0</span><br><span class="line">      sti</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">int9: push ax</span><br><span class="line">      push bx</span><br><span class="line">      push cx</span><br><span class="line">      push es</span><br><span class="line">      in al,60h               ;接收键入的字符</span><br><span class="line">      pushf</span><br><span class="line">      call dword ptr cs:[200h]</span><br><span class="line">      cmp al,1eh               ;A的通码</span><br><span class="line">      je int9ret</span><br><span class="line">      cmp al,9eh</span><br><span class="line">      jne int9ret</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov cx,2000</span><br><span class="line">  s:  mov byte ptr es:[bx],65</span><br><span class="line">      add bx,2</span><br><span class="line">      loop s</span><br><span class="line">int9ret:pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br><span class="line">int9end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="第十六章-直接定址表"><a href="#第十六章-直接定址表" class="headerlink" title="第十六章 直接定址表"></a>第十六章 直接定址表</h1><h2 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230411145516.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8</span><br><span class="line">    b dw 0</span><br><span class="line">    ;这里的a其实可以理解为数组的首地址a[0]是1</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230411145837.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:db 1,2,3,4</span><br><span class="line">b:dw 0</span><br><span class="line">;这种用法是代码段中特有的    即使用  :</span><br></pre></td></tr></table></figure>

<h2 id="将标号当作数据来使用"><a href="#将标号当作数据来使用" class="headerlink" title="将标号当作数据来使用"></a>将标号当作数据来使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line"> a db 1,2,3,4,5</span><br><span class="line"> b dw 0</span><br><span class="line"> c dw a,b      ;c dd a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line"> a db 1,2,3,4,5</span><br><span class="line"> b dw 0</span><br><span class="line"> c dw offset a,offset b   ;c dw offset a,seg a,offset b,seg b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<p>seg 取段地址</p>
<h2 id="实验-16"><a href="#实验-16" class="headerlink" title="实验 16"></a>实验 16</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230411122855.png"></p>
<p>具体的功能怎么实现，书中写的很清楚，我们的任务是确定整个程序的框架。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment </span><br><span class="line">   db 64 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:;安装新的int7ch</span><br><span class="line">mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,64</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,offset int7ch</span><br><span class="line">mov si,ax</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset int7chend-offset int7ch</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[7ch*4],200h</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">int7ch:</span><br><span class="line">     jmp short set</span><br><span class="line">     table dw offset sub1-offset int7ch+200h</span><br><span class="line">           dw offset sub2-offset int7ch+200h</span><br><span class="line">           dw offset sub3-offset int7ch+200h</span><br><span class="line">           dw offset sub4-offset int7ch+200h</span><br><span class="line"> set:push bx</span><br><span class="line">     cmp ah,3</span><br><span class="line">     ja sret</span><br><span class="line">     mov bl,ah</span><br><span class="line">     mov bh,0</span><br><span class="line">     add bx,bx</span><br><span class="line">     call word ptr cs:[bx+202h] ;这里的cs是跳转到int7ch之后的cs，加202是因为前面的jmp short set占了两个字节</span><br><span class="line">sret:pop bx</span><br><span class="line">     iret</span><br><span class="line">     sub1:push bx             ;清屏</span><br><span class="line">          push cx</span><br><span class="line">          push es</span><br><span class="line">          mov bx,0b800h</span><br><span class="line">          mov es,bx</span><br><span class="line">          mov bx,0</span><br><span class="line">          mov cx,2000</span><br><span class="line">    sub1s:mov byte ptr es:[bx],&#x27; &#x27;</span><br><span class="line">          add bx,2</span><br><span class="line">          loop sub1s</span><br><span class="line">          pop es</span><br><span class="line">          pop cx</span><br><span class="line">          pop bx</span><br><span class="line">          ret</span><br><span class="line">     sub2:push bx             ;前景</span><br><span class="line">          push cx</span><br><span class="line">          push es</span><br><span class="line">          mov bx,0b800h</span><br><span class="line">          mov es,bx</span><br><span class="line">          mov bx,1</span><br><span class="line">          mov cx,2000</span><br><span class="line">    sub2s:and byte ptr es:[bx],11110000b</span><br><span class="line">          or es:[bx],al</span><br><span class="line">          add bx,2</span><br><span class="line">          loop sub2s</span><br><span class="line">          pop es</span><br><span class="line">          pop cx</span><br><span class="line">          pop bx</span><br><span class="line">          ret</span><br><span class="line">     sub3:push bx             ;背景</span><br><span class="line">          push cx</span><br><span class="line">          push es</span><br><span class="line">          mov cl,4</span><br><span class="line">          shl al,cl</span><br><span class="line">          mov bx,0b800h</span><br><span class="line">          mov es,bx</span><br><span class="line">          mov bx,1</span><br><span class="line">          mov cx,2000</span><br><span class="line">    sub3s:and byte ptr es:[bx],10001111b</span><br><span class="line">          or es:[bx],al</span><br><span class="line">          add bx,2</span><br><span class="line">          loop sub3s</span><br><span class="line">          pop es</span><br><span class="line">          pop cx</span><br><span class="line">          pop bx</span><br><span class="line">          ret</span><br><span class="line">     sub4:push cx             ;滚动</span><br><span class="line">          push si</span><br><span class="line">          push di</span><br><span class="line">          push es</span><br><span class="line">          push ds</span><br><span class="line">          mov si,0b800h</span><br><span class="line">          mov es,si</span><br><span class="line">          mov ds,si</span><br><span class="line">          mov si,160</span><br><span class="line">          mov di,0</span><br><span class="line">          cld</span><br><span class="line">          mov cx,24</span><br><span class="line">    sub4s:push cx</span><br><span class="line">          mov cx,160</span><br><span class="line">          rep movsb         ;si和di的增加在此处进行</span><br><span class="line">          pop cx</span><br><span class="line">          loop sub4s</span><br><span class="line">          mov cx,80</span><br><span class="line">          mov si,0</span><br><span class="line">   sub4s1:mov byte ptr [160*24+si],&#x27; &#x27;</span><br><span class="line">          add si,2</span><br><span class="line">          loop sub4s1</span><br><span class="line">          pop ds</span><br><span class="line">          pop es</span><br><span class="line">          pop di</span><br><span class="line">          pop si</span><br><span class="line">          pop cx</span><br><span class="line">          ret</span><br><span class="line">int7chend:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>其实我们这里使用table的方式有点麻烦</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; table dw offset sub1-offset int7ch+200h</span><br><span class="line">           dw offset sub2-offset int7ch+200h</span><br><span class="line">           dw offset sub3-offset int7ch+200h</span><br><span class="line">           dw offset sub4-offset int7ch+200h</span><br><span class="line">;call word ptr cs:[bx+202h] </span><br><span class="line">;我们把上面这些替换成下面的</span><br><span class="line">;在int7ch前面加上 org 200h 表示偏移地址从200h处开始</span><br><span class="line">  table dw sub1,sub2,sub3,sub4</span><br><span class="line">  call word ptr table[bx]</span><br></pre></td></tr></table></figure>

<p>没加那个org 200h是不行的</p>
<p>org 200H		;表示下一条地址从偏移地址200H开始，和安装后的偏移地址相同，若没有org 200H，中断例程安装后，标号代表的地址改变了，和之前编译器编译的有所区别 </p>
<p>如果我们不加上org，那么这个table的偏移地址就是本程序中的偏移地址.可是为什么sub1，这种标号还是以200h为准的偏移？应该是因为，sub1作为一个标号能正确的复制过去，table作为一个标号复制不过去，是因为table是比较抽象的？隐式的？</p>
<p>下面这张图是org 200h的，【bx+202h】</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/Untitled.png"></p>
<p>这张图是没有org的，我们可以看到下面的【bx+36h】，加的table的偏移地址</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/Untitled2.png"></p>
<h2 id="疑惑-1"><a href="#疑惑-1" class="headerlink" title="疑惑"></a>疑惑</h2><p>为什么同样是标号，table复制过去是安装程序中的地址，sub传过去的就是200h的偏移地址？？？我觉得合理的解释是这个sub1s跟着一起复制了过去，就是第二个sub1s其实是随着第一个sub1s的变化而变化的。在程序执行完之后，主程序所占的内存被其他数据覆盖，之前的sub1消失，这么理解的话，标号代表的不一定是个固定不变的地址。</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230412020235.png"></p>
<h1 id="第十七章-使用BIOS进行键盘输入和磁盘读写"><a href="#第十七章-使用BIOS进行键盘输入和磁盘读写" class="headerlink" title="第十七章 使用BIOS进行键盘输入和磁盘读写"></a>第十七章 使用BIOS进行键盘输入和磁盘读写</h1><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>破解010Editor</title>
    <url>/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/</url>
    <content><![CDATA[<p>刚开始学安全的时候，以为逆向就是软件破解hhh，学习了也有段时间了，挑个软柿子捏捏吧。</p>
<p>去官网按照自己的需求下载</p>
<span id="more"></span>![](破解010Editor/QQ截图20230730115114.png)

<p>我是win64</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730115747.png"></p>
<p>不知道什么原因哈，我这个一打开是这样的，应为是破解完才写的博客，这个是我重新下载的一个，看这个名字和密码也是我之前随便输入的，不重要，直接上ida。</p>
<p>直接字符串搜索，就搜索下面的文本就行“thank you”<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120246.png"></p>
<p>双击之后x交叉引用<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120302.png"></p>
<p>进入了流程图界面，按一下tab即可进入伪代码界面，代码不多，翻找一下即可找到<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120429.png"></p>
<p>也就是v17只要满足这个判断就说明我们成功了。什么？你问为什么？</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120606.png"></p>
<p>现在知道了吧hhh找到最近的v17点进去看看<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120710.png"></p>
<p>我们只要使这个函数的返回值等于219即可，进入之后我们可以看到很多判断和ruturn<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120814.png"></p>
<p>查看流程图更加明了一点</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121003.png"></p>
<p>直接从头开始，jz代表的是判断为0则跳转	，对应的就是这里<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121106.png"></p>
<p>最简单的就是去掉这个判断条件，直接让他return然后把return的值修改一下即可。按空格进入汇编页面，选中jz那里（要多选择一行）然后右键点击fill with nops就行啦</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121528.png"></p>
<p>修改之后整个函数就变得简单啦<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121710.png"></p>
<p>再次查看刚在那个有很多return的函数发现变成这样了<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121753.png"></p>
<p>然后我们将这个275修改成219</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121935.png"></p>
<p>就ok啦。最后edit–&gt;patch program –&gt;apply patch to input file</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730122208.png"></p>
<p>出现了一个permisson denied，拒绝访问，查了一下多是linux系统中权限的问题，好像换一个盘符也可以解决，我摸索了一下，直接将刚才下载的010Editor.exe复制到别的地方，不在原来的目录即可</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730122808.png"></p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730122841.png"></p>
<p>然后这里的地址修改一下<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730122912.png"></p>
<p>出现<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730122558.png"></p>
<p>这个就算大功告成啦</p>
<p>然后将这个更改后的程序复制到之前的目录，选择替换即可<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730123134.png"></p>
<p>点击help –&gt; about 随意输入即可</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730123059.png"></p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730123105.png"></p>
<p>其是毫无难度，应该也可以找到加密函数写注册机啥的。其实感觉这一年的学习下来，学会的最重要的技能就是使用搜索引擎了，遇到什么问题都不至于太慌乱，可以想象，要是之前的我遇到种种报错和权限问题肯定慌得不行，现在第一反应就是取edge一下，再不行就Google一下，再不行就问一下学长。加油！！！</p>
<p>参考：</p>
<p><a href="https://www.bilibili.com/read/cv12423453/">https://www.bilibili.com/read/cv12423453/</a></p>
]]></content>
  </entry>
  <entry>
    <title>编写虚拟机</title>
    <url>/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>注意，接下来要实现的虚拟机不是VMware那种有完整操作的虚拟机，而是JVM这种（解释器），更像一个翻译，可以将汇编语言转成高级语言。我们将用代码模拟计算机的硬件组件。</p>
<h2 id="虚拟机概念"><a href="#虚拟机概念" class="headerlink" title="虚拟机概念"></a>虚拟机概念</h2><p>简单来说虚拟机可以定义为一个软件程序，用来模拟一些其他物理机的功能。</p>
<span id="more"></span>

<h1 id="LC-3-架构"><a href="#LC-3-架构" class="headerlink" title="LC-3 架构"></a>LC-3 架构</h1><p>下面我们将实现LC-3虚拟机而不是x86计算机。与x56相比，LC-3 的指令集更 加简化，但现代 CPU 的主要思想其中都包括了。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>该计算机有65536（16bit）个内存空间，每个位置可以存储一个16bit的值。我们用数组来模拟内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span>  memory[UINT16_MAX];     <span class="comment">//UINT16_MAX为16bit所能表示的最大值</span></span><br></pre></td></tr></table></figure>

<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>就像cpu的工作台，cpu要对一段数据进行处理则必须要将这段数据放到寄存器中。lc-3有十个寄存器，其中八个通用寄存器，一个程序计数器寄存器，一个条件标志位寄存器。</p>
<p>通用寄存器可以执行任何程序计算。计数器寄存器存放下一条指令的地址，条件寄存器记录上一次计算的正负符号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> //10个寄存器，八个通用，一个程序计数器寄存器，一个条件寄存器</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	R_R0=<span class="number">0</span>,</span><br><span class="line">	R_R1,</span><br><span class="line">	R_R3,</span><br><span class="line">	R_R4,</span><br><span class="line">	R_R5, </span><br><span class="line">	R_R6, </span><br><span class="line">	R_R7,</span><br><span class="line">	R_PC,<span class="comment">//程序计数器寄存器，存储要执行的指令的地址</span></span><br><span class="line">	R_COND,</span><br><span class="line">	R_COUNT<span class="comment">//这个值为10，是下面reg数组的长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用数组来表示这些寄存器</span></span><br><span class="line"><span class="type">uint16_t</span> reg[R_COUNT];</span><br></pre></td></tr></table></figure>

<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>指令集是一组计算机处理器可以理解和执行的指令或操作码，机器语言则是指令的二进制形式。一条指令就是一条cpu命令，他告诉cpu执行什么任务。一条指令包括两个部分：1.操作码 2.参数</p>
<p>每个操作码（0000—1111）代表一种任务，每条指令16bit，左侧的4bit存储操作码，其余存储参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>//定义操作码   </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	OP_BR = <span class="number">0</span>,<span class="comment">//分支指令</span></span><br><span class="line">	OP_ADD,</span><br><span class="line">	OP_LD,<span class="comment">//LOAD 加载指令</span></span><br><span class="line">	OP_ST,<span class="comment">//STORE 存储指令</span></span><br><span class="line">	OP_JSR,<span class="comment">//JUMP REGISTER 寄存器跳转指令</span></span><br><span class="line">	OP_AND,<span class="comment">//BITWISE AND   按位 与</span></span><br><span class="line">	OP_LDR,<span class="comment">//LOAD REGISTER  寄存器装载指令</span></span><br><span class="line">	OP_STR,<span class="comment">//STORE REGISTER 寄存器存储指令</span></span><br><span class="line">	OP_RTI,<span class="comment">//UNUSED  未使用</span></span><br><span class="line">	OP_NOT,<span class="comment">//BITWISE NOT 按位非</span></span><br><span class="line">	OP_LDI,<span class="comment">//LOAD INDIRRCT 间接装载指令</span></span><br><span class="line">	OP_STI,<span class="comment">//STORE INDIRECT 间接存储指令</span></span><br><span class="line">	OP_JUMP,<span class="comment">//JUMP </span></span><br><span class="line">	OP_RES,<span class="comment">//RESERVED(UNUSED)</span></span><br><span class="line">	OP_LEA,<span class="comment">//LOAD EFFECTIVE ADDRESS 加载有效地址</span></span><br><span class="line">	OP_TRAP<span class="comment">//EXECUTE TRAP 执行陷阱指令</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="条件标志位"><a href="#条件标志位" class="headerlink" title="条件标志位"></a>条件标志位</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    FL_POS = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">/* P */</span>    <span class="comment">//正数  0001</span></span><br><span class="line">    FL_ZRO = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">/* Z */</span>    <span class="comment">//零    0010</span></span><br><span class="line">    FL_NEG = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">/* N */</span>    <span class="comment">//负数   0100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>硬件的模拟完成。</p>
<h1 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h1><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>从PC寄存器指向的内存地址中加载一条指令</li>
<li>递增PC寄存器（指向下一条命令）</li>
<li>查看指令的操作码，判断指令类型</li>
<li>根据指令类型和指令中的参数执行该指令</li>
<li>跳转到第一步</li>
</ol>
<p>这个过程一点也不陌生和x86机器一摸一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    &#123;Load Arguments, <span class="number">12</span>&#125;</span><br><span class="line">    &#123;Setup, <span class="number">12</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the PC to starting position */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> PC_START = <span class="number">0x3000</span> &#125;; <span class="comment">/* 0x3000 is the default */</span></span><br><span class="line">    reg[R_PC] = PC_START;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> running = <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="type">uint16_t</span> instr = mem_read(reg[R_PC]++); <span class="comment">/* FETCH */</span> <span class="comment">//步骤一、步骤二</span></span><br><span class="line">        <span class="type">uint16_t</span> op = instr &gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;      <span class="comment">//步骤三、四</span></span><br><span class="line">            <span class="keyword">case</span> OP_ADD: &#123;ADD, <span class="number">6</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_AND: &#123;AND, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_NOT: &#123;NOT, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_BR: &#123;BR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_JMP: &#123;JMP, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_JSR: &#123;JSR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LD: &#123;LD, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LDI: &#123;LDI, <span class="number">6</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LDR: &#123;LDR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LEA: &#123;LEA, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ST: &#123;ST, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_STI: &#123;STI, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_STR: &#123;STR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_TRAP: &#123;TRAP, <span class="number">8</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_RES:</span><br><span class="line">            <span class="keyword">case</span> OP_RTI:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                &#123;BAD OPCODE, <span class="number">7</span>&#125;    </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;Shutdown, <span class="number">12</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是主要框架，接下来的任务就是具体的写出每一个指令实现了什么功能。详单与我们去完善一些函数。</p>
<h1 id="指令实现"><a href="#指令实现" class="headerlink" title="指令实现"></a>指令实现</h1><p>在这里我们描述指令如何运行</p>
<h3 id="ADD指令"><a href="#ADD指令" class="headerlink" title="ADD指令"></a>ADD指令</h3><p>ADD 指令将两个数相加，然后将结果存到一个寄存器中。</p>
<p>有两种格式：ADD R2 R0 R1  ；ADD R0 R0 1 第一种是将R0+R2存储到R2,第二种是将R0+1存到R0。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230518214834.png"></p>
<p>第二种方式我们可以看出立即数只有五位，我们得把它加载到一个16bit的空间上，这就涉及到有符号扩展，这部分内容CSAPP第二章讲的很详细，对于正数我们直接给高位填充0即可，对于负数，由于是用补码表示，所以我们将高位填充1,举个例子：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"> <span class="comment">5</span><span class="literal">--</span>&gt;<span class="comment">0101</span><span class="literal">--</span>&gt;<span class="comment">0000 0101</span></span><br><span class="line"><span class="literal">-</span><span class="comment">5</span><span class="literal">--</span>&gt;<span class="comment">1011</span><span class="literal">--</span>&gt;<span class="comment">1111 1011</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">sign_extend</span><span class="params">(<span class="type">uint16_t</span> x, <span class="type">int</span> bit_count)</span> &#123;  <span class="comment">//实现有符号扩展</span></span><br><span class="line">    <span class="keyword">if</span> ((x &gt;&gt; (bit_count - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        x |= (<span class="number">0xFFFF</span> &lt;&lt; bit_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次使用ADD都会涉及到寄存器值的改变，每当改变发生我们都要更新标志寄存器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_flags</span><span class="params">(<span class="type">uint16_t</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reg[r]==<span class="number">0</span>)&#123;</span><br><span class="line">        reg[R_COND]=FL_ZRO;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (reg[r] &gt;&gt; <span class="number">15</span>) &#123; <span class="comment">//查看符号位</span></span><br><span class="line">        reg[R_COND] = FL_NEG;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reg[R_COND] = FL_POS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现ADD的逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//只看9到11位，即目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> r1=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;<span class="comment">//第一个参数 寄存器编号</span></span><br><span class="line">    <span class="type">uint16_t</span> imm_flag=(instr&gt;&gt;<span class="number">5</span>)&amp;<span class="number">1</span>;<span class="comment">//查看第五位从而确定最后一个参数是寄存器还是立即数</span></span><br><span class="line">    <span class="keyword">if</span>(imm_flag)&#123;<span class="comment">//立即数模式</span></span><br><span class="line">        <span class="type">uint16_t</span> imm5=sign_extend(instr&amp;<span class="number">0x1f</span>,<span class="number">5</span>);<span class="comment">//短于16bit的值进行符号扩展</span></span><br><span class="line">        reg[r0]=reg[r1]+imm5;    </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;       <span class="comment">//寄存器模式</span></span><br><span class="line">        <span class="type">uint16_t</span> r2=instr&amp;<span class="number">0x7</span>;</span><br><span class="line">        reg[r0]=reg[r1]+reg[r2];</span><br><span class="line">    &#125;</span><br><span class="line">    update_flags(r0);<span class="comment">//查看计算的结果并更新标志寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是完整的ADD啦，小巧而精悍。</p>
<h3 id="LDI指令"><a href="#LDI指令" class="headerlink" title="LDI指令"></a>LDI指令</h3><p>LDI 是 load indirect 的缩写，用于从内存加载一个值到寄存器。感觉和x86里面的mov与lea（load effective address)相似。 LDI 的二进制格式如下：</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519000010.png"></p>
<p>实现逻辑是这样的：0-8是内存地址，将程序计数器寄存器的值加上此值，pc自加1，自加1之后的PC就是加载地址，取出该内存单元的值，将其放入9-11位所表示的寄存器中，这个0-8，也就是能够表示一个9bit的地址，我们的内存是16位的，所以显然LDI指令只能对附近的一些内存单元进行操作，这在x86中也有体现，当时只是知道一些指令只能进行段内跳转，这还是相对跳转hhh，现在清楚了为什么是远眺转为什么是近跳转。“可以将它想想成 C 中有一个局部变 量，这变量是指向某些数据的指针”，C语言中的局部变量也是因为距离的原因不能作用于全局嘛？？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//取目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> pc_offset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);<span class="comment">//符号扩展，第一个参数是该数的位，第二个参数描述长度</span></span><br><span class="line">   reg[r0]=men_read(mem_read(reg[R_PC]+pc_offset));<span class="comment">//读取指定内存地址处的值加载入目的寄存器</span></span><br><span class="line">    update_flags(r0);<span class="comment">//更新标志寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bitwise-and-（按位与）"><a href="#Bitwise-and-（按位与）" class="headerlink" title="Bitwise and （按位与）"></a>Bitwise and （按位与）</h3><p>AND和上面的ADD一样，也有两种模式即立即模式和寄存器模式。照着葫芦画瓢就行。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519160042.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> r1=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">    <span class="type">uint16_t</span> imm_flag=(instr&gt;&gt;<span class="number">5</span>)&amp;<span class="number">0x1</span>;<span class="comment">//确定模式</span></span><br><span class="line">    <span class="keyword">if</span>(imm_flag)&#123;</span><br><span class="line">        <span class="type">uint16_t</span> imm5=sign_extend(instr&amp;<span class="number">0x1f</span>,<span class="number">5</span>);</span><br><span class="line">        reg[r0]=reg[r1]&amp;imm5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">uint16_t</span> r2=instr&amp;<span class="number">0x7</span>;</span><br><span class="line">        reg[r0]=reg[r1]&amp;reg[r2];</span><br><span class="line">    &#125;</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是把ADD代码里的+换成了&amp;这么简单。</p>
<h3 id="Bitwise-not（按位非）"><a href="#Bitwise-not（按位非）" class="headerlink" title="Bitwise not（按位非）"></a>Bitwise not（按位非）</h3><p>位上的0变1，1变0；</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519162611.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> r1=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">    reg[r0]=~reg[r1];</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Branch（条件分支）"><a href="#Branch（条件分支）" class="headerlink" title="Branch（条件分支）"></a>Branch（条件分支）</h3><p>11-9所示的三位分别代表负数、零、正数，当n被设置为1的时候，就会检测条件码寄存器的值是否为FL_NEG，如果相等则跳转，其余两位原理相同。可以进行一些组合，比如设置为011则代表如果最近一次寄存器中的值更改为0或正数都会进行跳转。特殊的，如果设置为000则不进行检测，无条件跳转。（这里为什么不设置成111，这样无论正数负数还是0都会进行跳转啊），至于如何跳转，就是进行pc&#x3D;pc+pccoffset9.那这样进行排列组合的话就有八种可能。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519163705.png"></p>
<p>我的狗屎代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> n=(instr&gt;&gt;<span class="number">11</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> z=(instr&gt;&gt;<span class="number">10</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> p=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="type">uint16_t</span> nzp=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//000 001 010 011 100 101 110 111</span></span><br><span class="line">    <span class="keyword">if</span>(nzp==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_PC]=reg[R_PC]+pc_offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nzp==<span class="number">1</span>)</span><br><span class="line">    &#123;<span class="comment">//判断是否为正数</span></span><br><span class="line">        <span class="keyword">if</span>(reg[R_COND]==FL_POS)</span><br><span class="line">        &#123;</span><br><span class="line">            reg[R_PC]=reg[R_PC]+pc_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nzp==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">////////////这样一个个的判断当然不是不行，可就是这八种情况少说也得有70行代码，我觉得应该不会如此臃肿，果然，作者的实现只用了5行代码woc</span></span><br></pre></td></tr></table></figure>

<p>作者代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="type">uint16_t</span> cond_flag=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">if</span>(cond_flag&amp;reg[R_COND])&#123;</span><br><span class="line">        reg[R_PC]+=pc_offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最精华的部分是在 if(cond_flag&amp;reg[R_COND])这里，太精华了，这样一看代码果然前面的那个无条件跳转是将nzp三位设置成111而不是000.从这一步也可以解释当时条件码为什么要用移位符号那样设置。</p>
<h3 id="Jump（跳转）"><a href="#Jump（跳转）" class="headerlink" title="Jump（跳转）"></a>Jump（跳转）</h3><p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519163639.png"></p>
<blockquote>
<p>RET 在规范中作为一个单独的指令列出，因为在汇编中它是一个独立的关键字。但是，RET 本质上是 JMP 的一个特殊情况。当 R1 为 7 时会执行 RET。</p>
</blockquote>
<p>无条件的跳转到寄存器指示的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    reg[R_PC]=reg[r0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Jump-Register（跳转寄存器）"><a href="#Jump-Register（跳转寄存器）" class="headerlink" title="Jump Register（跳转寄存器）"></a>Jump Register（跳转寄存器）</h3><p>也是两种情况。根据文章的解释将它理解为x86里的call指令应该没什么不妥，毕竟他首先将下一条指令存到了寄存器rR7中，这对应了push ip操作吧。JSR模式：将pc加上pccoffset11；JSSR模式：将pc设置为寄存器的值。一个是远眺转一个是进跳转吧。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519175718.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> imm_flag=(instr&gt;&gt;<span class="number">11</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> long_pc_offset = sign_extend(instr &amp; <span class="number">0x7ff</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="type">uint16_t</span> long_flag = (instr &gt;&gt; <span class="number">11</span>) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    reg[R_R7] = reg[R_PC];</span><br><span class="line">    <span class="keyword">if</span> (long_flag) &#123;</span><br><span class="line">        reg[R_PC] += long_pc_offset;  <span class="comment">/* JSR */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reg[R_PC] = reg[r1]; <span class="comment">/* JSRR */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;<span class="comment">//终止包含他的循环，并执行下一阶段。结束这次的switch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个最后为什么要加上个break呀，在模板里break不是统一加在了最后吗，去掉应该没啥问题。</p>
<h3 id="Load（加载）"><a href="#Load（加载）" class="headerlink" title="Load（加载）"></a>Load（加载）</h3><p>相对地址在后面的pc段，用相对寻址的方法取得目的地址存放的数据，载入目的寄存器中。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519195058.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_coffset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    reg[r0]=mem_read(reg[R_PC]+pc_coffset);</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Load-Register（加载寄存器）"><a href="#Load-Register（加载寄存器）" class="headerlink" title="Load Register（加载寄存器）"></a>Load Register（加载寄存器）</h3><p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519200825.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">    reg[r0] = mem_read(reg[r1] + offset);</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Load-Effective-Address（加载有效地址）"><a href="#Load-Effective-Address（加载有效地址）" class="headerlink" title="Load Effective Address（加载有效地址）"></a>Load Effective Address（加载有效地址）</h3><p>和load小小不同</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519200522.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_coffset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    reg[r0]=reg[R_PC]+pc_coffset;</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Store（存储）"><a href="#Store（存储）" class="headerlink" title="Store（存储）"></a>Store（存储）</h3><p>将寄存器中的值存储到我们指定的内存单元</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519201159.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">    mem_write(reg[R_PC] + pc_offset, reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Store-Indirect（间接存储）"><a href="#Store-Indirect（间接存储）" class="headerlink" title="Store Indirect（间接存储）"></a>Store Indirect（间接存储）</h3><p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519201743.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">    mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Store-Register（存储寄存器）"><a href="#Store-Register（存储寄存器）" class="headerlink" title="Store Register（存储寄存器）"></a>Store Register（存储寄存器）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">    mem_write(reg[r1] + offset, reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="涉及到的一些函数"><a href="#涉及到的一些函数" class="headerlink" title="涉及到的一些函数"></a>涉及到的一些函数</h2><h3 id="mem-read"><a href="#mem-read" class="headerlink" title="mem_read()"></a>mem_read()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == MR_KBSR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_key()) &#123;</span><br><span class="line">            memory[MR_KBSR] = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">            memory[MR_KBDR] = getchar();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memory[MR_KBSR] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mem-write"><a href="#mem-write" class="headerlink" title="mem_write()"></a>mem_write()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span> &#123;</span><br><span class="line">    memory[address] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中断陷入例程"><a href="#中断陷入例程" class="headerlink" title="中断陷入例程"></a>中断陷入例程</h2><p>这是什么，和之前接触的内中断、外中断一回事吗？</p>
<blockquote>
<p>LC-3 提供了几个预定于的函数（过程），用于执行常规任务以及与 I&#x2F;O 设备交换， 例如，用于从键盘接收输入的函数，在控制台上显示字符串的函数。这些都称为 trap routines，你可以将它们当做操作系统或者是 LC-3 的 API。 每个 trap routine 都有一个对应的 trap code（中断号）。要执行一次捕获， 需要用相应的 trap code 执行 <code>TRAP</code> 指令。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TRAP_GETC = <span class="number">0x20</span>,  <span class="comment">/* 从键盘获取字符，不在终端回显 */</span></span><br><span class="line">    TRAP_OUT = <span class="number">0x21</span>,   <span class="comment">/* 输出一个字符 */</span></span><br><span class="line">    TRAP_PUTS = <span class="number">0x22</span>,  <span class="comment">/* 输出一个字符串 */</span></span><br><span class="line">    TRAP_IN = <span class="number">0x23</span>,    <span class="comment">/* 从键盘获取字符，并在终端回显 */</span></span><br><span class="line">    TRAP_PUTSP = <span class="number">0x24</span>, <span class="comment">/* 输出一个字节字符串*/</span></span><br><span class="line">    TRAP_HALT = <span class="number">0x25</span>   <span class="comment">/* 停止程序运行 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“字节字符串”（Byte String）是由多个字节组成的序列，每个字节都有8位。字节字符串不像字符串那样直接包含可读的字符，而是用于表示各种类型的信息，如图像、声音、视频、压缩文件等。在字节字符串中，单独的字节没有特定的意义，而是需要根据上下文来解释。</p>
</blockquote>
<p>逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (instr &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> TRAP_GETC: &#123;TRAP GETC, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_OUT: &#123;TRAP OUT, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_PUTS: &#123;TRAP PUTS, <span class="number">8</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_IN: &#123;TRAP IN, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_PUTSP: &#123;TRAP PUTSP, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_HALT: &#123;TRAP HALT, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PUTS"><a href="#PUTS" class="headerlink" title="PUTS"></a>PUTS</h3><p><code>PUT</code> trap code 用于输出一个以空字符结尾的字符串（和 C 中的 <code>printf</code> 类似）显示一个字符串需要将这个字符串的地址放到 <code>R0</code> 寄存器，然后触发 trap。</p>
<p>将字符串存储到一个连续的内存区域。由于LC-3内存寻址是16位的，所以打印之前需要先将内存中的值转换为char类型再输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span>* c=memory+reg[R_R0];<span class="comment">//memory内存首地址</span></span><br><span class="line">    <span class="keyword">while</span>(*c)&#123;<span class="comment">//c语言的字符串结尾会放一个0，ASCII的0来代表结束</span></span><br><span class="line">        putc((<span class="type">char</span>)*c,<span class="built_in">stdout</span>);<span class="comment">//stdout是标准输出流，这是一个地址，类似于之前汇编接触的演示区域</span></span><br><span class="line">        ++c;<span class="comment">//自增，加载下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);<span class="comment">//该函数会将缓冲区中尚未输出的数据立即写入到文件中，并清空缓冲区。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输入单个字符（Input-Character）"><a href="#输入单个字符（Input-Character）" class="headerlink" title="输入单个字符（Input Character）"></a>输入单个字符（Input Character）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    reg[R_R0] = (<span class="type">uint16_t</span>)getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出单个字符（Output-Character）"><a href="#输出单个字符（Output-Character）" class="headerlink" title="输出单个字符（Output Character）"></a>输出单个字符（Output Character）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    putc((<span class="type">char</span>)reg[R_R0], <span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印输入单个字符提示（Prompt-for-Input-Character）"><a href="#打印输入单个字符提示（Prompt-for-Input-Character）" class="headerlink" title="打印输入单个字符提示（Prompt for Input Character）"></a>打印输入单个字符提示（Prompt for Input Character）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a character: &quot;</span>);</span><br><span class="line">    <span class="type">char</span> c = getchar();</span><br><span class="line">    putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">    reg[R_R0] = (<span class="type">uint16_t</span>)c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出字符串（Output-String）"><a href="#输出字符串（Output-String）" class="headerlink" title="输出字符串（Output String）"></a>输出字符串（Output String）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="type">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">    <span class="keyword">while</span> (*c) &#123;</span><br><span class="line">        <span class="type">char</span> char1 = (*c) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        putc(char1, <span class="built_in">stdout</span>);</span><br><span class="line">        <span class="type">char</span> char2 = (*c) &gt;&gt; <span class="number">8</span>;<span class="comment">//这里细节注意   字符mzy在内存中是 zm ’0‘y因为寻址是16位的两个字节为一组，要想正常打印我们就要将顺序颠倒一下。</span></span><br><span class="line">        <span class="keyword">if</span> (char2) putc(char2, <span class="built_in">stdout</span>);</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="暂停程序执行（Halt-Program）"><a href="#暂停程序执行（Halt-Program）" class="headerlink" title="暂停程序执行（Halt Program）"></a>暂停程序执行（Halt Program）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;HALT&quot;</span>);<span class="comment">//在终端上显示HALT</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);<span class="comment">//立即显示</span></span><br><span class="line">    running = <span class="number">0</span>;<span class="comment">//置零，用于程序的判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_image_file</span><span class="params">(FILE* file)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> origin; <span class="comment">/* the origin tells us where in memory to place the image */</span></span><br><span class="line">    fread(&amp;origin, <span class="keyword">sizeof</span>(origin), <span class="number">1</span>, file);<span class="comment">//用于打开和读取文件</span></span><br><span class="line">    origin = swap16(origin);<span class="comment">//变换字节序，将我们物理机产生的小端数据转换为LC-3的大端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we know the maximum file size so we only need one fread */</span></span><br><span class="line">    <span class="type">uint16_t</span> max_read = UINT16_MAX - origin;<span class="comment">//计算出可以读取的最大字节数</span></span><br><span class="line">    <span class="type">uint16_t</span>* p = memory + origin;<span class="comment">//指针p指向程序入口</span></span><br><span class="line">    <span class="type">size_t</span> read = fread(p, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), max_read, file);</span><br><span class="line"><span class="comment">//从输入流file中读取最多max_read个元素，并将他们存储在以p为起始地址的内存位置中，返回值是读取的元素数存储在read中。</span></span><br><span class="line">    <span class="comment">/* swap to little endian */</span></span><br><span class="line">    <span class="keyword">while</span> (read-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *p = swap16(*p);</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">swap16</span><span class="params">(<span class="type">uint16_t</span> x)</span> &#123;<span class="comment">//变换大小端</span></span><br><span class="line">    <span class="keyword">return</span> (x &lt;&lt; <span class="number">8</span>) | (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对加载程序进行封装，经过封装之后，接受一个文件路径字符串作为参数，这样更加方便。搜嘎，原来这就是封装的奥妙。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_image</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* image_path)</span> &#123;</span><br><span class="line">    FILE* file = fopen(image_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line">    read_image_file(file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存映射寄存器"><a href="#内存映射寄存器" class="headerlink" title="内存映射寄存器"></a>内存映射寄存器</h2><p>一些寄存器不能通过常规的寄存器表进行访问，而内存中储存了特殊的地址，可以通过读写相应的内存地址而达到读写这些寄存器的目的。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520004211.png"></p>
<p>是不是和端口有点关系。</p>
<ul>
<li><code>KBSR</code>：键盘状态寄存器（keyboard status register），表示是否有键按下</li>
<li><code>KBDR</code>：键盘数据寄存器（keyboard data register），表示哪个键按下了</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    MR_KBSR = <span class="number">0xFE00</span>, <span class="comment">/* keyboard status */</span></span><br><span class="line">    MR_KBDR = <span class="number">0xFE02</span>  <span class="comment">/* keyboard data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>访问方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span> &#123;</span><br><span class="line">    memory[address] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == MR_KBSR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_key()) &#123;</span><br><span class="line">            memory[MR_KBSR] = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">            memory[MR_KBDR] = getchar();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memory[MR_KBSR] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="完整的虚拟机"><a href="#完整的虚拟机" class="headerlink" title="完整的虚拟机"></a>完整的虚拟机</h1><p>运行时需要传参    .&#x2F;LC-3\ VM.exe 2048.obj 就可以玩2048了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* windows only */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span>  <span class="comment">// _kbhit</span></span></span><br><span class="line"><span class="type">uint16_t</span> memory[UINT16_MAX];<span class="comment">//每个存储单元存储一个16位的值</span></span><br><span class="line"><span class="comment">//&#123;Memory Mapped Registers&#125;</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">check_key</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MR_KBSR = <span class="number">0xFE00</span>, <span class="comment">/* keyboard status */</span></span><br><span class="line">    MR_KBDR = <span class="number">0xFE02</span>  <span class="comment">/* keyboard data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    memory[address] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == MR_KBSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_key())</span><br><span class="line">        &#123;</span><br><span class="line">            memory[MR_KBSR] = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">            memory[MR_KBDR] = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            memory[MR_KBSR] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[address];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//陷阱代码</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TRAP_GETC = <span class="number">0x20</span>,  <span class="comment">/* get character from keyboard, not echoed onto the terminal */</span></span><br><span class="line">    TRAP_OUT = <span class="number">0x21</span>,   <span class="comment">/* output a character */</span></span><br><span class="line">    TRAP_PUTS = <span class="number">0x22</span>,  <span class="comment">/* output a word string */</span></span><br><span class="line">    TRAP_IN = <span class="number">0x23</span>,    <span class="comment">/* get character from keyboard, echoed onto the terminal */</span></span><br><span class="line">    TRAP_PUTSP = <span class="number">0x24</span>, <span class="comment">/* output a byte string */</span></span><br><span class="line">    TRAP_HALT = <span class="number">0x25</span>   <span class="comment">/* halt the program */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    R_R0 = <span class="number">0</span>,</span><br><span class="line">    R_R1,</span><br><span class="line">    R_R2,</span><br><span class="line">    R_R3,</span><br><span class="line">    R_R4,</span><br><span class="line">    R_R5,</span><br><span class="line">    R_R6,</span><br><span class="line">    R_R7,</span><br><span class="line">    R_PC, <span class="comment">/* program counter */</span></span><br><span class="line">    R_COND,</span><br><span class="line">    R_COUNT</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint16_t</span> reg[R_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    OP_BR = <span class="number">0</span>, <span class="comment">/* branch */</span></span><br><span class="line">    OP_ADD,    <span class="comment">/* add  */</span></span><br><span class="line">    OP_LD,     <span class="comment">/* load */</span></span><br><span class="line">    OP_ST,     <span class="comment">/* store */</span></span><br><span class="line">    OP_JSR,    <span class="comment">/* jump register */</span></span><br><span class="line">    OP_AND,    <span class="comment">/* bitwise and */</span></span><br><span class="line">    OP_LDR,    <span class="comment">/* load register */</span></span><br><span class="line">    OP_STR,    <span class="comment">/* store register */</span></span><br><span class="line">    OP_RTI,    <span class="comment">/* unused */</span></span><br><span class="line">    OP_NOT,    <span class="comment">/* bitwise not */</span></span><br><span class="line">    OP_LDI,    <span class="comment">/* load indirect */</span></span><br><span class="line">    OP_STI,    <span class="comment">/* store indirect */</span></span><br><span class="line">    OP_JMP,    <span class="comment">/* jump */</span></span><br><span class="line">    OP_RES,    <span class="comment">/* reserved (unused) */</span></span><br><span class="line">    OP_LEA,    <span class="comment">/* load effective address */</span></span><br><span class="line">    OP_TRAP    <span class="comment">/* execute trap */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HANDLE hStdin = INVALID_HANDLE_VALUE;</span><br><span class="line">DWORD fdwMode, fdwOldMode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_input_buffering</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    hStdin = GetStdHandle(STD_INPUT_HANDLE);</span><br><span class="line">    GetConsoleMode(hStdin, &amp;fdwOldMode); <span class="comment">/* save old mode */</span></span><br><span class="line">    fdwMode = fdwOldMode</span><br><span class="line">        ^ ENABLE_ECHO_INPUT  <span class="comment">/* no input echo */</span></span><br><span class="line">        ^ ENABLE_LINE_INPUT; <span class="comment">/* return when one or</span></span><br><span class="line"><span class="comment">                                more characters are available */</span></span><br><span class="line">    SetConsoleMode(hStdin, fdwMode); <span class="comment">/* set new mode */</span></span><br><span class="line">    FlushConsoleInputBuffer(hStdin); <span class="comment">/* clear buffer */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">restore_input_buffering</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetConsoleMode(hStdin, fdwOldMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">check_key</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> WaitForSingleObject(hStdin, <span class="number">1000</span>) == WAIT_OBJECT_0 &amp;&amp; _kbhit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_interrupt</span><span class="params">(<span class="type">int</span> signal)</span></span><br><span class="line">&#123;</span><br><span class="line">    restore_input_buffering();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">sign_extend</span><span class="params">(<span class="type">uint16_t</span> x, <span class="type">int</span> bit_count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x &gt;&gt; (bit_count - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        x |= (<span class="number">0xFFFF</span> &lt;&lt; bit_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">swap16</span><span class="params">(<span class="type">uint16_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &lt;&lt; <span class="number">8</span>) | (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FL_POS = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">/* P */</span></span><br><span class="line">    FL_ZRO = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">/* Z */</span></span><br><span class="line">    FL_NEG = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">/* N */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update_flags</span><span class="params">(<span class="type">uint16_t</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (reg[r] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_ZRO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (reg[r] &gt;&gt; <span class="number">15</span>) <span class="comment">/* a 1 in the left-most bit indicates negative */</span></span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_NEG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_POS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_image_file</span><span class="params">(FILE* file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* the origin tells us where in memory to place the image */</span></span><br><span class="line">    <span class="type">uint16_t</span> origin;</span><br><span class="line">    fread(&amp;origin, <span class="keyword">sizeof</span>(origin), <span class="number">1</span>, file);</span><br><span class="line">    origin = swap16(origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we know the maximum file size so we only need one fread */</span></span><br><span class="line">    <span class="type">uint16_t</span> max_read = UINT16_MAX - origin;</span><br><span class="line">    <span class="type">uint16_t</span>* p = memory + origin;</span><br><span class="line">    <span class="type">size_t</span> read = fread(p, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), max_read, file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* swap to little endian */</span></span><br><span class="line">    <span class="keyword">while</span> (read-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = swap16(*p);</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read_image</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* image_path)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* file = fopen(image_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line">    read_image_file(file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* show usage string */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lc3 [image-file1] ...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; argc; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!read_image(argv[j]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;failed to load image: %s\n&quot;</span>, argv[j]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGINT, handle_interrupt);</span><br><span class="line">    disable_input_buffering();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* since exactly one condition flag should be set at any given time, set the Z flag */</span></span><br><span class="line">    reg[R_COND] = FL_ZRO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the PC to starting position */</span></span><br><span class="line">    <span class="comment">/* 0x3000 is the default */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> PC_START = <span class="number">0x3000</span> &#125;;</span><br><span class="line">    reg[R_PC] = PC_START;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* FETCH */</span></span><br><span class="line">        <span class="type">uint16_t</span> instr = mem_read(reg[R_PC]++);</span><br><span class="line">        <span class="type">uint16_t</span> op = instr &gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;      <span class="comment">//步骤三、四</span></span><br><span class="line">        <span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//只看9到11位，即目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;<span class="comment">//第一个参数 寄存器编号</span></span><br><span class="line">            <span class="type">uint16_t</span> imm_flag = (instr &gt;&gt; <span class="number">5</span>) &amp; <span class="number">1</span>;<span class="comment">//查看第五位从而确定最后一个参数是寄存器还是立即数</span></span><br><span class="line">            <span class="keyword">if</span> (imm_flag) &#123;<span class="comment">//立即数模式</span></span><br><span class="line">                <span class="type">uint16_t</span> imm5 = sign_extend(instr &amp; <span class="number">0x1f</span>, <span class="number">5</span>);<span class="comment">//短于16bit的值进行符号扩展</span></span><br><span class="line">                reg[r0] = reg[r1] + imm5;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;       <span class="comment">//寄存器模式</span></span><br><span class="line">                <span class="type">uint16_t</span> r2 = instr &amp; <span class="number">0x7</span>;</span><br><span class="line">                reg[r0] = reg[r1] + reg[r2];</span><br><span class="line">            &#125;</span><br><span class="line">            update_flags(r0);<span class="comment">//查看计算的结果并更新标志寄存器</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_AND: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">            <span class="type">uint16_t</span> imm_flag = (instr &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1</span>;<span class="comment">//确定模式</span></span><br><span class="line">            <span class="keyword">if</span> (imm_flag) &#123;</span><br><span class="line">                <span class="type">uint16_t</span> imm5 = sign_extend(instr &amp; <span class="number">0x1f</span>, <span class="number">5</span>);</span><br><span class="line">                reg[r0] = reg[r1] &amp; imm5;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">uint16_t</span> r2 = instr &amp; <span class="number">0x7</span>;</span><br><span class="line">                reg[r0] = reg[r1] &amp; reg[r2];</span><br><span class="line">            &#125;</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_NOT: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">            reg[r0] = ~reg[r1];</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_BR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            <span class="type">uint16_t</span> cond_flag = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="keyword">if</span> (cond_flag &amp; reg[R_COND]) &#123;</span><br><span class="line">                reg[R_PC] += pc_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_JMP: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            reg[R_PC] = reg[r0];</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_JSR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> long_pc_offset = sign_extend(instr &amp; <span class="number">0x7ff</span>, <span class="number">11</span>);</span><br><span class="line">            <span class="type">uint16_t</span> long_flag = (instr &gt;&gt; <span class="number">11</span>) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            reg[R_R7] = reg[R_PC];</span><br><span class="line">            <span class="keyword">if</span> (long_flag) &#123;</span><br><span class="line">                reg[R_PC] += long_pc_offset;  <span class="comment">/* JSR */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                reg[R_PC] = reg[r1]; <span class="comment">/* JSRR */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//终止包含他的循环，并执行下一阶段。结束这次的switch</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LD: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_coffset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            reg[r0] = mem_read(reg[R_PC] + pc_coffset);</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LDI: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//取目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);<span class="comment">//符号扩展，第一个参数是该数的位，第二个参数描述长度</span></span><br><span class="line">            reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset));<span class="comment">//读取指定内存地址处的值加载入目的寄存器</span></span><br><span class="line">            update_flags(r0);<span class="comment">//更新标志寄存器</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LDR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">            reg[r0] = mem_read(reg[r1] + offset);</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LEA: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_coffset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            reg[r0] = reg[R_PC] + pc_coffset;</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_ST: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            mem_write(reg[R_PC] + pc_offset, reg[r0]);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_STI: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_STR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">            mem_write(reg[r1] + offset, reg[r0]);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_TRAP:</span><br><span class="line">            reg[R_R7] = reg[R_PC];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (instr &amp; <span class="number">0xFF</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> TRAP_GETC:</span><br><span class="line">            &#123;</span><br><span class="line">                reg[R_R0] = (<span class="type">uint16_t</span>)getchar();</span><br><span class="line">                update_flags(R_R0); </span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_OUT:</span><br><span class="line">            &#123;</span><br><span class="line">                putc((<span class="type">char</span>)reg[R_R0], <span class="built_in">stdout</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_PUTS:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* one char per word */</span></span><br><span class="line">                <span class="type">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">                <span class="keyword">while</span> (*c)</span><br><span class="line">                &#123;</span><br><span class="line">                    putc((<span class="type">char</span>)*c, <span class="built_in">stdout</span>);</span><br><span class="line">                    ++c;</span><br><span class="line">                &#125;</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_IN:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Enter a character: &quot;</span>);</span><br><span class="line">                <span class="type">char</span> c = getchar();</span><br><span class="line">                putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">                reg[R_R0] = (<span class="type">uint16_t</span>)c;</span><br><span class="line">                update_flags(R_R0);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_PUTSP:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* one char per byte (two bytes per word)</span></span><br><span class="line"><span class="comment">                   here we need to swap back to</span></span><br><span class="line"><span class="comment">                   big endian format */</span></span><br><span class="line">                <span class="type">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">                <span class="keyword">while</span> (*c)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> char1 = (*c) &amp; <span class="number">0xFF</span>;</span><br><span class="line">                    putc(char1, <span class="built_in">stdout</span>);</span><br><span class="line">                    <span class="type">char</span> char2 = (*c) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">                    <span class="keyword">if</span> (char2) putc(char2, <span class="built_in">stdout</span>);</span><br><span class="line">                    ++c;</span><br><span class="line">                &#125;</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_HALT:</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;HALT&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_RES:</span><br><span class="line">        <span class="keyword">case</span> OP_RTI:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    restore_input_buffering();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520140311.png"></p>
<p>其实整个虚拟机跟着做完人还处于一种比较懵逼的状态，我写了个虚拟机是干啥的？？？？实操了一下，这个虚拟机和我一开始接触的VMware不一样，这更像是一个翻译机器，我们可以用lc-3的汇编语言编写程序，然后用汇编器生成二进制文件，我们编写的这个程序就可以执行这个二进制文件。比如我们编写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.ORIG X3000 ;.ORIG是伪操作符</span><br><span class="line">LEA R0,string     </span><br><span class="line">PUTS</span><br><span class="line">HALT</span><br><span class="line">string .STRINGZ &quot;Hello,word!&quot;</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>

<p>这个汇编程序可以实现将hello word打印在屏幕上。具体的实现步骤</p>
<p>1.首先在模拟器中用汇编语言编写</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520145408.png"></p>
<p>2.将其保存为.asm文件</p>
<p>3.点击asm创建.obj文件</p>
<p>然后我们就可以通过 .&#x2F;LC-3\ VM.exe hello.obj来实现</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520145639.png"></p>
<p>工作流程：</p>
<ol>
<li>读取镜像文件,加载到内存</li>
<li>PC寄存器设置为0x3000,指向第一条指令</li>
<li>重复取指-译码-执行</li>
<li>遇到HALT指令后,退出模拟,程序结束。</li>
</ol>
<p>将二进制(机器码)翻译成高级语言，我们可以再套一层虚拟机，将我们的c语言转变成这个汇编。通过这次虚拟机的实现过程，对计算机行为有了更进一步的了解。</p>
<p><a href="https://www.jmeiners.com/lc3-vm/"><a href="https://www.jmeiners.com/lc3-vm/">Write your Own Virtual Machine (jmeiners.com)</a></a></p>
]]></content>
  </entry>
  <entry>
    <title>gcc常用命令</title>
    <url>/2023/08/18/gcc%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>1.<strong>首先是最常用的，</strong>源文件生成可执行文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c</span><br></pre></td></tr></table></figure>

<p>默认生成a.out的可执行文件，main.c经历了<strong>预处理</strong>、<strong>汇编</strong>、<strong>编译</strong>、<strong>链接</strong>操作</p>
<span id="more"></span>

<p><strong>2.</strong> 指定输出文件的文件名 <strong>-o</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c -o main</span><br></pre></td></tr></table></figure>

<p>生成可执行文件main</p>
<p><strong>3.</strong> 预处理 -E</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E main.c -o main.i</span><br></pre></td></tr></table></figure>

<p>最简单的打印hello，world都要大几百行代码。预处理的作用是直接将#include&lt;xxx.h&gt;、#include”xxx.h”还有宏进行直接的复制粘贴操作.尖括号&lt;&gt;和双引号”“的区别在于，尖括号包含的头文件预处理器会直接搜索指定目录，双引号包含的头文件预处理器则优先在当前目录下查找。也就是系统的头文件我们一般都使用尖括号&lt;&gt;,自己定义的则使用双引号。gcc有选项可以更改目录，这里不再多说。</p>
<p><strong>4.</strong> 编译生成汇编代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S main.i</span><br></pre></td></tr></table></figure>

<p>生成名为main.s的文本文件，里面是汇编语言。</p>
<p><strong>5.</strong> 汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c main.s</span><br></pre></td></tr></table></figure>

<p>汇编器将汇编代码转换成目标文件main.o</p>
<p><strong>6.</strong> 链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.o -o main</span><br></pre></td></tr></table></figure>

<p>链接器将目标文件链接为可执行文件-o为优化等级，-O1、-O2、-O3，级别越大优化效果越好。</p>
<h3 id="多文件编译方法"><a href="#多文件编译方法" class="headerlink" title="多文件编译方法"></a>多文件编译方法</h3><p>对于add.h、add.c、main.c三个文件</p>
<p>add.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>

<p>add.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>,addd(a,b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.直接源码到可执行文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c add.c -o main</span><br></pre></td></tr></table></figure>

<p>生成名为main的可执行文件</p>
<p><strong>2.分别编译各个源文件，然后进行链接</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c add.c    #生成add.o</span><br><span class="line">gcc -c main.c   #生成main.o</span><br><span class="line">gcc -o add.o main.o -o main     #链接生成可执行文件</span><br></pre></td></tr></table></figure>

<p>两种方法各有优缺点，第一种简便但是需要对所有文件进行重新编译，第二种方法可以只重新编译修改的文件，而不需要浪费时间重新编译整个工程。（详情请看另一篇介绍编译与链接的文章）</p>
<p>参考文章：<a href="https://blog.csdn.net/yinjiabin/article/details/7731817">linux gcc编译多个源文件的方法_yinjiabin的博客-CSDN博客</a></p>
]]></content>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>AES算法</title>
    <url>/2023/08/18/AES%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>AES（Advanced Encryption Standard，高级加密标准），不同于RC4这种流加密算法，AES属于<strong>块加密</strong>算法，其分组长度固定为128位，仅支持128位、192位、256位的密钥长度（密钥长度每增加64位，算法的循环次数增加两轮，10、12、14），分别称为AES-128、AES-192、AES-256。AES是一种<strong>对称加密</strong>算法。</p>
<p>下面以明文和密钥都是128位来举例。</p>
<h2 id="存储形式"><a href="#存储形式" class="headerlink" title="存储形式"></a>存储形式</h2><p>16字节的明文以4*4矩阵的形式存储。按照从上至下从左至右的顺序存储。<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803174932.png"></p>
<h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><p>明文经过<strong>初始变化</strong>然后经过<strong>九轮的循环运算</strong>再经过一轮的<strong>最终轮</strong>运算即可得到密文。</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803175347.png"></p>
<p>最终轮相较于九轮循环运算少了列混合的过程，其余三个过程相同。</p>
<h3 id="初始变换（Intial-round）"><a href="#初始变换（Intial-round）" class="headerlink" title="初始变换（Intial round）"></a>初始变换（Intial round）</h3><p>明文和<strong>子密钥</strong>存储在矩阵按字节进行异或，这一过程称为初始变换</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803175921.png"></p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803180107.png"></p>
<h3 id="九轮循环运算"><a href="#九轮循环运算" class="headerlink" title="九轮循环运算"></a>九轮循环运算</h3><p>分为四个步骤<strong>字节代换</strong>、<strong>行移位</strong>、<strong>列混合</strong>、<strong>轮密钥加</strong></p>
<h4 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h4><p>简单来讲就是对初始变换后的明文进行查表替换，这个表就是S-box</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803180404.png"></p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803180620.png"></p>
<p>比如初始矩阵为</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803180742.png"></p>
<p>第一个元素19，对应S表第一行第九列的元素d4，按照此规律进行全部的替换</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803181034.png"></p>
<p>S-box不是固定不变的，也就是说S-box部分可以被魔改，但是不能随意更改，要符合S-box的设计规范。</p>
<h4 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h4><p>矩阵第一行不变，第二行左移一个字节，第三行左移两个字节，第三行左移三个字节</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803181615.png"></p>
<h4 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h4><p>将输入矩阵<strong>左乘</strong>一个给定的4*4矩阵，但是这里的矩阵相乘的<strong>加</strong>和<strong>乘</strong>的规则不同于我们在线代课上接触的。</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803181829.png"></p>
<h5 id="加和乘规则"><a href="#加和乘规则" class="headerlink" title="加和乘规则"></a>加和乘规则</h5><p>简单来讲把<strong>加</strong>替换为了<strong>异或</strong>操作<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803200828.png"></p>
<p>对于<strong>乘法</strong>，我们就将其规则记作下面的 ” · “再mod上m(x)吧！！！因为是在有限域2^8中，所以最终的结果不能存在大于等于八的次数<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803235059.png"></p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803205004.png"></p>
<p>经过列混合得到<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803205352.png"></p>
<h4 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h4><p>将得到的矩阵与<strong>子密钥矩阵</strong>进行异或 </p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803182348.png"></p>
<h3 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h3><p>上述的过程所提及的密钥都是子密钥矩阵，子密钥矩阵是初始密钥矩阵通过密钥扩展得到的，密钥矩阵经密钥扩展得到十个子密钥矩阵，运用到十次加密中（九轮循环+最终轮）<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803184432.png"></p>
<p>前四列是初始的，后面的都是计算得来的，计算时讨论下标是不是4的倍数。</p>
<p><strong>T函数</strong> ：字循环、字节代换、轮常量异或</p>
<p>字循环：将一列的四个字节循环左移一个字节如【b0,b1,b2,b3】–&gt;【b1,b2,b3,b0】</p>
<p>字节代换：查S盒进行代换</p>
<p>轮常量异或：给定10列常量。将前两步得到的结果与轮常量Rcon[j]进行异或，j表示轮数。轮常量数组中的每一个元素为一个32位的双字，且低24位恒为0.高八位（1字节）按如下规则定义：Rcon[1]&#x3D;1,Rcon[i]&#x3D;2*Rcon[i-1]<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803200147.png"></p>
<p>重复扩展过程得到全部的子密钥矩阵<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803200329.png"></p>
<h2 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h2><p>128位（16字节）一组、S-box、列混合、行移位等过程</p>
<p>可以进行<strong>魔改</strong>的部分：S-box、列混合、轮密钥加、行移位等过程的顺序可以进行调整。</p>
]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
</search>
