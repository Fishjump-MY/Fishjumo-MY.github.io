<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022极客大挑战</title>
    <url>/2022/12/21/2022%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>csapp.lab</title>
    <url>/2023/03/24/csapp-lab/</url>
    <content><![CDATA[<h1 id="1-datalab-handout"><a href="#1-datalab-handout" class="headerlink" title="1.datalab-handout"></a>1.datalab-handout</h1><h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make clean//每次更改都要重新编译</span><br><span class="line">make btest//进行测试</span><br><span class="line">./btest -g//以紧凑形式进行测试</span><br><span class="line">./dlc -e bits.c//检测是否符合编码准则</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/FlamelNW/article/details/123039299">https://blog.csdn.net/FlamelNW/article/details/123039299</a></li>
<li></li>
</ul>
<h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><p>x^y using only ~ and &amp;,用按位运算~和&amp;实现异或。</p>
<p>&amp;是1、1的时候返回1，^是0、1的时候返回1,就拿4和5举例子吧</p>
<p>4：0100  0100 1011 1010 0101 1011</p>
<p>5：0101  0100 1010 1010 0101 1011</p>
<p>x、y是未知的，所以进行~运算的时候一定是对他两个同时。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> w=<span class="number">0</span>;</span><br><span class="line">  z=x&amp;y;<span class="comment">//0100</span></span><br><span class="line">  x=~x;<span class="comment">//1011</span></span><br><span class="line">  y=~y;<span class="comment">//1010</span></span><br><span class="line">  w=x&amp;y;<span class="comment">//1010</span></span><br><span class="line">  w=~w;<span class="comment">//0101</span></span><br><span class="line">  z=~z;<span class="comment">//1011</span></span><br><span class="line">  z=z&amp;w;<span class="comment">//0001</span></span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230312010752.png"></p>
<p>成功，其实很大程度是连蒙带猜的，毕竟就这两种运算。看看大佬是怎么分析的<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230312011601.png"></p>
<p>思路：用(x&amp;y)定位出共同的1所在，用(<del>x&amp;</del>y)定位出共同的0所在，其余部位就是既有1又有0啦，然后非全0部位和非全1部位进行&amp;运算<del>(x&amp;y)&amp;</del>(<del>x&amp;</del>y)</p>
<h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>return minimum two’s complement integer，返回补码最小值。</p>
<p>对于一个正数，它的二进制形式就是它的原码，正数的原码补码反码相同。</p>
<p>对于一个负数，反码是将除符号位以外的位全部取反，补码就是将反码加上1。</p>
<p>对于-1</p>
<p>原码：1000 0001</p>
<p>反码：1111 1110</p>
<p>补码：1111 1111</p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230312202856.png"></p>
<p>补码最小值，及第32位为1，其余位为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="type">int</span> min =<span class="number">1</span>;</span><br><span class="line">   min=min&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p>returns 1 if x is the maximum, two’s complement number,and 0 otherwise，传来的参数是补码的最大值则返回1，其余情况返回0。</p>
<p>从上图我们可以看到，补码的最大值紧挨着补码的最小值，所以我们只要将最小值减1即可，可是题目不允许使用移位操作符。</p>
<p>经过很长时间的思考，发现根本表示不出最大值，参考了一下，豁然开朗，可以假设传入的参数就是就是最大值。我们可以看出最大值有一个特性，那就是max+1&#x3D;<del>(max+1),也不能完全说是特性吧，因为-1也拥有这个属性，仅此两个。首先我们可以通过max^(</del>(max+1)),如果其值返回0那我们可以锁定-1和max这两种情况,接下来我们在排除其是-1这种情况。我们只要找出-1的特性即可，(-1+1)&amp;-1&#x3D;0,其他的任何数都满足不了这一点。这种做法可以实现函数功能，却没有满足操作符的数量，使用了11个操作符，题目规定不能大于10。参考过后修改一下操作数变成9啦。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isMax</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//如果是max则返回1，其余返回0</span></span><br><span class="line">&#123; <span class="comment">//int a=((x+1)&amp;~0);//如果x等于-1则返回0，其余的所有数都是非零</span></span><br><span class="line">  <span class="type">int</span> a=x+<span class="number">1</span>;<span class="comment">//这样也能判断是否为-1</span></span><br><span class="line">  <span class="type">int</span> b=(x^(~(x+<span class="number">1</span>)));<span class="comment">//如果是max或—1则返回0，其余的会返回非0</span></span><br><span class="line">  <span class="type">int</span> c=!!(!a)^(!b);！！可以使非零值返回<span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考一下<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230313005141.png"></p>
<h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p>return 1 if all odd-numbered bits in word set to 1，如果所有的奇数位都为1则返回1，最左侧为第31位，最右侧为第0位。</p>
<p>我们可以看看奇数位为1的数有什么共同点。<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230313201116.png"></p>
<p>额，这我只能说是毫无头绪好吧。奇数位必须为1，偶数位不做要求。灵光一现：左移偶数位，得到的数一定是负数。然而并没有什么卵用。直接选择参考。data&#x3D;1010 1010(32位)，参数x^data,如果x满足要求，则返回data。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目要求可以使用的最大的数为0xff即1010 1010 我们要通过移位操作构造出32位奇数位全为1的data</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">0xAA</span>;<span class="comment">//1010 1010</span></span><br><span class="line"><span class="type">int</span> a2=a&lt;&lt;<span class="number">8</span>|a;<span class="comment">//1010 1010 x 2</span></span><br><span class="line"><span class="type">int</span> data=((a2&lt;&lt;<span class="number">16</span>)|a2);<span class="comment">//1010 1010 x 4 32位</span></span><br><span class="line"><span class="type">int</span> mid=x&amp;data;<span class="comment">//x的偶数位全部变成0，奇数位是1则1，是0则0,即如果x奇数位全部为1则返回data</span></span><br><span class="line"><span class="type">int</span> final=mid^data；<span class="comment">//如果x为符合，则mid==data，则异或结果为0</span></span><br><span class="line"><span class="keyword">return</span> !final;<span class="comment">//final为0则符合，题目让返回1    </span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>可以这么说，这题要是不看点提示，想一天也想不来。还是按位操作这里有所欠缺。</p>
<h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>return -x ，返回-x。即返回一个数的相反数</p>
<p>这题比较简单，我们直接看一个数和他的相反数在二进制形式上有什么异同点。可以看出，只要按位取反再加上1即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0000 0001   1</span></span><br><span class="line"><span class="comment">//1111 1111  -1</span></span><br><span class="line"><span class="comment">//0000 0010   2</span></span><br><span class="line"><span class="comment">//1111 1110  -2</span></span><br><span class="line"><span class="comment">//0111 1111   127</span></span><br><span class="line"><span class="comment">//1000 0001  -127</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (~x)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><p>return 1 if 0x30 &lt;&#x3D; x &lt;&#x3D; 0x39 (ASCII codes for characters ‘0’ to ‘9’)，如果传来的参数是数字则反回1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment">//0x30  0011 0000</span></span><br><span class="line"><span class="comment">//0x31  0011 0001</span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="comment">//0x39  0011 1001</span></span><br><span class="line"><span class="type">int</span> a=(x&gt;&gt;<span class="number">4</span>)^<span class="number">3</span>(<span class="number">0011b</span>);<span class="comment">//若a为0，则说明前28位相同，我们只用再判断后四位即可,若不同则返回值非零</span></span><br><span class="line"><span class="type">int</span> b=(x&gt;&gt;<span class="number">4</span>)^(x+((~<span class="number">10</span>)+<span class="number">1</span>)&gt;&gt;<span class="number">4</span>);<span class="comment">//后四位如果是0~9则返回非零，如果不是则返回0</span></span><br><span class="line"><span class="keyword">return</span> !(a|(!b));<span class="comment">//如果前28位相同，且后四位小于10则返回1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>解释一下最后一行，假设x是数字，则a&#x3D;0，b≠0，c&#x3D;!b&#x3D;0，所以a|(!b)&#x3D;0，反之a|(!b)≠0，所以在前面加上一个！。</p>
<h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p>same as x ? y : z   如果x非零则返回y如果x为零则返回z。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=!!x;<span class="comment">//如果x为零则返回0，如果x非零则返回1</span></span><br><span class="line"><span class="type">int</span> b=(~a)+<span class="number">1</span>;<span class="comment">//如果a=0则返回0(全0)，如果a＝1则返回—1(全1)</span></span><br><span class="line"><span class="keyword">return</span> ((b&amp;y)+((~b)&amp;z));<span class="comment">//如果x为零则b为零，则返回z，反之返回y</span></span><br><span class="line"><span class="comment">//最后的return 也可以写成这样：return (b&amp;y)|((~b)&amp;z)</span></span><br></pre></td></tr></table></figure>

<h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>if x &lt;&#x3D; y  then return 1, else return 0  如果x&lt;&#x3D;y,返回1，反之返回0</p>
<p>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=x+((~y)+<span class="number">1</span>);<span class="comment">//a=x-y,如果a&lt;0，则a的最高位为1，如果a&gt;=0,最高位时0，这样有点不好实现，因为小于和等于没在一起</span></span><br><span class="line"><span class="type">int</span> b=y+((~x)+<span class="number">1</span>);<span class="comment">//b=y-x,如果y&gt;=x,则b的最高位为0，反之b的最高位为1</span></span><br><span class="line"><span class="type">int</span> c=b&gt;&gt;<span class="number">31</span>;<span class="comment">//如果成立则返回全0，如果不成立则返回全1</span></span><br><span class="line"><span class="keyword">return</span> c+<span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<p>本来以为简简单单大功告成，进行测试发现没分，cao,上面的方法只适合同符号比较。   y&gt;&#x3D;x等价于y-x&gt;&#x3D;0在数学是行得通的，可是在计算机中要考虑 溢出问题。也就是可能会出现一些比较诡异的情况：</p>
<p>当y&lt;0,x&gt;0时，可能出现y-x&gt;0的情况，比如1000 0000-0000 0001<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230316233030.png"></p>
<p>可以看到，由于第一位的1变成了0，所以就变成了正数。</p>
<p>当y&gt;0,x&lt;0时，可能出现y-x&lt;0的情况，比如0000 0001-1000 0000<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230316234033.png"></p>
<p>有什么是可以肯定的呢，符号不同时，正数肯定比负数大，符号相同时看差值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我测真的烦</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> singX=(x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//如果不&amp;1，负数情况下就会返回-1</span></span><br><span class="line">    <span class="type">int</span> signY=(y&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> signY_X=((y+(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//y-x如果大于等于则返回0，小于则返回1</span></span><br><span class="line">    <span class="type">int</span> checknSign=signX^signY;<span class="comment">//相同为0，不同为1</span></span><br><span class="line">    <span class="keyword">return</span> (!checkSign&amp;!signY_X)|(checkSign&amp;signX)</span><br><span class="line">&#125;          符号相同，看差的符号         符号不同时，x&lt;<span class="number">0</span>则返回<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个return比较长，我们分开来看一下其实很简单，</p>
<p>左半部分：!checkSign&amp;!signY_X，符号相等的情况，符号相等不用考虑溢出的问题，我们可以直接根据差值的符号进行大小的判断，符号相等则check为0，signY_X如果满足则为0，否则为1，这里我们倒换一下，也就是满足时返回1，不满足时返回0，如果出现符号不相等，则左半部分返回0</p>
<p>右半部分：如果符号相同则右半部分返回0，如果符号不同，那么我们只需要看x的符号即可，如果x是负数，一定满足条件则返回他的符号1</p>
<p>反思：卡在这里很久很久，因为什么？？？一个很重要的原因对按位运算|掌握得不够熟悉，看到很多师傅的解前面有很多都使用了|，从这一题往后很难不用到|，不能再简单的使用加减。</p>
<h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p>implement the ! operator, using all of   the legal operators except !</p>
<p> Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>使用其他合规操作符实现！，也就是传入的参数为0则返回1，非零则返回0</p>
<p>思路零：未完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//0   0000 0000     0的相反数是0 相反数和自身异或取其符号位，为零则为零，非零则为1</span></span><br><span class="line"><span class="comment">//正数 0000 1110</span></span><br><span class="line"><span class="comment">//负数 1000 0100</span></span><br><span class="line"><span class="comment">//0 异或0为0</span></span><br><span class="line">   <span class="type">int</span> signX=(X&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//获取x的符号，负数则为1</span></span><br><span class="line">   <span class="type">int</span> _signX=((~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//获取-x的符号</span></span><br><span class="line">   <span class="keyword">return</span> signX^_signX^<span class="number">1</span>;</span><br><span class="line">   <span class="comment">//零异或上自己的相反数为0，其他数为1，在异或上1，改变符号</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> xor0=(<span class="number">0</span>^x)&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;x为零和正数则为<span class="number">0</span>，负数返回<span class="number">1</span></span><br><span class="line">    <span class="comment">//我们需要这样一个数，等于零时返回1，其余时候返回0 死循环</span></span><br></pre></td></tr></table></figure>

<p>运行失败，看以下错误原因</p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230323155705.png"></p>
<p>0x80000也就是最小数10000000这里出现了错误，我们知道对于有符号整型，负数范围比正数大一，所以表示不出来最小数的相反数，这个数和零一样，相反数等于自身。收到一位师傅的启发，我们可以给符号位取反，这样0x80000的符号位就变成0，不造成影响</p>
<p>思路一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> _x=~x+<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> sign=(((~x&amp;~_x))&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sign;</span><br><span class="line">   取反后非零数相反数进行&amp;运算符号位为<span class="number">0</span>，如果不进行取反操作则不能绕过<span class="number">0x8000</span>这个存在，它的相反数和自身符号相同都为<span class="number">1</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>思路二：</p>
<p>一个非零数或上自己的相反数其符号位总是1，最小值0x8000也不例外，虽然它的相反数无法表示，但其最高位都是1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sign=(x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>;如果是零则返回<span class="number">0000</span>，非零则返回<span class="number">1111</span></span><br><span class="line">    <span class="keyword">return</span> sign+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都是用到相反数，只是如果使用异或的话不可行，因为0和min的相反数最高位相同，所以只能考虑使用|或&amp;。</p>
<h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p>return the minimum number of bits required to represent x in   two’s complement    返回用二进制补码表示x的最小位数，比如1、0只用一位即可表示</p>
<p>-1也是1，因为-1的补码是1111 1111其实等价于1，补码101和1101代表的都是-3，所以-3最少需要三位，补码的最高位是符号位，就像非负数01和001、0001代表的都是1，前面有多少0都无关紧要，对于负数的补码，前面有多少个1都无关紧要，用数学来解释的话就是最高的两位之和是个定值，对于101最高两位是-2&#x3D;-2，对于1101最高两位是-4+2&#x3D;-2。</p>
<p>负数以补码的形式储存，正数的原码补码反码相同。思路：如果是整数那就检索其最高位的1的位置，如果1首先出现在了第三位，比如0101，最高位的1所在的位置就是3，那么这个数最少就可以用3+1位来表示,加的那个1是符号位。对于负数，我们检索其最高位0出现的位置，11101，0出现在第2位，那么最少可以用2+1（符号位）来表示此数，对于-1也就是全1，可以用1表示，仍然符合，也就是它的第0位是0然后我们加上1。</p>
<p>那么怎么检索呢？一个一个来肯定是不能满足操作符数量上的要求的。可以用二分法，我们处理的int是32位的，我们可以先检测它的前十六位，比如说如果全部位0，那么肯定可以用16及更少的位来表示它，再检测其余十六位的前八位，如果不全为零，那么我们继续缩小范围，检测前八位的前四位……</p>
<p>具体怎么实现还是参考的网上的，两个主要操作：计数和缩小范围</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a0,a1,a2,a4,a8,a16;</span><br><span class="line">   <span class="type">int</span> w;<span class="comment">//位数</span></span><br><span class="line">   <span class="type">int</span> sign=x&gt;&gt;<span class="number">31</span>;<span class="comment">//如果是正数返回全0，如果是负数返回全1</span></span><br><span class="line">   x=(~sign&amp;x)|(sign&amp;~x);<span class="comment">//如果是非负数则返回x，如果是负数则按位取反</span></span><br><span class="line">   a16=(!!(x&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;<span class="comment">//右移16位，两次取非，左移4；如果如果没出现1则高16位为0则返回0，如果出现1则非零则返回16</span></span><br><span class="line">   x=x&gt;&gt;a16;<span class="comment">//如果高十六位非零，右移16位；</span></span><br><span class="line">   a8=(!!(x&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;<span class="comment">//如果前十六位为0，则检测其前24位，如果无1，则返回0，如果出现1，则返回8；如果前十六位不为0，则检测32~25位，如果为0则返回0，否则返回8</span></span><br><span class="line">   x=x&gt;&gt;a8;<span class="comment">//如果a8非零则右移8位；</span></span><br><span class="line">   a4=(!!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>);<span class="comment">//如果前8位为零的话，检测其前28位；如果前8位不为为零的话，这一步检测其前四位（32~29位），如果非零则返回4，为零返回0；</span></span><br><span class="line">   x=x&gt;&gt;a4;</span><br><span class="line">   a2=!!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;<span class="comment">//如果24位为零的话，则只检测其前30位，为零则返回0，出现1则返回2；</span></span><br><span class="line">   x=x&gt;&gt;a2;<span class="comment">//如果a2非零则右移四位</span></span><br><span class="line">   a1=!!(x&gt;&gt;<span class="number">1</span>);<span class="comment">//如果前30位为零的话，则检测其前31位。</span></span><br><span class="line">   x=x&gt;&gt;a1;<span class="comment">//如果a1非零则右移两位</span></span><br><span class="line">   a0=x;<span class="comment">//如果前31位为零，那么x要么是1，要么是0</span></span><br><span class="line">   w=a0+a1+a2+a4+a8+a16+<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> w;<span class="comment">//1是符号位</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>float型 符号 阶码 尾数位分别为 1、8、23，</p>
<p>规格化的，尾数以隐含的1开头，E&#x3D;e-bias</p>
<p>非规格化的，尾数无隐含的1，E&#x3D;1-bias</p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230328115316.png"></p>
<h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><p>Return bit-level equivalent of expression 2*f for floating point argument f.将传来的参数当成float的位级表示，返回浮点数乘2的位级表示，如果是NAN和极大值(阶码全部为1)则返回0x800000(1000 0000)</p>
<p>思路：对于规格话数，乘2只需要将阶码+1，其它位保持不变</p>
<p> 非规格化的数左移一位即可得到2倍，原因见下图。参考：<a href="https://blog.csdn.net/qq_43855740/article/details/106843924">https://blog.csdn.net/qq_43855740/article/details/106843924</a></p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230328140534.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;   <span class="comment">//拿1来举例子0    0000 0000    0000 0000 0000 0000 0000 001</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> s=((uf&gt;&gt;<span class="number">31</span>)&lt;&lt;<span class="number">31</span>);<span class="comment">//符号            0    0000 0000    0000 0000 0000 0000 0000 000 </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> e=((uf&gt;&gt;<span class="number">23</span>)&lt;&lt;<span class="number">24</span>&gt;&gt;<span class="number">1</span>);<span class="comment">//获得阶码     0    0000 0000    0000 0000 0000 0000 0000 000</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> m=((uf&lt;&lt;<span class="number">9</span>)&gt;&gt;<span class="number">9</span>);<span class="comment">//获得尾数           0    0000 0000    0000 0000 0000 0000 0000 001</span></span><br><span class="line">  <span class="keyword">if</span>(e==<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> (uf&lt;&lt;<span class="number">1</span>)|s;<span class="comment">//非规格化数左移1位变为两倍，再恢复其符号位</span></span><br><span class="line">  <span class="keyword">if</span>(e==<span class="number">0x7f800000</span>)<span class="comment">//无穷大和非规格化数 无穷大的二倍还是无穷大</span></span><br><span class="line">   <span class="keyword">return</span> uf;</span><br><span class="line">  e=(((uf&gt;&gt;<span class="number">23</span>)+<span class="number">1</span>)&lt;&lt;<span class="number">24</span>&gt;&gt;<span class="number">1</span>);<span class="comment">//获得阶码+1 </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> r=s+e+m;</span><br><span class="line">  <span class="keyword">return</span> r;                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h3><p>Return bit-level equivalent of expression (int) f  for floating point argument f.将浮点型转换为位级等价整数 Anything out of range (including NaN and infinity) should return 0x80000000u.</p>
<p>取出他的符号 指数和尾数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s=uf&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;<span class="comment">//取符号</span></span><br><span class="line">     <span class="type">int</span> e=(uf&lt;&lt;<span class="number">1</span>&gt;&gt;<span class="number">24</span>)<span class="number">-127</span>;<span class="comment">//e属于(-127~126)</span></span><br><span class="line">     <span class="type">int</span> m=uf&lt;&lt;<span class="number">9</span>&gt;&gt;<span class="number">9</span>;<span class="comment">//尾数</span></span><br><span class="line">     m=m+<span class="number">0x800000</span>;</span><br><span class="line">     <span class="type">int</span> r=<span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&lt;<span class="number">0</span>)<span class="comment">//小数点左移，实际的数就是0.xxx</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&gt;<span class="number">31</span>)<span class="comment">//溢出，包括NaN</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(e&gt;<span class="number">23</span>)</span><br><span class="line">        m=(m&lt;&lt;(e<span class="number">-23</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m=(m&gt;&gt;(<span class="number">23</span>-e));</span><br><span class="line">    <span class="type">int</span> mSign=m&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s)<span class="comment">//如果传来的参数是负数，那么我们直接将得到的数取反</span></span><br><span class="line">      <span class="keyword">return</span> -m;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//传参为正数</span></span><br><span class="line">      <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h3><p>Return bit-level equivalent of the expression 2.0^x  (2.0 raised to the power x) for any 32-bit integer x.以浮点数形式返回2^x&#x3D;r</p>
<p>2的多少次方，其尾数全零，隐含1，我们只需要将e改为127+x即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> e=x+<span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&gt;=<span class="number">255</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x7F000000</span>u;<span class="comment">//返回+INF（正无穷大）</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (e&lt;&lt;<span class="number">23</span>)|<span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230328212413.png"></p>
<p>完结撒花</p>
]]></content>
      <tags>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h2 id><a href="#" class="headerlink" title></a><span id="more"></span></h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a><!--more--></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>csapp笔记</title>
    <url>/2022/12/21/csapp/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一些自己的看法和心得。</p>
<h1 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h1><p>不知道是个人的原因，还是此章节比较特殊的原因，读了一遍，感觉没有进脑子什么东西。查看了一些笔记，说是有一定的C语言基础即可阅读，而第一章更是给读者们找自信的一个章节，这使我十分的迷茫。遇到困难我们就要勇敢的面对困难，硬着头皮整理一下吧。</p>
<span id="more"></span>

<h5 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h5><p>0和1组成位，也成为比特，八个位组成一组称为字节。系统之中所有的信息都是由一串比特表示的，区分不同数据对象的唯一方法就是对照上下文。举个简单的例子，0110 0100，这么一串比特，它既能表示二进制数，又能表示ASCII对应的值d，具体表示什么要联系上下文。</p>
<h5 id="了解编译系统如何工作的益处（书上这么写的不是我总结的）"><a href="#了解编译系统如何工作的益处（书上这么写的不是我总结的）" class="headerlink" title="了解编译系统如何工作的益处（书上这么写的不是我总结的）"></a>了解编译系统如何工作的益处（书上这么写的不是我总结的）</h5><p>1.优化程序性能</p>
<p>2.理解链接时出现的错误</p>
<p>3.避免安全漏洞</p>
<h5 id="了解shell"><a href="#了解shell" class="headerlink" title="了解shell"></a>了解shell</h5><p>第一章中不停的在提及shell。shell是一个命令解释器，他输出一个提示符，等待输入一个命令符，然后执行这个命令。简单的理解一下，Windows系统中我们打开一个程序需要点击其图像，Linux则需要我们输入命令行来打开，shell就是那个供用户输入命令行的程序。shell是一个应用程序，连接了用户和linux内核。参考：(<a href="http://c.biancheng.net/view/706.html">http://c.biancheng.net/view/706.html</a>)</p>
<h5 id="系统是硬件和软件互相交织的集合体（简单介绍一下硬件）"><a href="#系统是硬件和软件互相交织的集合体（简单介绍一下硬件）" class="headerlink" title="系统是硬件和软件互相交织的集合体（简单介绍一下硬件）"></a>系统是硬件和软件互相交织的集合体（简单介绍一下硬件）</h5><h6 id="1-总线"><a href="#1-总线" class="headerlink" title="1.总线"></a>1.总线</h6><p>像神经一样，贯穿于整个系统，携带信息字节并负责在各个部门传递</p>
<h6 id="2-I-x2F-O设备"><a href="#2-I-x2F-O设备" class="headerlink" title="2.I&#x2F;O设备"></a>2.I&#x2F;O设备</h6><p>及输入&#x2F;输出设备，键盘、鼠标为输入设备，显示器和磁盘为输出设备。</p>
<h6 id="3-主存"><a href="#3-主存" class="headerlink" title="3.主存"></a>3.主存</h6><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</p>
<h6 id="4-处理器"><a href="#4-处理器" class="headerlink" title="4.处理器"></a>4.处理器</h6><p>中央处理单元（CPU），简称处理器，世界是（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该指令的地址）。</p>
<h5 id="不大不小的疑惑"><a href="#不大不小的疑惑" class="headerlink" title="不大不小的疑惑"></a>不大不小的疑惑</h5><p>此时年轻懵懂的我不明白为什么有很多很多人念着Linux系统的好，Windows这种图形化控着与此相比有什么难以弥补的劣势？据说以后工作实践中，项目大多也是基于Linux完成的，有时间了一定好好了解一下其中的内幕。</p>
<h1 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h1><h6 id="研究数字的实际表示的意义"><a href="#研究数字的实际表示的意义" class="headerlink" title="研究数字的实际表示的意义"></a>研究数字的实际表示的意义</h6><p> 能够了解可以表时得知和不同算术运算的属性。从而使程序正确工作，更具可移植性，更安全。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230224173354.png"></p>
<h6 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h6><p>大多数计算机使用8位的块（字节）作为最小的可寻址的内存单元。机器级的程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都由一个唯一的数字来标识，称为它的地址。所有可能地址的集合称为虚拟地址空间。</p>
<h6 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h6><p>二进制表示起来过用冗长，而十进制与二进制的转化很麻烦，十六进制表示起来很方便。如果二进制位数不是4的倍数，最左侧补0。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230224174927.png"></p>
<p>j代表的是16进制0的数量。前面的i是1的数量，注意只能是1,11,111,1111这四种表示。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307203238.png"></p>
<h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><h6 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h6><p>字长决定虚拟地址空间的最大大小，我们常说的32位64位都是指的字长，32位字长虚拟地址空间为2的32次方及4GB。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307204456.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307204729.png"></p>
<p>#include&lt;stdint.h&gt;中有关于int32_t等的宏定义，确定的大小可以避免很多麻烦，程序的可移植性也更高。</p>
<h6 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307205643.png"></p>
<p>可以这样说，大端是更符合我们日常思维的那一种。两种端序没有优劣之分，选择哪种字节顺序没有技术上的理由。我们只需选择一种并且始终如一地坚持。</p>
<h6 id="C语言中的逻辑运算"><a href="#C语言中的逻辑运算" class="headerlink" title="C语言中的逻辑运算"></a>C语言中的逻辑运算</h6><p>逻辑运算和按位运算有很大的不同，其一逻辑运算中所有的非零参数都表示TRUE，0参表FALSE，其二，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算就不会对第二个参数求值。</p>
<h6 id="C语言中的移位运算"><a href="#C语言中的移位运算" class="headerlink" title="C语言中的移位运算"></a>C语言中的移位运算</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307222226.png"></p>
<p>几乎所有的编译器都对有符号数使用算数右移（保留最高位），对于无符号数，右移必须是逻辑的。Java中x&gt;&gt;&gt;k是逻辑右移，x&gt;&gt;k是算数右移。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307223156.png"></p>
<h6 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h6><p>强制类型转换结果保持位不变，改变的是对位的解析方式</p>
<h6 id="有符号和无符号处理"><a href="#有符号和无符号处理" class="headerlink" title="有符号和无符号处理"></a>有符号和无符号处理</h6><p>当表达式中同时出现也有符号和无符号，那么C语言会隐式的将有符号数转换为无符号数（位不变），例如表达式-1&lt;0u返回的结果是0，也就是表达式错误，因为将-1的补码按照无符号数来解析。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230324010451.png"></p>
<p>看着好像没什么问题，但是当len等于0，在运算0-1时，计算机会当作0+(-1),因为默认是有符号，而len是无符号的。所以(-1)要从补码转换成无符号数也就是T2U，也就是UMax，所以程序会进入死循环，并且访问到a的非法元素。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230324012052.png"></p>
<p>A.当s比t短的时候会错误的返回1</p>
<p>B.两数相减得到负数会当作无符号数处理，最高位为1也就是一个很大的数大于零</p>
<p>C.改为return strlen(s)&gt;strlen(t)</p>
<h6 id="扩展一个数字的位表示"><a href="#扩展一个数字的位表示" class="headerlink" title="扩展一个数字的位表示"></a>扩展一个数字的位表示</h6><p>如果想扩展一个数字，只需要在它的最高位补上n个符号位，比如说101表示-3，在最左侧加1变为1101还是表示-3，我们可以看到它最高位与后一位的和-8+4&#x3D;-4这也是扩展前符号位的值，我们再给它扩展一位变为11101它还是表示-3，对于非负数我们只需在其前面补上0即可，正好今天在做datalab的howManyBits，和这个正好是相关的，刚开始看到网上师傅举得例子还有点懵，为啥101和1101代表的都是-3，所以我们可以知道有无数种形式的补码可以表示-3，而101是最短的一种。</p>
<h6 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h6><p>截断无符号数：</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230324001954.png"></p>
<h6 id="对于整数运算最后的思考-模运算"><a href="#对于整数运算最后的思考-模运算" class="headerlink" title="对于整数运算最后的思考 模运算"></a>对于整数运算最后的思考 模运算</h6><p>计算机执行整数运算实际上是一种模运算，什么是模运算呢？模运算也就是求余运算，在前面我们可以看到几乎所有的溢出都采取了模最高位取余数的方法。补码的表示，可以使正数加上负数的补码等于减去其原码比如</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>-<span class="number">2</span></span><br><span class="line"><span class="symbol">0000 </span><span class="number">0011</span>-<span class="number">0000</span> <span class="number">0010</span>=  <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"><span class="symbol">0000 </span><span class="number">0011</span>+<span class="number">1111</span> <span class="number">1110</span>=<span class="number">1</span> <span class="number">0000</span> <span class="number">0001</span>//最高位舍去</span><br></pre></td></tr></table></figure>

<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><h6 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h6><p>二进制小数，小数点左边是二的非负权（非负幂），小数点右边是二的负权，这一点和十进制小数并无区别。</p>
<p>二进制小数只能精确的表示形如（x*2的y次幂）的数</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327091512.png"></p>
<h6 id="IEEE浮点数表示"><a href="#IEEE浮点数表示" class="headerlink" title="IEEE浮点数表示"></a>IEEE浮点数表示</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327091842.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327092231.png"></p>
<p>正如书中提到的，浮点数看起来比较深奥难懂，但它是建立在小而一致的原则之上的。</p>
<p>根据exp的值，可以分为三种不同的情况，规格化的、非规格化的或特殊值</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327093637.png"></p>
<h6 id="规格化得值"><a href="#规格化得值" class="headerlink" title="规格化得值"></a>规格化得值</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327093742.png"></p>
<p>小数点在f段最高位的左侧，隐含的以1开头表示。</p>
<h6 id="偏置值"><a href="#偏置值" class="headerlink" title="偏置值"></a>偏置值</h6><p>这个师傅讲的比较简单明了：</p>
<p>拿单精度来说，（规格化）e的取值范围是0000 0001<del>1111 1110也就是1</del>254，肯定不能只使用无符号表示，因为这样只能表示非负数，所以使用E&#x3D;e-Bias，其范围就是-126<del>127，那么为什么不直接用补码表示e呢？这样E的范围就是1111 1111</del>0111 1111&#x3D;（-128~127），可以看出使用偏置和使用补码表示的范围相差不大，还可以不用考虑符号</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327134820.png"></p>
<h6 id="非规格化的值"><a href="#非规格化的值" class="headerlink" title="非规格化的值"></a>非规格化的值</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327094556.png"></p>
<h6 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327095039.png"></p>
<h6 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h6><p>浮点数浮点数采用向偶数最接近的偶数舍入的方法，这样对与那些处在中间的数在50%的时间里会向上舍入(1.5—&gt;2)，在另外的50%的时间会向下舍入(2.5—&gt;2)。</p>
<h6 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327210735.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327210747.png"></p>
<p>下面是对3丢失的解释，所以说浮点数计算不符合结合律</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">对于float</span> <span class="string">符号位</span> <span class="string">阶码</span> <span class="string">尾数分别为</span> <span class="number">1</span> <span class="number">8</span> <span class="number">23</span></span><br><span class="line"><span class="number">1e10</span> <span class="string">=</span> <span class="number">0010 </span><span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">010</span><span class="string">（0</span> <span class="number">0000 </span><span class="number">0000</span><span class="string">）</span></span><br><span class="line">     <span class="string">=1.0</span> <span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">0000 </span><span class="string">X</span> <span class="number">2</span><span class="string">^33</span></span><br><span class="line"><span class="string">表示成浮点数</span>   <span class="string">bias=127</span> <span class="string">所以E=127+33=160=1010</span> <span class="number">0000</span></span><br><span class="line"><span class="number">1e10</span></span><br><span class="line"><span class="string">浮点数：0</span> <span class="number">1010 </span><span class="number">0000 </span><span class="number">0010 </span><span class="number">1010 </span><span class="number">0000 </span><span class="number">0101 </span><span class="number">1111 </span><span class="number">0010</span> </span><br><span class="line"><span class="number">1e10</span><span class="string">+3=</span> <span class="number">0010 </span><span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">010</span><span class="string">（0</span> <span class="number">0000 </span><span class="number">0011</span><span class="string">）</span></span><br><span class="line">      <span class="string">=1.0</span> <span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">0011 </span><span class="string">X</span> <span class="number">2</span><span class="string">^33</span></span><br><span class="line"><span class="string">浮点数</span> <span class="string">=0</span> <span class="number">1010 </span><span class="number">0000 </span><span class="number">0010 </span><span class="number">1010 </span><span class="number">0000 </span><span class="number">0101 </span><span class="number">1111 </span><span class="number">0010</span></span><br><span class="line"><span class="string">可以看出后面括号里的的3=0</span> <span class="number">0000 </span><span class="number">0011</span><span class="string">直接被舍掉了</span></span><br></pre></td></tr></table></figure>

<h1 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章  程序的机器级表示"></a>第三章  程序的机器级表示</h1><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>从十六位过渡到64位不显得突兀，在指令后面加了字符后缀，确定大小<img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405114357.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405114424.png"></p>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405120704.png"></p>
<h2 id="ATT和Intel"><a href="#ATT和Intel" class="headerlink" title="ATT和Intel"></a>ATT和Intel</h2><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405122311.png"></p>
<p>之前接触的是intel的导致我以为这里出现了错误</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>更新一点对栈的认知，之前一直以为将栈顶的值pop之后，内存中的值会消失，原来值会一直存在，直到被覆盖。</p>
<h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><h3 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作"></a>算术操作</h3><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405214930.png"></p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405220431.png"></p>
<h2 id="函数传参和寄存器的关系"><a href="#函数传参和寄存器的关系" class="headerlink" title="函数传参和寄存器的关系"></a>函数传参和寄存器的关系</h2><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230406093404.png"></p>
<p>是按照这个顺序进行传参，并且返回值默认是ax。</p>
]]></content>
      <tags>
        <tag>阅读</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言</title>
    <url>/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>​       </p>
<h1 id="debug中的常用命令"><a href="#debug中的常用命令" class="headerlink" title="debug中的常用命令"></a>debug中的常用命令</h1><ul>
<li><p>g 加地址，直接跳转至此处，前面全部执行 </p>
</li>
<li><p>u 将内存中的机器指令翻译成汇编指令</p>
</li>
<li><p>t 执行一条指令</p>
<span id="more"></span>
</li>
<li><p>r 查看寄存器中的值，同时显示出下一条要执行的指令，还可以改变寄存器中的内容，比如r ax，然后弹出冒号，输入即可</p>
</li>
<li><p>d 查看内存中的内容，d 段地址：偏移地址 (可以在此处加上想查看的范围，默认是128字节)，之后再按d显示后续内容</p>
</li>
<li><p>p 可以跳过loop循环</p>
</li>
<li><p>e 向内存单元写入命令，e 段地址:偏移地址 B8 01 00,即向该内存写入mov ax,1命令</p>
</li>
</ul>
<h1 id="第7章-更灵活的定位内存地址的方法"><a href="#第7章-更灵活的定位内存地址的方法" class="headerlink" title="第7章 更灵活的定位内存地址的方法"></a>第7章 更灵活的定位内存地址的方法</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230313180808.png"></p>
<p>话不多说，直接上图，完成了任务。只不过忘掉了如何一次性执行完循环，一直t加回车，头皮发麻。这一题是让我们补充codesg段的代码，我们要灵活的利用栈来存储和释放cx</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230313181241.png"></p>
<p>s0处的push cx是将外层循环的cx值压入栈中，然后往下执行，mov cx,4设置内层循环次数，执行完4次s1后，此时的cx值为零，将之前cx的值弹出栈，恢复为3(即4-1)，然后往复执行。</p>
<h5 id="tips-快速结束循环"><a href="#tips-快速结束循环" class="headerlink" title="tips 快速结束循环"></a>tips 快速结束循环</h5><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230313182253.png"></p>
<p>再补充一个快速的指令 g 偏移地址，例如g 0012执行后，ip&#x3D;0012，从此处开始往下执行。</p>
<h1 id="第8章-数据处理的两个基本问题"><a href="#第8章-数据处理的两个基本问题" class="headerlink" title="第8章 数据处理的两个基本问题"></a>第8章 数据处理的两个基本问题</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230315004402.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230315004456.png"></p>
<p>只有上述形式是是正确的，有个小要点，[bp]默认的段地址是ss。</p>
<h5 id="指令要处理的数据有多长"><a href="#指令要处理的数据有多长" class="headerlink" title="指令要处理的数据有多长"></a>指令要处理的数据有多长</h5><p>这是我们必须指出的，可以显性地指出也可以隐形的指出，比如在有寄存器名称的情况下我们可以判断出访问的是字单元还是字节单元，在没有寄存器参与的情况下用操作符X ptr指明长度。X为byte或word。对于push [1000]这样的指令则无需指明，因为push指令只进行字操作。</p>
<h3 id="实验-7"><a href="#实验-7" class="headerlink" title="实验 7"></a>实验 7</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322200528.png"></p>
<p>废了九牛二虎之力终于用比较朴素的方法实现了。遇到了不少问题，其中最主要的两个是：</p>
<ol>
<li>error A2052: Improper operand type</li>
<li>g命令之后卡死</li>
</ol>
<p>第一个在经过Google之后找到了解答<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322202425.png"></p>
<p>我记得这一点书上好像提到过，给忘掉了，真是一头雾水</p>
<p>第二个问题，算是摸索着解开了疑惑，网上说有三种情况，1.代码段没加mov ax,4c00h 2.重启解决 3.代码导致g命令出错</p>
<p>我的情况应该是属于第三种，因为我按自己的想法写的时候，寻址方式比较奇怪。比如说我成功之前的那一次</p>
<h5 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div word ptr [bx].0Ah//g命令后卡死，虽然这两处的值不相同，但按道理来说结果会出错，不应该出现程序卡死，此处存有疑惑</span><br><span class="line">div word ptr [bx+0ah]//也不可行</span><br><span class="line">div word ptr es:[bx+0ah]//成功，上边的错误在于忘记了要标明es段，可是有一点存疑，就算用的是ds段地址，那同样也能读取数据，为什么会卡死呢？？？？？</span><br><span class="line">div word ptr [168+si]//正确</span><br></pre></td></tr></table></figure>

<h5 id="寻址方式小结"><a href="#寻址方式小结" class="headerlink" title="寻址方式小结"></a>寻址方式小结</h5><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322203639.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg                        //写的比较朴实，可能有较多重复的步骤，也可以一次循环填充一行中的所有信息，然后循环</span><br><span class="line">data segment                            //21次即可</span><br><span class="line">db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;</span><br><span class="line">db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line"></span><br><span class="line">dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">dd 345980,590827,803530,1183000,1843000,2759000,375000,4649000,5937000</span><br><span class="line"></span><br><span class="line">dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">dw 11542,14430,15257,17800</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line">table segment</span><br><span class="line">db 21 dup(&#x27;year sumn ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line">codesg segment</span><br><span class="line">   start:mov ax,data</span><br><span class="line">         mov ds,ax</span><br><span class="line">         mov ax,table</span><br><span class="line">         mov es,ax</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s0: mov ax,[si]                       </span><br><span class="line">         mov es:[bx],ax</span><br><span class="line">         add si,2</span><br><span class="line">         mov ax,[si]</span><br><span class="line">         mov es:[bx+2],ax</span><br><span class="line">         add si,2</span><br><span class="line">         add bx,16                                </span><br><span class="line">         loop s0</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s1: mov ax,[84+si]                          </span><br><span class="line">         mov es:[bx+5],ax              </span><br><span class="line">         add si,2</span><br><span class="line">         mov ax,[84+si]</span><br><span class="line">         mov es:[bx+5+2],ax</span><br><span class="line">         add si,2</span><br><span class="line">         add bx,16                             </span><br><span class="line">         loop s1</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s2: mov ax,[168+si]                         </span><br><span class="line">         mov es:[bx+0Ah],ax</span><br><span class="line">         add bx,16</span><br><span class="line">         add si,2</span><br><span class="line">         loop s2</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s3: mov ax,es:[bx+5]</span><br><span class="line">         mov dx,es:[bx+5+2]</span><br><span class="line">         div word ptr [168+si]</span><br><span class="line">         mov es:[bx+0Dh],ax</span><br><span class="line">         add si,2</span><br><span class="line">         add bx,16</span><br><span class="line">         loop s3</span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start      </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这次的实验知识发现了不少短板，hhh或者说全是短板哈哈哈哈，很多基础的东西打的不是很牢固，比如说高低字节，高低位</p>
<h5 id="高低字节，高低位"><a href="#高低字节，高低位" class="headerlink" title="高低字节，高低位"></a>高低字节，高低位</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">对于 <span class="number">1234</span>h这个十六进制数来说，其高字节是<span class="number">12</span>，低字节是<span class="number">34</span></span><br><span class="line">我们平时接触小端序比较多，那么高字节<span class="number">12</span>存放在高地址单元中，低字节<span class="number">34</span>存放在低地址单元中</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322204849.png"></p>
<p>如果我们进行div word ptr ds:0操作，那么处理的也就是0、1这两个内存单元组成的数1234h。</p>
<h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><h2 id="操作符offeset"><a href="#操作符offeset" class="headerlink" title="操作符offeset"></a>操作符offeset</h2><p>offeset在汇编语言中是由编译器处理的符号，它的功能是取得标号处的偏移地址<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330172558.png"></p>
<h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><h3 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h3><p>CPU在执行jmp指令的时候不需要转移的目的地址，需要的是位移量。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173053.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173151.png"></p>
<h4 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h4><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173536.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173606.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173835.png"></p>
<p>可以看到，这里是通过目的地址而非位移量进行转移的</p>
<h4 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h4><p>jmp word ptr 内存单元地址（段内转移）</p>
<p>jmp dword ptr 内存段地址（段间转移）</p>
<p>对于段间转移 （CS）&#x3D;（内存单元地址+2），</p>
<p>​                        （IP） &#x3D;（内存单元地址）</p>
<h3 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h3><p>有条件的段间转移，有条件转移都是段间的，在对应的机器码中包含位移而不是地址。当cx&#x3D;&#x3D;0的时候执行跳转，cx!&#x3D;0时直接执行下一条语句<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330175241.png"></p>
<h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><p>循环指令都是段指令，对应的机器码中包含位移地址而不是目的地址<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330175446.png"></p>
<h2 id="实验八-分析一个奇怪的程序"><a href="#实验八-分析一个奇怪的程序" class="headerlink" title="实验八 分析一个奇怪的程序"></a>实验八 分析一个奇怪的程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">start:</span><br><span class="line">       mov ax,0</span><br><span class="line">s:     nop</span><br><span class="line">       nop</span><br><span class="line">       mov di,offset s</span><br><span class="line">       mov si,offset s2</span><br><span class="line">       mov ax,cs:[si]</span><br><span class="line">       mov cs:[di],ax</span><br><span class="line">s0: jmp short s</span><br><span class="line">s1: mov ax,0</span><br><span class="line">       int 21h</span><br><span class="line">       mov ax,0</span><br><span class="line">s2: jmp short s1</span><br><span class="line">       nop</span><br><span class="line">codesg ends</span><br><span class="line">       end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然看着是挺奇怪的，s的操作就是使s处的命令变为s2处的命令，即跳转到s1，很显然mov ax,0这里不满足让程序正确返回，用debug的t命令进行调试，可以成功运行，我们知道jup命令是不带有目标位置的地址的，它含有一个偏移地址，s2处的jump short s1的机器码是EB F6,F6就是偏移地址1111 0110补码表示-10，-10含义是标号处的地址-jmp指令后的第一个字节的地址，也就是从mov di,offset s位置前移十个字节，正好到达mov ax,4c00h int 21h，程序得以成功返回</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330172008.png"></p>
<h2 id="实验九"><a href="#实验九" class="headerlink" title="实验九"></a>实验九</h2><p>将’welcome to masm!’正好16个字符，填入第11、12、13行</p>
<p>绿色属性 0 000 0 010B                 02h</p>
<p>绿底红字属性  0 010 0 100B         24h</p>
<p>白底蓝色属性 0 111 0 001B          71h</p>
<p>经过不懈的努力终于是搞好了，困住我的主要有两点，其一是对字，字节，寄存器不敏感，对于传输字和字节有点生疏。其二就是让我崩溃的东西，题目要求是打印在中间，我一想80个字符位，左边空出32，右边空出32中间正好留下16，然后左边的32x2&#x3D;64，有因为是从零开始，所以这边我们第一个填充的位置就是64呀，当成了63操作，结果是真抽象，还好最后一试，将welcome全部改成了11111，打印出来发现全部是同一个颜色的符号，也就是说我的颜色就然和字符与关，果断想到填充错了位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg,ds:data</span><br><span class="line">data segment</span><br><span class="line">  db &#x27;welcome to masm!&#x27;</span><br><span class="line">data ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov di,0</span><br><span class="line">      mov cx,16</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov ax,0B800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov si,06e0h</span><br><span class="line">      mov ah,02h</span><br><span class="line">   s0:mov al,ds:[di]</span><br><span class="line">      mov es:[bx+si+64],al</span><br><span class="line">      mov es:[bx+si+65],ah</span><br><span class="line">      add bx,2</span><br><span class="line">      add di,1</span><br><span class="line">      loop s0</span><br><span class="line">      mov ax,0B800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,0</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov si,780h</span><br><span class="line">      mov cx,16</span><br><span class="line">   s1:mov al,ds:[di]</span><br><span class="line">      mov es:[bx+si+64],al</span><br><span class="line">      mov al,24h</span><br><span class="line">      mov es:[bx+si+65],al</span><br><span class="line">      add bx,2</span><br><span class="line">      inc di</span><br><span class="line">      loop s1</span><br><span class="line">      mov ax,0B800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov di,0</span><br><span class="line">      mov si,820h</span><br><span class="line">      mov cx,16</span><br><span class="line">   s2:mov al,ds:[di]</span><br><span class="line">      mov es:[bx+si+64],al</span><br><span class="line">      mov al,71h</span><br><span class="line">      mov es:[bx+si+65],al</span><br><span class="line">      add bx,2</span><br><span class="line">      inc di</span><br><span class="line">      loop s2</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230331013823.png"></p>
<h1 id="第十章-CALL指令和RET指令"><a href="#第十章-CALL指令和RET指令" class="headerlink" title="第十章 CALL指令和RET指令"></a>第十章 CALL指令和RET指令</h1><h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><p>ret指令只修改ip的内容，实现近迁移，retf应该就是ret far的意思，同时修改cs和ip中的内容，实现远迁移。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032439.png"></p>
<p>用汇编语言解释</p>
<p>ret：POP IP</p>
<p>retf：POP IP ,POP CS</p>
<h2 id="CALL指令"><a href="#CALL指令" class="headerlink" title="CALL指令"></a>CALL指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032635.png"></p>
<h3 id="依据位迁移进行转移的call指令"><a href="#依据位迁移进行转移的call指令" class="headerlink" title="依据位迁移进行转移的call指令"></a>依据位迁移进行转移的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032834.png"></p>
<p>下面程序执行后，ax的值</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032932.png"></p>
<p>读取过call s指令后，ip中的值自动增加（第二章 28页），变为6，call指令相当于push ip，s处是pop ax，所以ax的值为6。</p>
<h3 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402033501.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402034116.png"></p>
<h3 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402034837.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402034852.png"></p>
<p>bp的默认段地址是ss</p>
<h3 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402035632.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402040248.png"></p>
<p>回顾一下jump dword ptr 内存单元地址 </p>
<p>CS&#x3D;（内存单元地址+2）</p>
<p>IP&#x3D;（内存单元地址）</p>
<h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230403170535.png"></p>
<h2 id="实验-10-编写子程序"><a href="#实验-10-编写子程序" class="headerlink" title="实验 10 编写子程序"></a>实验 10 编写子程序</h2><p>1.显示字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line">data segment</span><br><span class="line">db&#x27;welcome to masm!&#x27;,0</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">db 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov dh,8 ;传参 8行 3列 绿色</span><br><span class="line">      mov dl,3</span><br><span class="line">      mov cl,2</span><br><span class="line">      mov ax,data</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,0</span><br><span class="line">      call show_str</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">show_str:</span><br><span class="line">      sub dh,1;这里注意000是第一行开始，160是第2行开始</span><br><span class="line">      mov al,160</span><br><span class="line">      mul dh;存入的数据是7*160，即第八行开始</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dh,0</span><br><span class="line">      add bx,dx</span><br><span class="line">      add bx,dx;这里实现列数，注意两个字节表一个字符，所以我们加两次即加6</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov al,cl</span><br><span class="line">    s:mov cl,[si]</span><br><span class="line">      mov ch,0</span><br><span class="line">      jcxz ok;如果是结束字符0，则跳转回去</span><br><span class="line">      mov es:[bx],cl</span><br><span class="line">      mov es:[bx+1],al</span><br><span class="line">      inc si</span><br><span class="line">      add bx,2</span><br><span class="line">      jmp short s</span><br><span class="line">      </span><br><span class="line">ok:   ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>由于粗心出现了一个警告 missing data：zero assume，提醒我们缺少操作数</p>
<p>把add bx,dx写成了add bx,dx</p>
<p>2.解决除法的溢出问题</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230404195800.png"></p>
<p>给出了一个提示</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230404195943.png"></p>
<p>65536是十六进制的1 0000也就是将得到的数左移四个16进制位呗，我们可以直接把int(H&#x2F;N)的内容直接放入dx中，然后把后面的整体装入ax中，把后面整体产生的余数装入cx中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line">stack segment</span><br><span class="line">dw 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">      mov ss,ax</span><br><span class="line">      mov sp,10h</span><br><span class="line">      mov ax,4240h</span><br><span class="line">      mov dx,000fh</span><br><span class="line">      mov cx,0ah</span><br><span class="line">      call divdw</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">divdw:push ax</span><br><span class="line">      push dx</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dx,0</span><br><span class="line">      pop ax</span><br><span class="line">      div cx</span><br><span class="line">      push ax;商</span><br><span class="line">      push dx;余</span><br><span class="line">      mov ax,bx</span><br><span class="line">      div cx</span><br><span class="line">      mov cx,dx</span><br><span class="line">      pop dx</span><br><span class="line">      pop dx</span><br><span class="line">      pop si;它存在的意义是把栈清理到只剩一个，以便使下面的ret成功返回</span><br><span class="line">      ret    ;前面哪些部分其实可以不使用栈，此题占用的寄存器不多</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230404221743.png"></p>
<p>3.数值显示将二进制转化为十进制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line"> db 10 dup (10)</span><br><span class="line"> data ends</span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">start:mov ax,12666</span><br><span class="line">      mov bx,data</span><br><span class="line">      mov ds,bx</span><br><span class="line">      mov si,0</span><br><span class="line">      call dtoc</span><br><span class="line"></span><br><span class="line">      mov dh,8</span><br><span class="line">      mov dl,3</span><br><span class="line">      mov cl,2</span><br><span class="line">      call show_str</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line"> </span><br><span class="line"> dtoc:mov dx,0</span><br><span class="line">      mov bx,10</span><br><span class="line">      div bx;余数在dx，商在ax</span><br><span class="line">      mov cx,ax</span><br><span class="line">      add dx,30h</span><br><span class="line">      mov [si],dl;存放余数的ascii</span><br><span class="line">      inc si;表示位数</span><br><span class="line">      jcxz short s1</span><br><span class="line">      jmp short dtoc</span><br><span class="line">   s1:ret</span><br><span class="line">show_str:</span><br><span class="line">      sub dh,1</span><br><span class="line">      mov al,160</span><br><span class="line">      mul dh</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dh,0</span><br><span class="line">      add bx,dx</span><br><span class="line">      add bx,dx</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov al,cl</span><br><span class="line">    s:mov cl,[-1+si];66621</span><br><span class="line">      mov ch,0</span><br><span class="line">      ;jcxz ok 如果不注释掉的话，以零结尾的数将无法显示</span><br><span class="line">      mov es:[bx],cl</span><br><span class="line">      mov es:[bx+1],al</span><br><span class="line">      sub si,1</span><br><span class="line">      mov cx,si</span><br><span class="line">      jcxz short ok</span><br><span class="line">      add bx,2</span><br><span class="line">      jmp short s</span><br><span class="line">ok:   ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>感谢这位博主：<a href="https://blog.csdn.net/qq_60829702/article/details/123582250">https://blog.csdn.net/qq_60829702/article/details/123582250</a></p>
<h1 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406121332.png"></p>
<h2 id="ZF-标志"><a href="#ZF-标志" class="headerlink" title="ZF 标志"></a>ZF 标志</h2><p>记录相关指令执行后结果是否为零，如果为零则ZF为1，如果非零则ZF为0。</p>
<h2 id="PF-标志"><a href="#PF-标志" class="headerlink" title="PF 标志"></a>PF 标志</h2><p>记录执行相关指令后，结果的所有bit位1的个数是否为偶数，如果1的数量是偶数，则PF为1.</p>
<h2 id="SF-标志"><a href="#SF-标志" class="headerlink" title="SF 标志"></a>SF 标志</h2><p>记录执行相关指令后，结果是否为负，如果结果为负，则SF为1.</p>
<h2 id="CF-标志"><a href="#CF-标志" class="headerlink" title="CF 标志"></a>CF 标志</h2><p>在进行无符号运算时，它记录进位和借位情况</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406122332.png"></p>
<p>进位比较好理解，下面看一下借位</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406122516.png"></p>
<h2 id="OF-标志"><a href="#OF-标志" class="headerlink" title="OF 标志"></a>OF 标志</h2><p>进行有符号运算是否发生溢出，如果溢出则OF为1.<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406123023.png"></p>
<h2 id="adc-指令"><a href="#adc-指令" class="headerlink" title="adc 指令"></a>adc 指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406123128.png"></p>
<p>这个指令乍一看很奇怪，很多余，为什么要加上一个cf？但是看了下面的解释之后，我直呼巧妙</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406123359.png"></p>
<p>adc也会对CF位进行设置，由于这样的功能，我们可以对任意大的数据进行加法运算。</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406124107.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406124125.png"></p>
<h2 id="sbb-指令"><a href="#sbb-指令" class="headerlink" title="sbb 指令"></a>sbb 指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406133522.png"></p>
<h2 id="cmp-指令"><a href="#cmp-指令" class="headerlink" title="cmp 指令"></a>cmp 指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406134232.png"></p>
<p>可以通过标志寄存器中的值得出比较结果<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406134301.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406171440.png"></p>
<p>这里有点疑惑的，为什么实际结果为负，且发生了溢出，就可以推出实际结果为正。溢出，有正溢出和负溢出。正溢出就是两个正数相加，超过了能表示的最大范围，变为负数，负溢出就是两个负数相加，超出了能表示的最小范围，变为正数。举个例子：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">拿四位有符号数来举例</span><br><span class="line"><span class="attribute">MAX</span>==0111==7</span><br><span class="line"><span class="attribute">MIN</span>==1000==-8</span><br><span class="line">正溢出0111+<span class="attribute">0111</span>==1110(补码)==-2</span><br><span class="line">负溢出1000+<span class="attribute">1000</span>==10000截断最高位==0000两个负数相加结果为0</span><br></pre></td></tr></table></figure>

<p>好的疑惑消失了。</p>
<h2 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h2><p>这些指令往往和cmp搭配使用，因为cmp可以同时进行两种比较，无符号数比较和有符号数比较。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406181600.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406181626.png"></p>
<h2 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406183935.png"></p>
<p>串传送指令：movsb，实现传送一个字节，movsw实现传送一个字</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184037.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184052.png"></p>
<p>movsb一般和rep搭配使用</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184255.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184459.png"></p>
<h2 id="pushf-和-popf"><a href="#pushf-和-popf" class="headerlink" title="pushf 和 popf"></a>pushf 和 popf</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184609.png"></p>
<p>push 和 pop显然不能进行这些操作，他两个的操作对象是字而不是bit。</p>
<h2 id="标志寄存器在Debug中的表示"><a href="#标志寄存器在Debug中的表示" class="headerlink" title="标志寄存器在Debug中的表示"></a>标志寄存器在Debug中的表示</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406185003.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406185033.png"></p>
<h2 id="实验-11-编写子程序"><a href="#实验-11-编写子程序" class="headerlink" title="实验 11 编写子程序"></a>实验 11 编写子程序</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406200150.png"></p>
<p>我们分析一下题目，以0结尾，我们可以通过cx实现自动循环。</p>
<p>难点在于我们如何识别出是小写字符a<del>z，应该是通过ASCII（97</del>122）判断，如果ascii在这个区间，那么我们就通过and 1101 1111将第6位置零，如果不在此区间，那么直接下一个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">datasg segment</span><br><span class="line">  db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class="line">data ends</span><br><span class="line">codesg segment</span><br><span class="line">begin:mov ax,datasg</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,0</span><br><span class="line">      call letterc</span><br><span class="line"></span><br><span class="line">      mov ax,4cooh</span><br><span class="line">      int 21h</span><br><span class="line"></span><br><span class="line">letterc:</span><br><span class="line">s0   :mov cl,[si]</span><br><span class="line">      mov ch,0</span><br><span class="line">      jcxz then</span><br><span class="line">      cmp cl,97</span><br><span class="line">      jb over;如果小于97，进行下一个字符</span><br><span class="line">      cmp cl,122;如果大于122，进行下一个</span><br><span class="line">      ja over</span><br><span class="line">      and cl,11011111b;如果在区间内则</span><br><span class="line">      mov [si],cl</span><br><span class="line">over :inc si</span><br><span class="line">      jmp s0</span><br><span class="line">then :ret</span><br><span class="line">codesg ends</span><br><span class="line">end begin</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406203439.png"></p>
<p>运行完我们使用d命令进行检测，全部都是大写，成功。</p>
<h1 id="第十二章-内中断"><a href="#第十二章-内中断" class="headerlink" title="第十二章  内中断"></a>第十二章  内中断</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406212630.png"></p>
<h2 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406213552.png"></p>
<p>有四种中断源，前三个看不懂，但是最后这个int很熟悉，我们可以推测一下，int 21，21这个中断类型码代表的就是结束程序。CPU通过中断类型码来识别中断信息的来源。</p>
<h2 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407135334.png"></p>
<p>1.取得中断类型码</p>
<p>2.标志寄存器入栈</p>
<p>3.设置标志寄存器</p>
<p>4.CS的内容入栈</p>
<p>5.IP的内容入栈</p>
<p>6.读取入口地址</p>
<h2 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h2><p>中断处理程序是存储在内存某段空间之中的，因为CPU随时都可能执行中断处理程序。中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表中。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407140044.png"></p>
<p>iret指令相较于ret指令多了一步，让标志寄存器出栈</p>
<p>pop IP</p>
<p>pop CS</p>
<p>popf</p>
<h2 id="向量表"><a href="#向量表" class="headerlink" title="向量表"></a>向量表</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407181125.png"></p>
<h2 id="实验-12-编写0号中断的处理程序"><a href="#实验-12-编写0号中断的处理程序" class="headerlink" title="实验 12 编写0号中断的处理程序"></a>实验 12 编写0号中断的处理程序</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407140951.png"></p>
<p>要点：1.中断处理程序一般存储在0000：0200~0000：02ff这256个字节中。</p>
<p>​            2.显示缓冲区 以B8000开始 25x80，25行80列，一列160个字节，两个字节显示一个字</p>
<p>​            3.我们想要现实的字符串，不能刚开始就存放在data段中，因为这个程序执行完之后，它所占用的内存空间被系统释放，在其中存放的字符串很可能会被别的信息覆盖，所以我们将字符串放置在do0程序中</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">d<span class="meta">o0</span>安装程序  将d<span class="meta">o0</span>的内容放在以<span class="number">0000</span>：<span class="number">0200</span>开头的那段空间中</span><br><span class="line">设置中断向量表 将中断类型码<span class="number">0</span>对应的中断向量表改为d<span class="meta">o0</span>程序的起始地址 注意第一个字节是偏移地址，第二个字节是段地址</span><br><span class="line">d<span class="meta">o0</span>程序 实现功能</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:;do0安装程序</span><br><span class="line">      mov ax,cs    </span><br><span class="line">      mov ds,ax    ;设置ds：si指向源地址（do0）</span><br><span class="line">      mov si,offset do0;刚开始忘了设置si了，导致源地址指向了向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h  ;设置es：di指向目的地址</span><br><span class="line">      </span><br><span class="line">      mov cx,offset do0end-do0</span><br><span class="line">      cld          ;设置传输方向为正</span><br><span class="line">      rep movsb    ;逐字节传输</span><br><span class="line">      </span><br><span class="line">      ;设置中断向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[0],200h;通用的格式是[n*4]</span><br><span class="line">      mov word ptr es:[2],0</span><br><span class="line">      ;检测程序</span><br><span class="line">      mov ax,1000h</span><br><span class="line">      mov bh,1</span><br><span class="line">      div bh</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">  do0:jmp short do0start</span><br><span class="line">      db &quot;divide erro!&quot;</span><br><span class="line">do0start:</span><br><span class="line">      mov ax,cx</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,202h      ;设置es:di指向字符串，刚开始的jmp指令长度为两个字节</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,12*160+36*2 ;第十三行，第36列</span><br><span class="line">      mov cx,12       ;cx为字符串长度</span><br><span class="line">   s: mov al,[si]</span><br><span class="line">      mov es:[di],al</span><br><span class="line">      mov es:[di+1],7ch</span><br><span class="line">      inc si</span><br><span class="line">      add di,2</span><br><span class="line">      loop s</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">      </span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h1 id="第十三章-int-指令"><a href="#第十三章-int-指令" class="headerlink" title="第十三章 int 指令"></a>第十三章 int 指令</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407162603.png"></p>
<h2 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407170452.png"></p>
<h2 id="实验-13-编写、应用中断例程"><a href="#实验-13-编写、应用中断例程" class="headerlink" title="实验 13 编写、应用中断例程"></a>实验 13 编写、应用中断例程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407172949.png"></p>
<p>这一题应该可以调用int 10的9号子程序吧，搭配2号子程序设置光标，但是9号子程序的结束标志是‘$’，看来是想让我们自己实现。</p>
<p>在网上看到了一种方法，先把安装程序执行，在运行测试程序，只要不重启DOSBox，就会保存我们设置的中断例程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;编写安装程序</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,offset ins             ;设置ds:si指向源程序</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h                   ;设置es:di指向目的地址</span><br><span class="line">      mov cx，offset insends-0ffset ins      ;传输长度</span><br><span class="line">      cld                            ;正向传输</span><br><span class="line">      rep mobsb</span><br><span class="line">      ;设置中断向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[7ch*4],200h     ;两个字节存一个地址 高地址存段 低地址存偏移</span><br><span class="line">      mov word ptr es:[ych*4+2],0</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">  ins:sub dh,1;这里注意000是第一行开始，160是第2行开始</span><br><span class="line">      mov al,160</span><br><span class="line">      mul dh;存入的数据是7*160，即第八行开始</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dh,0</span><br><span class="line">      add bx,dx</span><br><span class="line">      add bx,dx;这里实现列数，注意两个字节表一个字符，所以我们加两次即加6</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov al,cl</span><br><span class="line">    s:mov cl,[si]</span><br><span class="line">      mov ch,0</span><br><span class="line">      jcxz ok;如果是结束字符0，则跳转回去</span><br><span class="line">      mov es:[bx],cl</span><br><span class="line">      mov es:[bx+1],al</span><br><span class="line">      inc si</span><br><span class="line">      add bx,2</span><br><span class="line">      jmp short s</span><br><span class="line">ok:   iret</span><br><span class="line">insends:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>这里的ins程序和我们之前做的show_str十分吻合，我们直接copy过来，不要忘记将子程序使用的寄存器入栈然后反序出栈。</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407185352.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407185417.png"></p>
<p>啊这个不就是书中的例子吗，自己尝试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;编写安装程序 照着抄即可</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,offset ins             ;设置ds:si指向源程序</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h                   ;设置es:di指向目的地址</span><br><span class="line">      mov cx,offset insends-offset ins      ;传输长度</span><br><span class="line">      cld                            ;正向传输</span><br><span class="line">      rep movsb</span><br><span class="line">      ;设置中断向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[7ch*4],200h     ;两个字节存一个地址 高地址存段 低地址存偏移</span><br><span class="line">      mov word ptr es:[7ch*4+2],0</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">  ins:push bp</span><br><span class="line">      mov bp,sp</span><br><span class="line">      dec cx</span><br><span class="line">      jcxz lpret</span><br><span class="line">      add [bp+2],bx    ;给原来的ip加上位移 </span><br><span class="line">lpret:pop bp</span><br><span class="line">      iret</span><br><span class="line">insends:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>本来ins那里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ins：</span><br><span class="line">      dec cx</span><br><span class="line">      jcxz lpret</span><br><span class="line">      add [sp],bx    ;给原来的ip加上位移 </span><br></pre></td></tr></table></figure>

<p>然后就出现了一个报错：must be index or base register 必须是索引寄存器或者base寄存器</p>
<p>也就是sp不能放在[]里单独使用，只有bx、si、di、bp （第八章）</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407193620.png"></p>
<p>看到后面的’$‘,不难看出下面将使用int 21的子程序</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407194103.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407193938.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	s1:	db &#x27;Good,better,best,&#x27;,&#x27;$&#x27;</span><br><span class="line">	s2: db &#x27;Never let it rest&#x27;,&#x27;$&#x27;</span><br><span class="line">	s3: db &#x27;Till good is better&#x27;,&#x27;$&#x27;</span><br><span class="line">	s4: db &#x27;And better,best.&#x27;,&#x27;$&#x27;</span><br><span class="line">	s : dw offset s1,offset s2,offset s3,offset s4</span><br><span class="line">	row: db 2,4,6,8</span><br><span class="line"></span><br><span class="line">strat:</span><br><span class="line">	mov ax,cs</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,offset s</span><br><span class="line">	mov si,offset row</span><br><span class="line">	mov cx,4</span><br><span class="line">ok:</span><br><span class="line">	mov bh,0</span><br><span class="line">	mov dh,ds:[si]</span><br><span class="line">	mov dl,0</span><br><span class="line">	mov ah,2</span><br><span class="line">	int 10h</span><br><span class="line"></span><br><span class="line">	mov dx,ds:[bx]</span><br><span class="line">	mov ah,9</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">	add bx,2</span><br><span class="line">	int si,2</span><br><span class="line">	loop ok</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end strat		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="第十四章-端口"><a href="#第十四章-端口" class="headerlink" title="第十四章 端口"></a>第十四章 端口</h1><h2 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h2><p>端口的读写指令只有两条，in和out，分别用于从端口读取数据和往端口写入数据</p>
<p>举个例子 （这里的in和out是针对 out就是从寄存器中出去）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dx,3f8h ;将端口号送入dx</span><br><span class="line">in  al,dx   ;从3f8h端口读入一个字节，就是将dx中的数据送入al</span><br><span class="line">out dx,al   ;向3f8h端口写入一个字节，将al中的数据写入dx</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409205632.png"></p>
<h2 id="CMOS-RAM-芯片"><a href="#CMOS-RAM-芯片" class="headerlink" title="CMOS RAM 芯片"></a>CMOS RAM 芯片</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409205749.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409205813.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,2</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h</span><br></pre></td></tr></table></figure>

<h2 id="逻辑位移指令-shl和shr"><a href="#逻辑位移指令-shl和shr" class="headerlink" title="逻辑位移指令 shl和shr"></a>逻辑位移指令 shl和shr</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409210214.png"></p>
<p>左移相当于x*2，右移相当于x&#x2F;2。</p>
<h2 id="实验-14-访问-CMOS-RAM"><a href="#实验-14-访问-CMOS-RAM" class="headerlink" title="实验 14 访问 CMOS RAM"></a>实验 14 访问 CMOS RAM</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409210618.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409210754.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">      mov cx,3</span><br><span class="line">      mov si,30</span><br><span class="line">   s: push cx</span><br><span class="line">      add cx,6</span><br><span class="line">      mov al,cl</span><br><span class="line">      out 70h,al</span><br><span class="line">      in al,71h</span><br><span class="line">      mov ah,al</span><br><span class="line">      mov cl,4</span><br><span class="line">      shr ah,cl</span><br><span class="line">      and al,00001111b</span><br><span class="line">      add ah,30h    ;以ascii表示</span><br><span class="line">      add al,30h</span><br><span class="line">      mov bx,0b800h</span><br><span class="line">      mov es,bx</span><br><span class="line">      mov bx,si</span><br><span class="line">      mov byte ptr es:[160*12+si+bx],ah</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+2],al</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+4],2fh</span><br><span class="line">      add si,3</span><br><span class="line">      pop cx</span><br><span class="line">      loop s</span><br><span class="line">      mov cx,3</span><br><span class="line">  s2: push cx</span><br><span class="line">      add cx,cx</span><br><span class="line">      sub cx,2</span><br><span class="line">      push cx</span><br><span class="line">      mov al,cl</span><br><span class="line">      out 70h,al</span><br><span class="line">      in al,71h</span><br><span class="line">      mov ah,al</span><br><span class="line">      mov cl,4</span><br><span class="line">      shr ah,cl</span><br><span class="line">      and al,00001111b</span><br><span class="line">      add ah,30h    ;以ascii表示</span><br><span class="line">      add al,30h</span><br><span class="line">      mov bx,0b800h</span><br><span class="line">      mov es,bx</span><br><span class="line">      mov bx,si</span><br><span class="line">      mov byte ptr es:[160*12+si+bx],ah</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+2],al</span><br><span class="line">      pop cx</span><br><span class="line">      jcxz ok    ;如果没有这一步的化，最后秒后面会多出一个冒号</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+4],3ah     ;冒号的ascii</span><br><span class="line">      add si,3</span><br><span class="line">      pop cx</span><br><span class="line">      loop s2 </span><br><span class="line">   ok:mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">      </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409231300.png"></p>
<h1 id="第十五章-外中断"><a href="#第十五章-外中断" class="headerlink" title="第十五章 外中断"></a>第十五章 外中断</h1><p>用两个16位寄存器来存放32位的循环次数，这里刚开始没看懂，在网上找到了一个恍然大悟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   mov ds,10h</span><br><span class="line">   mov ax,0</span><br><span class="line">s: sub ax,1    ;第一次ax=fffffh，cf=1</span><br><span class="line">   sbb dx,0    ;第一次dx=fh</span><br><span class="line">   cmp ax,0</span><br><span class="line">   jne s</span><br><span class="line">   cmp dx,0</span><br><span class="line">   jne s</span><br></pre></td></tr></table></figure>

<p>上述程序实现了循环100000次。sbb dx,0 相当于dx&#x3D;dx-0-CF,每循环（ffffh+1）即10000h次，dx减1.注意这里dx减1，发生在每10000次循环的最开始哦。</p>
<h2 id="sti和cli指令"><a href="#sti和cli指令" class="headerlink" title="sti和cli指令"></a>sti和cli指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230410205935.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230410205945.png"></p>
<p>下面的程序用于改变全屏的显示信息非常的炫酷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment </span><br><span class="line"> db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">      mov ss,ax</span><br><span class="line">      mov sp,128</span><br><span class="line">      push cs</span><br><span class="line">      pop ds</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov si,offset int9</span><br><span class="line">      mov di,204h</span><br><span class="line">      mov cx,offset int9end-offset int9</span><br><span class="line">      cld</span><br><span class="line">      rep movsb</span><br><span class="line">      push es:[9*4]</span><br><span class="line">      pop es:[200h]</span><br><span class="line">      push es:[9*4+2]</span><br><span class="line">      pop es:[202h]</span><br><span class="line">      cli</span><br><span class="line">      mov word ptr es:[9*4],204h</span><br><span class="line">      mov word ptr es:[9*4+2],0</span><br><span class="line">      sti</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">int9: push ax</span><br><span class="line">      push bx</span><br><span class="line">      push cx</span><br><span class="line">      push es</span><br><span class="line">      in al,60h               ;接收键入的字符</span><br><span class="line">      pushf</span><br><span class="line">      call dword ptr cs:[200h]</span><br><span class="line">      cmp al,3bh</span><br><span class="line">      jne int9ret</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,1</span><br><span class="line">      mov cx,2000</span><br><span class="line">  s:  inc byte ptr es:[bx]</span><br><span class="line">      add bx,2</span><br><span class="line">      loop s</span><br><span class="line">int9ret:pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br><span class="line">int9end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实验-15-安装新的int9中断例程"><a href="#实验-15-安装新的int9中断例程" class="headerlink" title="实验 15 安装新的int9中断例程"></a>实验 15 安装新的int9中断例程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230410220732.png"></p>
<p>这次实验我们只需要更改上面程序int9的部分即可，A的通码1E，断码9E</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment </span><br><span class="line"> db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">      mov ss,ax</span><br><span class="line">      mov sp,128</span><br><span class="line">      push cs</span><br><span class="line">      pop ds</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov si,offset int9</span><br><span class="line">      mov di,204h</span><br><span class="line">      mov cx,offset int9end-offset int9</span><br><span class="line">      cld</span><br><span class="line">      rep movsb</span><br><span class="line">      push es:[9*4]</span><br><span class="line">      pop es:[200h]</span><br><span class="line">      push es:[9*4+2]</span><br><span class="line">      pop es:[202h]</span><br><span class="line">      cli</span><br><span class="line">      mov word ptr es:[9*4],204h</span><br><span class="line">      mov word ptr es:[9*4+2],0</span><br><span class="line">      sti</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">int9: push ax</span><br><span class="line">      push bx</span><br><span class="line">      push cx</span><br><span class="line">      push es</span><br><span class="line">      in al,60h               ;接收键入的字符</span><br><span class="line">      pushf</span><br><span class="line">      call dword ptr cs:[200h]</span><br><span class="line">      cmp al,1eh               ;A的通码</span><br><span class="line">      je int9ret</span><br><span class="line">      cmp al,9eh</span><br><span class="line">      jne int9ret</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov cx,2000</span><br><span class="line">  s:  mov byte ptr es:[bx],65</span><br><span class="line">      add bx,2</span><br><span class="line">      loop s</span><br><span class="line">int9ret:pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br><span class="line">int9end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="第十六章-直接定址表"><a href="#第十六章-直接定址表" class="headerlink" title="第十六章 直接定址表"></a>第十六章 直接定址表</h1><h2 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230411145516.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8</span><br><span class="line">    b dw 0</span><br><span class="line">    ;这里的a其实可以理解为数组的首地址a[0]是1</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230411145837.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:db 1,2,3,4</span><br><span class="line">b:dw 0</span><br><span class="line">;这种用法是代码段中特有的    即使用  :</span><br></pre></td></tr></table></figure>

<h2 id="将标号当作数据来使用"><a href="#将标号当作数据来使用" class="headerlink" title="将标号当作数据来使用"></a>将标号当作数据来使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line"> a db 1,2,3,4,5</span><br><span class="line"> b dw 0</span><br><span class="line"> c dw a,b      ;c dd a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line"> a db 1,2,3,4,5</span><br><span class="line"> b dw 0</span><br><span class="line"> c dw offset a,offset b   ;c dw offset a,seg a,offset b,seg b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<p>seg 取段地址</p>
<h2 id="实验-16"><a href="#实验-16" class="headerlink" title="实验 16"></a>实验 16</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230411122855.png"></p>
<p>具体的功能怎么实现，书中写的很清楚，我们的任务是确定整个程序的框架。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment </span><br><span class="line">   db 64 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:;安装新的int7ch</span><br><span class="line">mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,64</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,offset int7ch</span><br><span class="line">mov si,ax</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset int7chend-offset int7ch</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[7ch*4],200h</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">int7ch:</span><br><span class="line">     jmp short set</span><br><span class="line">     table dw offset sub1-offset int7ch+200h</span><br><span class="line">           dw offset sub2-offset int7ch+200h</span><br><span class="line">           dw offset sub3-offset int7ch+200h</span><br><span class="line">           dw offset sub4-offset int7ch+200h</span><br><span class="line"> set:push bx</span><br><span class="line">     cmp ah,3</span><br><span class="line">     ja sret</span><br><span class="line">     mov bl,ah</span><br><span class="line">     mov bh,0</span><br><span class="line">     add bx,bx</span><br><span class="line">     call word ptr cs:[bx+202h] ;这里的cs是跳转到int7ch之后的cs，加202是因为前面的jmp short set占了两个字节</span><br><span class="line">sret:pop bx</span><br><span class="line">     iret</span><br><span class="line">     sub1:push bx             ;清屏</span><br><span class="line">          push cx</span><br><span class="line">          push es</span><br><span class="line">          mov bx,0b800h</span><br><span class="line">          mov es,bx</span><br><span class="line">          mov bx,0</span><br><span class="line">          mov cx,2000</span><br><span class="line">    sub1s:mov byte ptr es:[bx],&#x27; &#x27;</span><br><span class="line">          add bx,2</span><br><span class="line">          loop sub1s</span><br><span class="line">          pop es</span><br><span class="line">          pop cx</span><br><span class="line">          pop bx</span><br><span class="line">          ret</span><br><span class="line">     sub2:push bx             ;前景</span><br><span class="line">          push cx</span><br><span class="line">          push es</span><br><span class="line">          mov bx,0b800h</span><br><span class="line">          mov es,bx</span><br><span class="line">          mov bx,1</span><br><span class="line">          mov cx,2000</span><br><span class="line">    sub2s:and byte ptr es:[bx],11110000b</span><br><span class="line">          or es:[bx],al</span><br><span class="line">          add bx,2</span><br><span class="line">          loop sub2s</span><br><span class="line">          pop es</span><br><span class="line">          pop cx</span><br><span class="line">          pop bx</span><br><span class="line">          ret</span><br><span class="line">     sub3:push bx             ;背景</span><br><span class="line">          push cx</span><br><span class="line">          push es</span><br><span class="line">          mov cl,4</span><br><span class="line">          shl al,cl</span><br><span class="line">          mov bx,0b800h</span><br><span class="line">          mov es,bx</span><br><span class="line">          mov bx,1</span><br><span class="line">          mov cx,2000</span><br><span class="line">    sub3s:and byte ptr es:[bx],10001111b</span><br><span class="line">          or es:[bx],al</span><br><span class="line">          add bx,2</span><br><span class="line">          loop sub3s</span><br><span class="line">          pop es</span><br><span class="line">          pop cx</span><br><span class="line">          pop bx</span><br><span class="line">          ret</span><br><span class="line">     sub4:push cx             ;滚动</span><br><span class="line">          push si</span><br><span class="line">          push di</span><br><span class="line">          push es</span><br><span class="line">          push ds</span><br><span class="line">          mov si,0b800h</span><br><span class="line">          mov es,si</span><br><span class="line">          mov ds,si</span><br><span class="line">          mov si,160</span><br><span class="line">          mov di,0</span><br><span class="line">          cld</span><br><span class="line">          mov cx,24</span><br><span class="line">    sub4s:push cx</span><br><span class="line">          mov cx,160</span><br><span class="line">          rep movsb         ;si和di的增加在此处进行</span><br><span class="line">          pop cx</span><br><span class="line">          loop sub4s</span><br><span class="line">          mov cx,80</span><br><span class="line">          mov si,0</span><br><span class="line">   sub4s1:mov byte ptr [160*24+si],&#x27; &#x27;</span><br><span class="line">          add si,2</span><br><span class="line">          loop sub4s1</span><br><span class="line">          pop ds</span><br><span class="line">          pop es</span><br><span class="line">          pop di</span><br><span class="line">          pop si</span><br><span class="line">          pop cx</span><br><span class="line">          ret</span><br><span class="line">int7chend:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>其实我们这里使用table的方式有点麻烦</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; table dw offset sub1-offset int7ch+200h</span><br><span class="line">           dw offset sub2-offset int7ch+200h</span><br><span class="line">           dw offset sub3-offset int7ch+200h</span><br><span class="line">           dw offset sub4-offset int7ch+200h</span><br><span class="line">;call word ptr cs:[bx+202h] </span><br><span class="line">;我们把上面这些替换成下面的</span><br><span class="line">;在int7ch前面加上 org 200h 表示偏移地址从200h处开始</span><br><span class="line">  table dw sub1,sub2,sub3,sub4</span><br><span class="line">  call word ptr table[bx]</span><br></pre></td></tr></table></figure>

<p>没加那个org 200h是不行的</p>
<p>org 200H		;表示下一条地址从偏移地址200H开始，和安装后的偏移地址相同，若没有org 200H，中断例程安装后，标号代表的地址改变了，和之前编译器编译的有所区别 </p>
<p>如果我们不加上org，那么这个table的偏移地址就是本程序中的偏移地址.可是为什么sub1，这种标号还是以200h为准的偏移？应该是因为，sub1作为一个标号能正确的复制过去，table作为一个标号复制不过去，是因为table是比较抽象的？隐式的？</p>
<p>下面这张图是org 200h的，【bx+202h】</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/Untitled.png"></p>
<p>这张图是没有org的，我们可以看到下面的【bx+36h】，加的table的偏移地址</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/Untitled2.png"></p>
<h2 id="疑惑-1"><a href="#疑惑-1" class="headerlink" title="疑惑"></a>疑惑</h2><p>为什么同样是标号，table复制过去是安装程序中的地址，sub传过去的就是200h的偏移地址？？？我觉得合理的解释是这个sub1s跟着一起复制了过去，就是第二个sub1s其实是随着第一个sub1s的变化而变化的。在程序执行完之后，主程序所占的内存被其他数据覆盖，之前的sub1消失，这么理解的话，标号代表的不一定是个固定不变的地址。</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230412020235.png"></p>
<h1 id="第十七章-使用BIOS进行键盘输入和磁盘读写"><a href="#第十七章-使用BIOS进行键盘输入和磁盘读写" class="headerlink" title="第十七章 使用BIOS进行键盘输入和磁盘读写"></a>第十七章 使用BIOS进行键盘输入和磁盘读写</h1><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>编写虚拟机</title>
    <url>/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>注意，接下来要实现的虚拟机不是VMware那种有完整操作的虚拟机，而是JVM这种（解释器），更像一个翻译，可以将汇编语言转成高级语言。我们将用代码模拟计算机的硬件组件。</p>
<h2 id="虚拟机概念"><a href="#虚拟机概念" class="headerlink" title="虚拟机概念"></a>虚拟机概念</h2><p>简单来说虚拟机可以定义为一个软件程序，用来模拟一些其他物理机的功能。</p>
<span id="more"></span>

<h1 id="LC-3-架构"><a href="#LC-3-架构" class="headerlink" title="LC-3 架构"></a>LC-3 架构</h1><p>下面我们将实现LC-3虚拟机而不是x86计算机。与x56相比，LC-3 的指令集更 加简化，但现代 CPU 的主要思想其中都包括了。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>该计算机有65536（16bit）个内存空间，每个位置可以存储一个16bit的值。我们用数组来模拟内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span>  memory[UINT16_MAX];     <span class="comment">//UINT16_MAX为16bit所能表示的最大值</span></span><br></pre></td></tr></table></figure>

<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>就像cpu的工作台，cpu要对一段数据进行处理则必须要将这段数据放到寄存器中。lc-3有十个寄存器，其中八个通用寄存器，一个程序计数器寄存器，一个条件标志位寄存器。</p>
<p>通用寄存器可以执行任何程序计算。计数器寄存器存放下一条指令的地址，条件寄存器记录上一次计算的正负符号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> //10个寄存器，八个通用，一个程序计数器寄存器，一个条件寄存器</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	R_R0=<span class="number">0</span>,</span><br><span class="line">	R_R1,</span><br><span class="line">	R_R3,</span><br><span class="line">	R_R4,</span><br><span class="line">	R_R5, </span><br><span class="line">	R_R6, </span><br><span class="line">	R_R7,</span><br><span class="line">	R_PC,<span class="comment">//程序计数器寄存器，存储要执行的指令的地址</span></span><br><span class="line">	R_COND,</span><br><span class="line">	R_COUNT<span class="comment">//这个值为10，是下面reg数组的长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用数组来表示这些寄存器</span></span><br><span class="line"><span class="type">uint16_t</span> reg[R_COUNT];</span><br></pre></td></tr></table></figure>

<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>指令集是一组计算机处理器可以理解和执行的指令或操作码，机器语言则是指令的二进制形式。一条指令就是一条cpu命令，他告诉cpu执行什么任务。一条指令包括两个部分：1.操作码 2.参数</p>
<p>每个操作码（0000—1111）代表一种任务，每条指令16bit，左侧的4bit存储操作码，其余存储参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>//定义操作码   </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	OP_BR = <span class="number">0</span>,<span class="comment">//分支指令</span></span><br><span class="line">	OP_ADD,</span><br><span class="line">	OP_LD,<span class="comment">//LOAD 加载指令</span></span><br><span class="line">	OP_ST,<span class="comment">//STORE 存储指令</span></span><br><span class="line">	OP_JSR,<span class="comment">//JUMP REGISTER 寄存器跳转指令</span></span><br><span class="line">	OP_AND,<span class="comment">//BITWISE AND   按位 与</span></span><br><span class="line">	OP_LDR,<span class="comment">//LOAD REGISTER  寄存器装载指令</span></span><br><span class="line">	OP_STR,<span class="comment">//STORE REGISTER 寄存器存储指令</span></span><br><span class="line">	OP_RTI,<span class="comment">//UNUSED  未使用</span></span><br><span class="line">	OP_NOT,<span class="comment">//BITWISE NOT 按位非</span></span><br><span class="line">	OP_LDI,<span class="comment">//LOAD INDIRRCT 间接装载指令</span></span><br><span class="line">	OP_STI,<span class="comment">//STORE INDIRECT 间接存储指令</span></span><br><span class="line">	OP_JUMP,<span class="comment">//JUMP </span></span><br><span class="line">	OP_RES,<span class="comment">//RESERVED(UNUSED)</span></span><br><span class="line">	OP_LEA,<span class="comment">//LOAD EFFECTIVE ADDRESS 加载有效地址</span></span><br><span class="line">	OP_TRAP<span class="comment">//EXECUTE TRAP 执行陷阱指令</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="条件标志位"><a href="#条件标志位" class="headerlink" title="条件标志位"></a>条件标志位</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    FL_POS = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">/* P */</span>    <span class="comment">//正数  0001</span></span><br><span class="line">    FL_ZRO = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">/* Z */</span>    <span class="comment">//零    0010</span></span><br><span class="line">    FL_NEG = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">/* N */</span>    <span class="comment">//负数   0100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>硬件的模拟完成。</p>
<h1 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h1><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>从PC寄存器指向的内存地址中加载一条指令</li>
<li>递增PC寄存器（指向下一条命令）</li>
<li>查看指令的操作码，判断指令类型</li>
<li>根据指令类型和指令中的参数执行该指令</li>
<li>跳转到第一步</li>
</ol>
<p>这个过程一点也不陌生和x86机器一摸一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    &#123;Load Arguments, <span class="number">12</span>&#125;</span><br><span class="line">    &#123;Setup, <span class="number">12</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the PC to starting position */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> PC_START = <span class="number">0x3000</span> &#125;; <span class="comment">/* 0x3000 is the default */</span></span><br><span class="line">    reg[R_PC] = PC_START;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> running = <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="type">uint16_t</span> instr = mem_read(reg[R_PC]++); <span class="comment">/* FETCH */</span> <span class="comment">//步骤一、步骤二</span></span><br><span class="line">        <span class="type">uint16_t</span> op = instr &gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;      <span class="comment">//步骤三、四</span></span><br><span class="line">            <span class="keyword">case</span> OP_ADD: &#123;ADD, <span class="number">6</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_AND: &#123;AND, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_NOT: &#123;NOT, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_BR: &#123;BR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_JMP: &#123;JMP, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_JSR: &#123;JSR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LD: &#123;LD, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LDI: &#123;LDI, <span class="number">6</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LDR: &#123;LDR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LEA: &#123;LEA, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ST: &#123;ST, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_STI: &#123;STI, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_STR: &#123;STR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_TRAP: &#123;TRAP, <span class="number">8</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_RES:</span><br><span class="line">            <span class="keyword">case</span> OP_RTI:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                &#123;BAD OPCODE, <span class="number">7</span>&#125;    </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;Shutdown, <span class="number">12</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是主要框架，接下来的任务就是具体的写出每一个指令实现了什么功能。详单与我们去完善一些函数。</p>
<h1 id="指令实现"><a href="#指令实现" class="headerlink" title="指令实现"></a>指令实现</h1><p>在这里我们描述指令如何运行</p>
<h3 id="ADD指令"><a href="#ADD指令" class="headerlink" title="ADD指令"></a>ADD指令</h3><p>ADD 指令将两个数相加，然后将结果存到一个寄存器中。</p>
<p>有两种格式：ADD R2 R0 R1  ；ADD R0 R0 1 第一种是将R0+R2存储到R2,第二种是将R0+1存到R0。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230518214834.png"></p>
<p>第二种方式我们可以看出立即数只有五位，我们得把它加载到一个16bit的空间上，这就涉及到有符号扩展，这部分内容CSAPP第二章讲的很详细，对于正数我们直接给高位填充0即可，对于负数，由于是用补码表示，所以我们将高位填充1,举个例子：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"> <span class="comment">5</span><span class="literal">--</span>&gt;<span class="comment">0101</span><span class="literal">--</span>&gt;<span class="comment">0000 0101</span></span><br><span class="line"><span class="literal">-</span><span class="comment">5</span><span class="literal">--</span>&gt;<span class="comment">1011</span><span class="literal">--</span>&gt;<span class="comment">1111 1011</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">sign_extend</span><span class="params">(<span class="type">uint16_t</span> x, <span class="type">int</span> bit_count)</span> &#123;  <span class="comment">//实现有符号扩展</span></span><br><span class="line">    <span class="keyword">if</span> ((x &gt;&gt; (bit_count - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        x |= (<span class="number">0xFFFF</span> &lt;&lt; bit_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次使用ADD都会涉及到寄存器值的改变，每当改变发生我们都要更新标志寄存器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_flags</span><span class="params">(<span class="type">uint16_t</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reg[r]==<span class="number">0</span>)&#123;</span><br><span class="line">        reg[R_COND]=FL_ZRO;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (reg[r] &gt;&gt; <span class="number">15</span>) &#123; <span class="comment">//查看符号位</span></span><br><span class="line">        reg[R_COND] = FL_NEG;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reg[R_COND] = FL_POS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现ADD的逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//只看9到11位，即目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> r1=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;<span class="comment">//第一个参数 寄存器编号</span></span><br><span class="line">    <span class="type">uint16_t</span> imm_flag=(instr&gt;&gt;<span class="number">5</span>)&amp;<span class="number">1</span>;<span class="comment">//查看第五位从而确定最后一个参数是寄存器还是立即数</span></span><br><span class="line">    <span class="keyword">if</span>(imm_flag)&#123;<span class="comment">//立即数模式</span></span><br><span class="line">        <span class="type">uint16_t</span> imm5=sign_extend(instr&amp;<span class="number">0x1f</span>,<span class="number">5</span>);<span class="comment">//短于16bit的值进行符号扩展</span></span><br><span class="line">        reg[r0]=reg[r1]+imm5;    </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;       <span class="comment">//寄存器模式</span></span><br><span class="line">        <span class="type">uint16_t</span> r2=instr&amp;<span class="number">0x7</span>;</span><br><span class="line">        reg[r0]=reg[r1]+reg[r2];</span><br><span class="line">    &#125;</span><br><span class="line">    update_flags(r0);<span class="comment">//查看计算的结果并更新标志寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是完整的ADD啦，小巧而精悍。</p>
<h3 id="LDI指令"><a href="#LDI指令" class="headerlink" title="LDI指令"></a>LDI指令</h3><p>LDI 是 load indirect 的缩写，用于从内存加载一个值到寄存器。感觉和x86里面的mov与lea（load effective address)相似。 LDI 的二进制格式如下：</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519000010.png"></p>
<p>实现逻辑是这样的：0-8是内存地址，将程序计数器寄存器的值加上此值，pc自加1，自加1之后的PC就是加载地址，取出该内存单元的值，将其放入9-11位所表示的寄存器中，这个0-8，也就是能够表示一个9bit的地址，我们的内存是16位的，所以显然LDI指令只能对附近的一些内存单元进行操作，这在x86中也有体现，当时只是知道一些指令只能进行段内跳转，这还是相对跳转hhh，现在清楚了为什么是远眺转为什么是近跳转。“可以将它想想成 C 中有一个局部变 量，这变量是指向某些数据的指针”，C语言中的局部变量也是因为距离的原因不能作用于全局嘛？？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//取目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> pc_offset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);<span class="comment">//符号扩展，第一个参数是该数的位，第二个参数描述长度</span></span><br><span class="line">   reg[r0]=men_read(mem_read(reg[R_PC]+pc_offset));<span class="comment">//读取指定内存地址处的值加载入目的寄存器</span></span><br><span class="line">    update_flags(r0);<span class="comment">//更新标志寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bitwise-and-（按位与）"><a href="#Bitwise-and-（按位与）" class="headerlink" title="Bitwise and （按位与）"></a>Bitwise and （按位与）</h3><p>AND和上面的ADD一样，也有两种模式即立即模式和寄存器模式。照着葫芦画瓢就行。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519160042.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> r1=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">    <span class="type">uint16_t</span> imm_flag=(instr&gt;&gt;<span class="number">5</span>)&amp;<span class="number">0x1</span>;<span class="comment">//确定模式</span></span><br><span class="line">    <span class="keyword">if</span>(imm_flag)&#123;</span><br><span class="line">        <span class="type">uint16_t</span> imm5=sign_extend(instr&amp;<span class="number">0x1f</span>,<span class="number">5</span>);</span><br><span class="line">        reg[r0]=reg[r1]&amp;imm5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">uint16_t</span> r2=instr&amp;<span class="number">0x7</span>;</span><br><span class="line">        reg[r0]=reg[r1]&amp;reg[r2];</span><br><span class="line">    &#125;</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是把ADD代码里的+换成了&amp;这么简单。</p>
<h3 id="Bitwise-not（按位非）"><a href="#Bitwise-not（按位非）" class="headerlink" title="Bitwise not（按位非）"></a>Bitwise not（按位非）</h3><p>位上的0变1，1变0；</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519162611.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> r1=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">    reg[r0]=~reg[r1];</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Branch（条件分支）"><a href="#Branch（条件分支）" class="headerlink" title="Branch（条件分支）"></a>Branch（条件分支）</h3><p>11-9所示的三位分别代表负数、零、正数，当n被设置为1的时候，就会检测条件码寄存器的值是否为FL_NEG，如果相等则跳转，其余两位原理相同。可以进行一些组合，比如设置为011则代表如果最近一次寄存器中的值更改为0或正数都会进行跳转。特殊的，如果设置为000则不进行检测，无条件跳转。（这里为什么不设置成111，这样无论正数负数还是0都会进行跳转啊），至于如何跳转，就是进行pc&#x3D;pc+pccoffset9.那这样进行排列组合的话就有八种可能。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519163705.png"></p>
<p>我的狗屎代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> n=(instr&gt;&gt;<span class="number">11</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> z=(instr&gt;&gt;<span class="number">10</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> p=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="type">uint16_t</span> nzp=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//000 001 010 011 100 101 110 111</span></span><br><span class="line">    <span class="keyword">if</span>(nzp==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_PC]=reg[R_PC]+pc_offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nzp==<span class="number">1</span>)</span><br><span class="line">    &#123;<span class="comment">//判断是否为正数</span></span><br><span class="line">        <span class="keyword">if</span>(reg[R_COND]==FL_POS)</span><br><span class="line">        &#123;</span><br><span class="line">            reg[R_PC]=reg[R_PC]+pc_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nzp==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">////////////这样一个个的判断当然不是不行，可就是这八种情况少说也得有70行代码，我觉得应该不会如此臃肿，果然，作者的实现只用了5行代码woc</span></span><br></pre></td></tr></table></figure>

<p>作者代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="type">uint16_t</span> cond_flag=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">if</span>(cond_flag&amp;reg[R_COND])&#123;</span><br><span class="line">        reg[R_PC]+=pc_offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最精华的部分是在 if(cond_flag&amp;reg[R_COND])这里，太精华了，这样一看代码果然前面的那个无条件跳转是将nzp三位设置成111而不是000.从这一步也可以解释当时条件码为什么要用移位符号那样设置。</p>
<h3 id="Jump（跳转）"><a href="#Jump（跳转）" class="headerlink" title="Jump（跳转）"></a>Jump（跳转）</h3><p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519163639.png"></p>
<blockquote>
<p>RET 在规范中作为一个单独的指令列出，因为在汇编中它是一个独立的关键字。但是，RET 本质上是 JMP 的一个特殊情况。当 R1 为 7 时会执行 RET。</p>
</blockquote>
<p>无条件的跳转到寄存器指示的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    reg[R_PC]=reg[r0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Jump-Register（跳转寄存器）"><a href="#Jump-Register（跳转寄存器）" class="headerlink" title="Jump Register（跳转寄存器）"></a>Jump Register（跳转寄存器）</h3><p>也是两种情况。根据文章的解释将它理解为x86里的call指令应该没什么不妥，毕竟他首先将下一条指令存到了寄存器rR7中，这对应了push ip操作吧。JSR模式：将pc加上pccoffset11；JSSR模式：将pc设置为寄存器的值。一个是远眺转一个是进跳转吧。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519175718.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> imm_flag=(instr&gt;&gt;<span class="number">11</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> long_pc_offset = sign_extend(instr &amp; <span class="number">0x7ff</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="type">uint16_t</span> long_flag = (instr &gt;&gt; <span class="number">11</span>) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    reg[R_R7] = reg[R_PC];</span><br><span class="line">    <span class="keyword">if</span> (long_flag) &#123;</span><br><span class="line">        reg[R_PC] += long_pc_offset;  <span class="comment">/* JSR */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reg[R_PC] = reg[r1]; <span class="comment">/* JSRR */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;<span class="comment">//终止包含他的循环，并执行下一阶段。结束这次的switch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个最后为什么要加上个break呀，在模板里break不是统一加在了最后吗，去掉应该没啥问题。</p>
<h3 id="Load（加载）"><a href="#Load（加载）" class="headerlink" title="Load（加载）"></a>Load（加载）</h3><p>相对地址在后面的pc段，用相对寻址的方法取得目的地址存放的数据，载入目的寄存器中。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519195058.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_coffset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    reg[r0]=mem_read(reg[R_PC]+pc_coffset);</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Load-Register（加载寄存器）"><a href="#Load-Register（加载寄存器）" class="headerlink" title="Load Register（加载寄存器）"></a>Load Register（加载寄存器）</h3><p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519200825.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">    reg[r0] = mem_read(reg[r1] + offset);</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Load-Effective-Address（加载有效地址）"><a href="#Load-Effective-Address（加载有效地址）" class="headerlink" title="Load Effective Address（加载有效地址）"></a>Load Effective Address（加载有效地址）</h3><p>和load小小不同</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519200522.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_coffset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    reg[r0]=reg[R_PC]+pc_coffset;</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Store（存储）"><a href="#Store（存储）" class="headerlink" title="Store（存储）"></a>Store（存储）</h3><p>将寄存器中的值存储到我们指定的内存单元</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519201159.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">    mem_write(reg[R_PC] + pc_offset, reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Store-Indirect（间接存储）"><a href="#Store-Indirect（间接存储）" class="headerlink" title="Store Indirect（间接存储）"></a>Store Indirect（间接存储）</h3><p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519201743.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">    mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Store-Register（存储寄存器）"><a href="#Store-Register（存储寄存器）" class="headerlink" title="Store Register（存储寄存器）"></a>Store Register（存储寄存器）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">    mem_write(reg[r1] + offset, reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="涉及到的一些函数"><a href="#涉及到的一些函数" class="headerlink" title="涉及到的一些函数"></a>涉及到的一些函数</h2><h3 id="mem-read"><a href="#mem-read" class="headerlink" title="mem_read()"></a>mem_read()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == MR_KBSR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_key()) &#123;</span><br><span class="line">            memory[MR_KBSR] = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">            memory[MR_KBDR] = getchar();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memory[MR_KBSR] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mem-write"><a href="#mem-write" class="headerlink" title="mem_write()"></a>mem_write()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span> &#123;</span><br><span class="line">    memory[address] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中断陷入例程"><a href="#中断陷入例程" class="headerlink" title="中断陷入例程"></a>中断陷入例程</h2><p>这是什么，和之前接触的内中断、外中断一回事吗？</p>
<blockquote>
<p>LC-3 提供了几个预定于的函数（过程），用于执行常规任务以及与 I&#x2F;O 设备交换， 例如，用于从键盘接收输入的函数，在控制台上显示字符串的函数。这些都称为 trap routines，你可以将它们当做操作系统或者是 LC-3 的 API。 每个 trap routine 都有一个对应的 trap code（中断号）。要执行一次捕获， 需要用相应的 trap code 执行 <code>TRAP</code> 指令。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TRAP_GETC = <span class="number">0x20</span>,  <span class="comment">/* 从键盘获取字符，不在终端回显 */</span></span><br><span class="line">    TRAP_OUT = <span class="number">0x21</span>,   <span class="comment">/* 输出一个字符 */</span></span><br><span class="line">    TRAP_PUTS = <span class="number">0x22</span>,  <span class="comment">/* 输出一个字符串 */</span></span><br><span class="line">    TRAP_IN = <span class="number">0x23</span>,    <span class="comment">/* 从键盘获取字符，并在终端回显 */</span></span><br><span class="line">    TRAP_PUTSP = <span class="number">0x24</span>, <span class="comment">/* 输出一个字节字符串*/</span></span><br><span class="line">    TRAP_HALT = <span class="number">0x25</span>   <span class="comment">/* 停止程序运行 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“字节字符串”（Byte String）是由多个字节组成的序列，每个字节都有8位。字节字符串不像字符串那样直接包含可读的字符，而是用于表示各种类型的信息，如图像、声音、视频、压缩文件等。在字节字符串中，单独的字节没有特定的意义，而是需要根据上下文来解释。</p>
</blockquote>
<p>逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (instr &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> TRAP_GETC: &#123;TRAP GETC, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_OUT: &#123;TRAP OUT, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_PUTS: &#123;TRAP PUTS, <span class="number">8</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_IN: &#123;TRAP IN, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_PUTSP: &#123;TRAP PUTSP, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_HALT: &#123;TRAP HALT, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PUTS"><a href="#PUTS" class="headerlink" title="PUTS"></a>PUTS</h3><p><code>PUT</code> trap code 用于输出一个以空字符结尾的字符串（和 C 中的 <code>printf</code> 类似）显示一个字符串需要将这个字符串的地址放到 <code>R0</code> 寄存器，然后触发 trap。</p>
<p>将字符串存储到一个连续的内存区域。由于LC-3内存寻址是16位的，所以打印之前需要先将内存中的值转换为char类型再输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span>* c=memory+reg[R_R0];<span class="comment">//memory内存首地址</span></span><br><span class="line">    <span class="keyword">while</span>(*c)&#123;<span class="comment">//c语言的字符串结尾会放一个0，ASCII的0来代表结束</span></span><br><span class="line">        putc((<span class="type">char</span>)*c,<span class="built_in">stdout</span>);<span class="comment">//stdout是标准输出流，这是一个地址，类似于之前汇编接触的演示区域</span></span><br><span class="line">        ++c;<span class="comment">//自增，加载下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);<span class="comment">//该函数会将缓冲区中尚未输出的数据立即写入到文件中，并清空缓冲区。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输入单个字符（Input-Character）"><a href="#输入单个字符（Input-Character）" class="headerlink" title="输入单个字符（Input Character）"></a>输入单个字符（Input Character）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    reg[R_R0] = (<span class="type">uint16_t</span>)getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出单个字符（Output-Character）"><a href="#输出单个字符（Output-Character）" class="headerlink" title="输出单个字符（Output Character）"></a>输出单个字符（Output Character）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    putc((<span class="type">char</span>)reg[R_R0], <span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印输入单个字符提示（Prompt-for-Input-Character）"><a href="#打印输入单个字符提示（Prompt-for-Input-Character）" class="headerlink" title="打印输入单个字符提示（Prompt for Input Character）"></a>打印输入单个字符提示（Prompt for Input Character）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a character: &quot;</span>);</span><br><span class="line">    <span class="type">char</span> c = getchar();</span><br><span class="line">    putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">    reg[R_R0] = (<span class="type">uint16_t</span>)c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出字符串（Output-String）"><a href="#输出字符串（Output-String）" class="headerlink" title="输出字符串（Output String）"></a>输出字符串（Output String）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="type">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">    <span class="keyword">while</span> (*c) &#123;</span><br><span class="line">        <span class="type">char</span> char1 = (*c) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        putc(char1, <span class="built_in">stdout</span>);</span><br><span class="line">        <span class="type">char</span> char2 = (*c) &gt;&gt; <span class="number">8</span>;<span class="comment">//这里细节注意   字符mzy在内存中是 zm ’0‘y因为寻址是16位的两个字节为一组，要想正常打印我们就要将顺序颠倒一下。</span></span><br><span class="line">        <span class="keyword">if</span> (char2) putc(char2, <span class="built_in">stdout</span>);</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="暂停程序执行（Halt-Program）"><a href="#暂停程序执行（Halt-Program）" class="headerlink" title="暂停程序执行（Halt Program）"></a>暂停程序执行（Halt Program）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;HALT&quot;</span>);<span class="comment">//在终端上显示HALT</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);<span class="comment">//立即显示</span></span><br><span class="line">    running = <span class="number">0</span>;<span class="comment">//置零，用于程序的判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_image_file</span><span class="params">(FILE* file)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> origin; <span class="comment">/* the origin tells us where in memory to place the image */</span></span><br><span class="line">    fread(&amp;origin, <span class="keyword">sizeof</span>(origin), <span class="number">1</span>, file);<span class="comment">//用于打开和读取文件</span></span><br><span class="line">    origin = swap16(origin);<span class="comment">//变换字节序，将我们物理机产生的小端数据转换为LC-3的大端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we know the maximum file size so we only need one fread */</span></span><br><span class="line">    <span class="type">uint16_t</span> max_read = UINT16_MAX - origin;<span class="comment">//计算出可以读取的最大字节数</span></span><br><span class="line">    <span class="type">uint16_t</span>* p = memory + origin;<span class="comment">//指针p指向程序入口</span></span><br><span class="line">    <span class="type">size_t</span> read = fread(p, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), max_read, file);</span><br><span class="line"><span class="comment">//从输入流file中读取最多max_read个元素，并将他们存储在以p为起始地址的内存位置中，返回值是读取的元素数存储在read中。</span></span><br><span class="line">    <span class="comment">/* swap to little endian */</span></span><br><span class="line">    <span class="keyword">while</span> (read-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *p = swap16(*p);</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">swap16</span><span class="params">(<span class="type">uint16_t</span> x)</span> &#123;<span class="comment">//变换大小端</span></span><br><span class="line">    <span class="keyword">return</span> (x &lt;&lt; <span class="number">8</span>) | (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对加载程序进行封装，经过封装之后，接受一个文件路径字符串作为参数，这样更加方便。搜嘎，原来这就是封装的奥妙。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_image</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* image_path)</span> &#123;</span><br><span class="line">    FILE* file = fopen(image_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line">    read_image_file(file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存映射寄存器"><a href="#内存映射寄存器" class="headerlink" title="内存映射寄存器"></a>内存映射寄存器</h2><p>一些寄存器不能通过常规的寄存器表进行访问，而内存中储存了特殊的地址，可以通过读写相应的内存地址而达到读写这些寄存器的目的。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520004211.png"></p>
<p>是不是和端口有点关系。</p>
<ul>
<li><code>KBSR</code>：键盘状态寄存器（keyboard status register），表示是否有键按下</li>
<li><code>KBDR</code>：键盘数据寄存器（keyboard data register），表示哪个键按下了</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    MR_KBSR = <span class="number">0xFE00</span>, <span class="comment">/* keyboard status */</span></span><br><span class="line">    MR_KBDR = <span class="number">0xFE02</span>  <span class="comment">/* keyboard data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>访问方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span> &#123;</span><br><span class="line">    memory[address] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == MR_KBSR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_key()) &#123;</span><br><span class="line">            memory[MR_KBSR] = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">            memory[MR_KBDR] = getchar();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memory[MR_KBSR] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="完整的虚拟机"><a href="#完整的虚拟机" class="headerlink" title="完整的虚拟机"></a>完整的虚拟机</h1><p>运行时需要传参    .&#x2F;LC-3\ VM.exe 2048.obj 就可以玩2048了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* windows only */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span>  <span class="comment">// _kbhit</span></span></span><br><span class="line"><span class="type">uint16_t</span> memory[UINT16_MAX];<span class="comment">//每个存储单元存储一个16位的值</span></span><br><span class="line"><span class="comment">//&#123;Memory Mapped Registers&#125;</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">check_key</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MR_KBSR = <span class="number">0xFE00</span>, <span class="comment">/* keyboard status */</span></span><br><span class="line">    MR_KBDR = <span class="number">0xFE02</span>  <span class="comment">/* keyboard data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    memory[address] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == MR_KBSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_key())</span><br><span class="line">        &#123;</span><br><span class="line">            memory[MR_KBSR] = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">            memory[MR_KBDR] = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            memory[MR_KBSR] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[address];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//陷阱代码</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TRAP_GETC = <span class="number">0x20</span>,  <span class="comment">/* get character from keyboard, not echoed onto the terminal */</span></span><br><span class="line">    TRAP_OUT = <span class="number">0x21</span>,   <span class="comment">/* output a character */</span></span><br><span class="line">    TRAP_PUTS = <span class="number">0x22</span>,  <span class="comment">/* output a word string */</span></span><br><span class="line">    TRAP_IN = <span class="number">0x23</span>,    <span class="comment">/* get character from keyboard, echoed onto the terminal */</span></span><br><span class="line">    TRAP_PUTSP = <span class="number">0x24</span>, <span class="comment">/* output a byte string */</span></span><br><span class="line">    TRAP_HALT = <span class="number">0x25</span>   <span class="comment">/* halt the program */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    R_R0 = <span class="number">0</span>,</span><br><span class="line">    R_R1,</span><br><span class="line">    R_R2,</span><br><span class="line">    R_R3,</span><br><span class="line">    R_R4,</span><br><span class="line">    R_R5,</span><br><span class="line">    R_R6,</span><br><span class="line">    R_R7,</span><br><span class="line">    R_PC, <span class="comment">/* program counter */</span></span><br><span class="line">    R_COND,</span><br><span class="line">    R_COUNT</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint16_t</span> reg[R_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    OP_BR = <span class="number">0</span>, <span class="comment">/* branch */</span></span><br><span class="line">    OP_ADD,    <span class="comment">/* add  */</span></span><br><span class="line">    OP_LD,     <span class="comment">/* load */</span></span><br><span class="line">    OP_ST,     <span class="comment">/* store */</span></span><br><span class="line">    OP_JSR,    <span class="comment">/* jump register */</span></span><br><span class="line">    OP_AND,    <span class="comment">/* bitwise and */</span></span><br><span class="line">    OP_LDR,    <span class="comment">/* load register */</span></span><br><span class="line">    OP_STR,    <span class="comment">/* store register */</span></span><br><span class="line">    OP_RTI,    <span class="comment">/* unused */</span></span><br><span class="line">    OP_NOT,    <span class="comment">/* bitwise not */</span></span><br><span class="line">    OP_LDI,    <span class="comment">/* load indirect */</span></span><br><span class="line">    OP_STI,    <span class="comment">/* store indirect */</span></span><br><span class="line">    OP_JMP,    <span class="comment">/* jump */</span></span><br><span class="line">    OP_RES,    <span class="comment">/* reserved (unused) */</span></span><br><span class="line">    OP_LEA,    <span class="comment">/* load effective address */</span></span><br><span class="line">    OP_TRAP    <span class="comment">/* execute trap */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HANDLE hStdin = INVALID_HANDLE_VALUE;</span><br><span class="line">DWORD fdwMode, fdwOldMode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_input_buffering</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    hStdin = GetStdHandle(STD_INPUT_HANDLE);</span><br><span class="line">    GetConsoleMode(hStdin, &amp;fdwOldMode); <span class="comment">/* save old mode */</span></span><br><span class="line">    fdwMode = fdwOldMode</span><br><span class="line">        ^ ENABLE_ECHO_INPUT  <span class="comment">/* no input echo */</span></span><br><span class="line">        ^ ENABLE_LINE_INPUT; <span class="comment">/* return when one or</span></span><br><span class="line"><span class="comment">                                more characters are available */</span></span><br><span class="line">    SetConsoleMode(hStdin, fdwMode); <span class="comment">/* set new mode */</span></span><br><span class="line">    FlushConsoleInputBuffer(hStdin); <span class="comment">/* clear buffer */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">restore_input_buffering</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetConsoleMode(hStdin, fdwOldMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">check_key</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> WaitForSingleObject(hStdin, <span class="number">1000</span>) == WAIT_OBJECT_0 &amp;&amp; _kbhit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_interrupt</span><span class="params">(<span class="type">int</span> signal)</span></span><br><span class="line">&#123;</span><br><span class="line">    restore_input_buffering();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">sign_extend</span><span class="params">(<span class="type">uint16_t</span> x, <span class="type">int</span> bit_count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x &gt;&gt; (bit_count - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        x |= (<span class="number">0xFFFF</span> &lt;&lt; bit_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">swap16</span><span class="params">(<span class="type">uint16_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &lt;&lt; <span class="number">8</span>) | (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FL_POS = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">/* P */</span></span><br><span class="line">    FL_ZRO = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">/* Z */</span></span><br><span class="line">    FL_NEG = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">/* N */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update_flags</span><span class="params">(<span class="type">uint16_t</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (reg[r] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_ZRO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (reg[r] &gt;&gt; <span class="number">15</span>) <span class="comment">/* a 1 in the left-most bit indicates negative */</span></span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_NEG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_POS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_image_file</span><span class="params">(FILE* file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* the origin tells us where in memory to place the image */</span></span><br><span class="line">    <span class="type">uint16_t</span> origin;</span><br><span class="line">    fread(&amp;origin, <span class="keyword">sizeof</span>(origin), <span class="number">1</span>, file);</span><br><span class="line">    origin = swap16(origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we know the maximum file size so we only need one fread */</span></span><br><span class="line">    <span class="type">uint16_t</span> max_read = UINT16_MAX - origin;</span><br><span class="line">    <span class="type">uint16_t</span>* p = memory + origin;</span><br><span class="line">    <span class="type">size_t</span> read = fread(p, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), max_read, file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* swap to little endian */</span></span><br><span class="line">    <span class="keyword">while</span> (read-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = swap16(*p);</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read_image</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* image_path)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* file = fopen(image_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line">    read_image_file(file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* show usage string */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lc3 [image-file1] ...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; argc; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!read_image(argv[j]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;failed to load image: %s\n&quot;</span>, argv[j]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGINT, handle_interrupt);</span><br><span class="line">    disable_input_buffering();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* since exactly one condition flag should be set at any given time, set the Z flag */</span></span><br><span class="line">    reg[R_COND] = FL_ZRO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the PC to starting position */</span></span><br><span class="line">    <span class="comment">/* 0x3000 is the default */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> PC_START = <span class="number">0x3000</span> &#125;;</span><br><span class="line">    reg[R_PC] = PC_START;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* FETCH */</span></span><br><span class="line">        <span class="type">uint16_t</span> instr = mem_read(reg[R_PC]++);</span><br><span class="line">        <span class="type">uint16_t</span> op = instr &gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;      <span class="comment">//步骤三、四</span></span><br><span class="line">        <span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//只看9到11位，即目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;<span class="comment">//第一个参数 寄存器编号</span></span><br><span class="line">            <span class="type">uint16_t</span> imm_flag = (instr &gt;&gt; <span class="number">5</span>) &amp; <span class="number">1</span>;<span class="comment">//查看第五位从而确定最后一个参数是寄存器还是立即数</span></span><br><span class="line">            <span class="keyword">if</span> (imm_flag) &#123;<span class="comment">//立即数模式</span></span><br><span class="line">                <span class="type">uint16_t</span> imm5 = sign_extend(instr &amp; <span class="number">0x1f</span>, <span class="number">5</span>);<span class="comment">//短于16bit的值进行符号扩展</span></span><br><span class="line">                reg[r0] = reg[r1] + imm5;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;       <span class="comment">//寄存器模式</span></span><br><span class="line">                <span class="type">uint16_t</span> r2 = instr &amp; <span class="number">0x7</span>;</span><br><span class="line">                reg[r0] = reg[r1] + reg[r2];</span><br><span class="line">            &#125;</span><br><span class="line">            update_flags(r0);<span class="comment">//查看计算的结果并更新标志寄存器</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_AND: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">            <span class="type">uint16_t</span> imm_flag = (instr &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1</span>;<span class="comment">//确定模式</span></span><br><span class="line">            <span class="keyword">if</span> (imm_flag) &#123;</span><br><span class="line">                <span class="type">uint16_t</span> imm5 = sign_extend(instr &amp; <span class="number">0x1f</span>, <span class="number">5</span>);</span><br><span class="line">                reg[r0] = reg[r1] &amp; imm5;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">uint16_t</span> r2 = instr &amp; <span class="number">0x7</span>;</span><br><span class="line">                reg[r0] = reg[r1] &amp; reg[r2];</span><br><span class="line">            &#125;</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_NOT: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">            reg[r0] = ~reg[r1];</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_BR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            <span class="type">uint16_t</span> cond_flag = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="keyword">if</span> (cond_flag &amp; reg[R_COND]) &#123;</span><br><span class="line">                reg[R_PC] += pc_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_JMP: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            reg[R_PC] = reg[r0];</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_JSR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> long_pc_offset = sign_extend(instr &amp; <span class="number">0x7ff</span>, <span class="number">11</span>);</span><br><span class="line">            <span class="type">uint16_t</span> long_flag = (instr &gt;&gt; <span class="number">11</span>) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            reg[R_R7] = reg[R_PC];</span><br><span class="line">            <span class="keyword">if</span> (long_flag) &#123;</span><br><span class="line">                reg[R_PC] += long_pc_offset;  <span class="comment">/* JSR */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                reg[R_PC] = reg[r1]; <span class="comment">/* JSRR */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//终止包含他的循环，并执行下一阶段。结束这次的switch</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LD: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_coffset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            reg[r0] = mem_read(reg[R_PC] + pc_coffset);</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LDI: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//取目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);<span class="comment">//符号扩展，第一个参数是该数的位，第二个参数描述长度</span></span><br><span class="line">            reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset));<span class="comment">//读取指定内存地址处的值加载入目的寄存器</span></span><br><span class="line">            update_flags(r0);<span class="comment">//更新标志寄存器</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LDR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">            reg[r0] = mem_read(reg[r1] + offset);</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LEA: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_coffset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            reg[r0] = reg[R_PC] + pc_coffset;</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_ST: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            mem_write(reg[R_PC] + pc_offset, reg[r0]);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_STI: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_STR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">            mem_write(reg[r1] + offset, reg[r0]);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_TRAP:</span><br><span class="line">            reg[R_R7] = reg[R_PC];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (instr &amp; <span class="number">0xFF</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> TRAP_GETC:</span><br><span class="line">            &#123;</span><br><span class="line">                reg[R_R0] = (<span class="type">uint16_t</span>)getchar();</span><br><span class="line">                update_flags(R_R0); </span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_OUT:</span><br><span class="line">            &#123;</span><br><span class="line">                putc((<span class="type">char</span>)reg[R_R0], <span class="built_in">stdout</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_PUTS:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* one char per word */</span></span><br><span class="line">                <span class="type">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">                <span class="keyword">while</span> (*c)</span><br><span class="line">                &#123;</span><br><span class="line">                    putc((<span class="type">char</span>)*c, <span class="built_in">stdout</span>);</span><br><span class="line">                    ++c;</span><br><span class="line">                &#125;</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_IN:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Enter a character: &quot;</span>);</span><br><span class="line">                <span class="type">char</span> c = getchar();</span><br><span class="line">                putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">                reg[R_R0] = (<span class="type">uint16_t</span>)c;</span><br><span class="line">                update_flags(R_R0);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_PUTSP:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* one char per byte (two bytes per word)</span></span><br><span class="line"><span class="comment">                   here we need to swap back to</span></span><br><span class="line"><span class="comment">                   big endian format */</span></span><br><span class="line">                <span class="type">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">                <span class="keyword">while</span> (*c)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> char1 = (*c) &amp; <span class="number">0xFF</span>;</span><br><span class="line">                    putc(char1, <span class="built_in">stdout</span>);</span><br><span class="line">                    <span class="type">char</span> char2 = (*c) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">                    <span class="keyword">if</span> (char2) putc(char2, <span class="built_in">stdout</span>);</span><br><span class="line">                    ++c;</span><br><span class="line">                &#125;</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_HALT:</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;HALT&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_RES:</span><br><span class="line">        <span class="keyword">case</span> OP_RTI:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    restore_input_buffering();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520140311.png"></p>
<p>其实整个虚拟机跟着做完人还处于一种比较懵逼的状态，我写了个虚拟机是干啥的？？？？实操了一下，这个虚拟机和我一开始接触的VMware不一样，这更像是一个翻译机器，我们可以用lc-3的汇编语言编写程序，然后用汇编器生成二进制文件，我们编写的这个程序就可以执行这个二进制文件。比如我们编写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.ORIG X3000 ;.ORIG是伪操作符</span><br><span class="line">LEA R0,string     </span><br><span class="line">PUTS</span><br><span class="line">HALT</span><br><span class="line">string .STRINGZ &quot;Hello,word!&quot;</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>

<p>这个汇编程序可以实现将hello word打印在屏幕上。具体的实现步骤</p>
<p>1.首先在模拟器中用汇编语言编写</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520145408.png"></p>
<p>2.将其保存为.asm文件</p>
<p>3.点击asm创建.obj文件</p>
<p>然后我们就可以通过 .&#x2F;LC-3\ VM.exe hello.obj来实现</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520145639.png"></p>
<p>工作流程：</p>
<ol>
<li>读取镜像文件,加载到内存</li>
<li>PC寄存器设置为0x3000,指向第一条指令</li>
<li>重复取指-译码-执行</li>
<li>遇到HALT指令后,退出模拟,程序结束。</li>
</ol>
<p>将二进制(机器码)翻译成高级语言，我们可以再套一层虚拟机，将我们的c语言转变成这个汇编。通过这次虚拟机的实现过程，对计算机行为有了更进一步的了解。</p>
<p><a href="https://www.jmeiners.com/lc3-vm/"><a href="https://www.jmeiners.com/lc3-vm/">Write your Own Virtual Machine (jmeiners.com)</a></a></p>
]]></content>
  </entry>
</search>
